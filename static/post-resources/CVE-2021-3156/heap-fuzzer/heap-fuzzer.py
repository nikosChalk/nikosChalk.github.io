

import random
import shlex
import os
import re
import json
import string
from pathlib import Path
from joblib import Parallel, delayed # let's go parallel!
from pwn import *

# Script that perform heap feng shui.
# The script generates arguments of variable size and then runs the binary through gdb.
# The results are stored in results-* folder.

Path("results-crashes").mkdir(exist_ok=True)

def coin_flip(a=True, b=False):
    return a if random.randint(0,1) == 1 else b
def chance(probability: float, a: any=True, b: any =False):
    assert(probability >= 0 and probability <= 1)
    return a if random.randint(0, 1000) <= probability*1000 else b
            
def fuzz_args_crashes(outname: str):
    # The gdb script hooks whenever the binary stops (e.g. SIGSEGV, SIGABRT, etc.)
    # and saves a lightweight state (registers, context, backtrace)
    
    def gen_arg(c: str, minrepeat=1, maxrepeat=-1):
        # https://elixir.bootlin.com/glibc/glibc-2.36/source/malloc/malloc.c#L1547
        if minrepeat != -1 and maxrepeat != -1:
            assert(minrepeat<=maxrepeat)
        mul=1
        flip = random.randint(0,128-1)
        if flip < 64:
            mul = random.randint(1,8-1)
        elif flip < 96:
            mul = random.randint(8,64-1)
        elif flip < 112:
            mul = random.randint(64,512-1)
        elif flip < 120:
            mul = random.randint(512,4096-1)
        elif flip < 122:
            mul = random.randint(4096,8192-1) # augmented
        # Normal value causes OSError: [Errno 7] Argument list too long: '
        # elif flip < :
        #     mul = random.randint(32768,262144-1)
        # elif flip < :
        #     mul = random.randint(262144, 262144+0x100-1)
        else:
            mul = random.randint(1, 512-1)
        res = c*mul
        if maxrepeat > 0:
            res = res[:maxrepeat]
        if minrepeat > 0 and len(res) < minrepeat:
            res += (minrepeat-len(res))*c
        
        if minrepeat != -1:
            assert(len(res)>=minrepeat)
        if maxrepeat != -1:
            assert(len(res)<=maxrepeat)
        return res
    
    HAS_PWNDBG=False #TODO: Detect dynamically
    progname_fuzz = gen_arg("/", maxrepeat=512)
    cmd = [
        # '/usr/bin/stdbuf', '-o', '0',
        'gdb', '-q',
        '-iex', 'set confirm off',
        '-iex', 'set pagination off',
        '-iex', 'set disable-randomization on',
        '-iex', f'set exec-wrapper ./gdb-argv0-wrapper.sh ./{progname_fuzz}0edit',
        '-x', './gdbscript.py',
    ]
    if HAS_PWNDBG:
        cmd.extend([
            '-iex', 'set context-output /dev/null',
            '-iex', 'set show-tips off',
            '-iex', 'set disable-colors on',
        ])
    else:
        cmd.extend([
            '--nh',
        ])
    cmd.extend(['--args', './0edit'])
    args  = []
    args += ['-hB']
    args += ['-i']
    args += [gen_arg('A', minrepeat=20) + '\\' + chance(0.1, gen_arg('\\', maxrepeat=20), '')] # must end with backslash
    args += [gen_arg('B', minrepeat=20, maxrepeat=250)] # total argv size control. Will be used to overflow things.
    args += [gen_arg('B', maxrepeat=150)] # total argv size control. Will be used to overflow things.
    args += [gen_arg('B', maxrepeat=100)] # total argv size control. Will be used to overflow things.
    args += [gen_arg('B', maxrepeat=50)]  # total argv size control. Will be used to overflow things.
    if coin_flip(0.05): # argc control (aggressive allocations)
        for _ in range(random.randint(0, 50)):
            args += [gen_arg('b', maxrepeat=50)]

    cmd.extend(args)
    # print(cmd)

    ENV=dict(os.environ)
    process_env=OrderedDict()
    process_env['PWNLIB_NOTERM'] = '1'
    process_env['PATH']=ENV['PATH']
    process_env['HOME']=ENV['HOME']
    process_env['LC_CTYPE']='C.UTF-8' # default
    if HAS_PWNDBG:
        process_env['LC_CTYPE']='C.UTF-8' # required for pwndbg
    elif coin_flip():
        # fuzz
        if chance(0.2):
            process_env['LC_COLLATE']       = gen_arg('C')
        if chance(0.2):
            process_env['LC_CTYPE']         = gen_arg('D')
        if chance(0.2):
            process_env['LC_IDENTIFICATION']= gen_arg('E')
        if chance(0.2):
            process_env['LC_MEASUREMENT']   = gen_arg('F')
        if chance(0.2):
            process_env['LC_MESSAGES']      = gen_arg('G')
        if chance(0.2):
            process_env['LC_MONETARY']      = gen_arg('H')
        if chance(0.2):
            process_env['LC_NAME']          = gen_arg('I')
        if chance(0.2):
            process_env['LC_NUMERIC']       = gen_arg('J')
        if chance(0.2):
            process_env['LC_PAPER']         = gen_arg('K')
        if chance(0.2):
            process_env['LC_TELEPHONE']     = gen_arg('F')
        if chance(0.2):
            process_env['LC_TIME']          = gen_arg('M')

    if coin_flip():
        process_env['TZ']           = gen_arg('N')
    if coin_flip():
        process_env['LOCPATH']      = gen_arg('O')
    if coin_flip():
        process_env['LANG']         = gen_arg('P')
    if coin_flip():
        process_env['GCONV_PATH']   = gen_arg('Q')
    
    if chance(1/20):
        for _ in range(random.randint(1, 700)):
            if coin_flip():
                key=''
                for _ in range(10):
                    key += random.choice(string.ascii_uppercase)
                process_env[key] = gen_arg('R')

    # total env size control
    if coin_flip():
        process_env[gen_arg('Y')]=gen_arg(random.choice(string.digits+'\\'))

    io = process(cmd, env=process_env)
    raw_output = io.recvall() # decode() here was hanging sometimes - no clue why
    io.close()
    # for l in raw_output.splitlines():
    #     print(l)
    # exit(0)

    m_start = re.search(rb'Inferior stopped:', raw_output)
    if m_start:
        slice = raw_output[m_start.start():].decode()
        lines = [l.strip() for l in slice.splitlines()][1:]
        slice = '\n'.join(lines)
        print(slice)

        data = OrderedDict()
        data['input'] = OrderedDict()
        data['input']['gdbcmd'] = cmd
        data['input']['cmd'] = [f'./{progname_fuzz}0edit'] + args
        data['input']['env'] = process_env
        
        data['output'] = OrderedDict()
        data['output']['raw'] = slice
        data['output']['reason'] = re.search(r'Stop Reason:\n(.+)\ncontext:', slice).group(1).strip()
        data['output']['context'] = slice[re.search(r'context:\n', slice).end():re.search(r'environment:\n', slice).start()].strip()
        
        data['output']['env'] = OrderedDict()
        for l in slice[re.search(r'environment:\n', slice).end():re.search(r'bt:\n', slice).start()].strip().splitlines():
            k, v = l.strip().split('=', 1)
            data['output']['env'][k]=v

        bt = [
            l.strip() for l in 
                slice[re.search(r'\nbt:\n', slice).end():re.search(r'Inferior exited.', slice).start()].strip().splitlines()
        ]
        data['output']['bt'] = []
        for trace in bt:
            trace_raw_args = re.search(r'\((.*)\)', trace).group(1).strip()
            addr_match = re.search(r' (0x[0-9a-f]+) ', trace)
            if ' in ' in trace:
                funcname = trace.split()[3]
            else:
                funcname_pos_end = trace.find(trace_raw_args)-2
                funcname_pos_start = funcname_pos_end
                while trace[funcname_pos_start-1] not in string.whitespace:
                    funcname_pos_start-=1
                funcname = trace[funcname_pos_start:funcname_pos_end]
                
            data['output']['bt'].append({
                'raw'   : trace,
                'num'   : trace.split()[0][1:], # disregard the '#' symbol
                'addr'  : addr_match.group(1) if addr_match else "0", # NULL in case we don't have it
                'funcname' : funcname,
                'args'     : [arg.strip() for arg in trace_raw_args.split(',')] if len(trace_raw_args)>0 else [],
                'filename' : trace.split()[-1] if ' at ' in trace else '',
            })
        exit_code = re.search(r'exit code: (.+)', slice).group(1).strip()
        if exit_code == 'unavailable':
            exit_code = 300 # impossible for a process to return
        data['output']['exit_code'] = exit_code
        
        serialized=json.dumps(data, indent=2)
        # print(serialized)
        with open(Path("results-crashes") / outname, 'w') as f:
            f.write(serialized)

# FIXME: Run this command on your host OS (won't work in docker)
# os.system('echo 0 | sudo tee /proc/sys/kernel/randomize_va_space')

LAST_SAVED_ITERATION=0
N=1000000
Parallel(n_jobs=8, verbose=10)(
    delayed(fuzz_args_crashes)(f'inp.{i}') for i in range(LAST_SAVED_ITERATION, N)
)
